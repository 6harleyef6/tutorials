{
    "docs": [
        {
            "location": "/",
            "text": "Tutorials for Zend Framework\n\n\nThis repository contains tutorials for learning Zend Framework, particularly\naround building zend-mvc applications.\n\n\nPlease see the \ngenerated documentation\n.",
            "title": "Home"
        },
        {
            "location": "/#tutorials-for-zend-framework",
            "text": "This repository contains tutorials for learning Zend Framework, particularly\naround building zend-mvc applications.  Please see the  generated documentation .",
            "title": "Tutorials for Zend Framework"
        },
        {
            "location": "/getting-started/overview/",
            "text": "Getting Started with Zend Framework MVC Applications\n\n\nThis tutorial is intended to give an introduction to using Zend Framework 2 by creating a simple database driven application using the Model-View-Controller paradigm. By the end you will have a working ZF2 application and you can then poke around the code to find out more about how it all works and fits together.\n\n\nSome assumptions\n\n\nThis tutorial assumes that you are running at least PHP 5.6 with the Apache\nweb server and MySQL, accessible via the PDO extension. Your Apache installation\nmust have the \nmod_rewrite\n extension installed and configured.\n\n\nYou must also ensure that Apache is configured to support \n.htaccess\n files.\nThis is usually done by changing the setting:\n\n\nAllowOverride None\n\n\n\n\nto\n\n\nAllowOverride FileInfo\n\n\n\n\nin your \nhttpd.conf\n file. Check with your distribution\u2019s documentation for\nexact details. You will not be able to navigate to any page other than the home\npage in this tutorial if you have not configured \nmod_rewrite\n and \n.htaccess\n\nusage correctly.\n\n\n\n\nGetting started faster\n\n\nAlternatively, you can use any of the following as well:\n\n\n\n\nThe built-in web server in PHP. Run \nphp -S 0.0.0.0:8080 -t public/\n  public/index.php\n in your application root to start a web server listening\n  on port 8080.\n\n\nUse the shipped \nVagrantfile\n, by executing \nvagrant up\n from the\n  application root. This binds the host machine's port 8080 to the Apache\n  server instance running on the Vagrant image.\n\n\nUse the shipped \ndocker-compose\n\n  integration, by executing \ndocker-compose up -d --build\n from the\n  application root. This binds the host machine's port 8080 to the Apache\n  server instance running container.\n\n\n\n\n\n\nThe tutorial application\n\n\nThe application that we are going to build is a simple inventory system to\ndisplay which albums we own. The main page will list our collection and allow us\nto add, edit and delete CDs. We are going to need four pages in our website:\n\n\n\n\n\n\n\n\nPage\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nList of albums\n\n\nThis will display the list of albums and provide links to edit and delete them. Also, a link to enable adding new albums will be provided.\n\n\n\n\n\n\nAdd new album\n\n\nThis page will provide a form for adding a new album.\n\n\n\n\n\n\nEdit album\n\n\nThis page will provide a form for editing an album.\n\n\n\n\n\n\nDelete album\n\n\nThis page will confirm that we want to delete an album and then delete it.\n\n\n\n\n\n\n\n\nWe will also need to store our data into a database. We will only need one table\nwith these fields in it:\n\n\n\n\n\n\n\n\nField name\n\n\nType\n\n\nNull?\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nid\n\n\ninteger\n\n\nNo\n\n\nPrimary key, auto-increment\n\n\n\n\n\n\nartist\n\n\nvarchar(100)\n\n\nNo\n\n\n\n\n\n\n\n\ntitle\n\n\nvarchar(100)\n\n\nNo",
            "title": "Overview"
        },
        {
            "location": "/getting-started/overview/#getting-started-with-zend-framework-mvc-applications",
            "text": "This tutorial is intended to give an introduction to using Zend Framework 2 by creating a simple database driven application using the Model-View-Controller paradigm. By the end you will have a working ZF2 application and you can then poke around the code to find out more about how it all works and fits together.",
            "title": "Getting Started with Zend Framework MVC Applications"
        },
        {
            "location": "/getting-started/overview/#some-assumptions",
            "text": "This tutorial assumes that you are running at least PHP 5.6 with the Apache\nweb server and MySQL, accessible via the PDO extension. Your Apache installation\nmust have the  mod_rewrite  extension installed and configured.  You must also ensure that Apache is configured to support  .htaccess  files.\nThis is usually done by changing the setting:  AllowOverride None  to  AllowOverride FileInfo  in your  httpd.conf  file. Check with your distribution\u2019s documentation for\nexact details. You will not be able to navigate to any page other than the home\npage in this tutorial if you have not configured  mod_rewrite  and  .htaccess \nusage correctly.",
            "title": "Some assumptions"
        },
        {
            "location": "/getting-started/overview/#getting-started-faster",
            "text": "Alternatively, you can use any of the following as well:   The built-in web server in PHP. Run  php -S 0.0.0.0:8080 -t public/\n  public/index.php  in your application root to start a web server listening\n  on port 8080.  Use the shipped  Vagrantfile , by executing  vagrant up  from the\n  application root. This binds the host machine's port 8080 to the Apache\n  server instance running on the Vagrant image.  Use the shipped  docker-compose \n  integration, by executing  docker-compose up -d --build  from the\n  application root. This binds the host machine's port 8080 to the Apache\n  server instance running container.",
            "title": "Getting started faster"
        },
        {
            "location": "/getting-started/overview/#the-tutorial-application",
            "text": "The application that we are going to build is a simple inventory system to\ndisplay which albums we own. The main page will list our collection and allow us\nto add, edit and delete CDs. We are going to need four pages in our website:     Page  Description      List of albums  This will display the list of albums and provide links to edit and delete them. Also, a link to enable adding new albums will be provided.    Add new album  This page will provide a form for adding a new album.    Edit album  This page will provide a form for editing an album.    Delete album  This page will confirm that we want to delete an album and then delete it.     We will also need to store our data into a database. We will only need one table\nwith these fields in it:     Field name  Type  Null?  Notes      id  integer  No  Primary key, auto-increment    artist  varchar(100)  No     title  varchar(100)  No",
            "title": "The tutorial application"
        },
        {
            "location": "/getting-started/skeleton-application/",
            "text": "Getting started: A skeleton application\n\n\nIn order to build our application, we will start with the\n\nZendSkeletonApplication\n\navailable on \ngithub\n. Use \nComposer\n\nto create a new project from scratch:\n\n\n$ composer create-project -s dev zendframework/skeleton-application path/to/install\n\n\n\n\nThis will install an initial set of dependencies, including:\n\n\n\n\nzend-component-installer, which helps automate injection of component\n  configuration into your application.\n\n\nzend-mvc, the kernel for MVC applications.\n\n\n\n\nThe default is to provide the minimum amount of dependencies necessary to run a\nzend-mvc application. However, you may have additional needs that you know at\nthe outset, and, as such, the skeleton also ships with an installer plugin that\nwill prompt you for a number of items.\n\n\nFirst, it will prompt:\n\n\n    Do you want a minimal install (no optional packages)? Y/n\n\n\n\n\n\n\nPrompts and default values\n\n\nAll prompts emitted by the installer provide the list of options available,\nand will specify the default option via a capital letter. Default values are\nused if the user presses \"Enter\" with no value. In the previous example, \"Y\"\nis the default.\n\n\n\n\nIf you answer \"Y\", or press enter with no selection, the installer will not\nraise any additional prompts, and finish installing your application. If you\nanser \"n\", it will continue prompting you:\n\n\n    Would you like to install caching support? y/N\n\n\n\n\nWe will not be demonstrating caching in this tutorial, so either hit \"Enter\", or\n\"n\" followed by \"Enter\".\n\n\n    Would you like to install database support (installs zend-db)? y/N\n\n\n\n\nWe \nwill\n be using zend-db extensively in this tutorial, so hit \"y\" followed by\n\"Enter\". You should see the following text appear:\n\n\n    Will install zendframework/zend-db (^2.8.1)\n    When prompted to install as a module, select application.config.php or modules.config.php\n\n\n\n\nThe next prompt is:\n\n\n    Would you like to install forms support (installs zend-form)? y/N\n\n\n\n\nThis tutorial also uses zend-form, so we will again select \"y\" to install this;\ndoing so emits a similar message to that used for zend-db.\n\n\nAt this point, we can answer \"n\" to the remaining features:\n\n\n    Would you like to install JSON de/serialization support? y/N\n    Would you like to install logging support? y/N\n    Would you like to install MVC-based console support? (We recommend migrating to zf-console, symfony/console, or Aura.CLI) y/N\n    Would you like to install i18n support? y/N\n    Would you like to install the official MVC plugins, including PRG support, identity, and flash messages? y/N\n    Would you like to use the PSR-7 middleware dispatcher? y/N\n    Would you like to install sessions support? y/N\n    Would you like to install MVC testing support? y/N\n    Would you like to install the zend-di integration for zend-servicemanager? y/N\n\n\n\n\nAt a certain point, you'll see the following text:\n\n\nUpdating root package\n    Running an update to install optional packages\n\n...\n\nUpdating application configuration...\n\n  Please select which config file you wish to inject 'Zend\\Db' into:\n  [0] Do not inject\n  [1] config/application.config.php\n  Make your selection (default is 0):\n\n\n\n\nWe want to enable the various selections we made in the application. As such,\nwe'll choose \n1\n, which will then give us the following prompt:\n\n\n  Remember this option for other packages of the same type? (y/N)\n\n\n\n\nIn our case, we can safely say \"y\", which will mean we will no longer be\nprompted for additional packages. (The only package in the default set of\nprompts that you may not want to enable by default is \nZend\\Test\n.)\n\n\nOnce the installation is done, the skeleton installer removes itself, and the\nnew application is ready to start!\n\n\n\n\nDownloading the skeleton\n\n\nAnother way to install the ZendSkeletonApplication is to use github to\ndownload a compressed archive. Go to\nhttps://github.com/zendframework/ZendSkeletonApplication, click the \"Clone or\ndownload\" button, and select \"Download ZIP\". This will download a file with a\nname like \nZendSkeletonApplication-master.zip\n or similar.\n\n\nUnzip this file into the directory where you keep all your vhosts and rename\nthe resultant directory to \nzf2-tutorial\n.\n\n\nZendSkeletonApplication is set up to use \nComposer\n\nto resolve its dependencies. Run the following from within your new\nzf2-tutorial folder to install them:\n\n\n$ composer self-update\n$ composer install\n\n\n\n\nThis takes a while. You should see output like the following:\n\n\nInstalling dependencies from lock file\n- Installing zendframework/zend-component-installer (0.2.0)\n  \n...\n\nGenerating autoload files\n\n\n\n\nAt this point, you will be prompted to answer questions as noted above.\n\n\nAlternately, if you do not have Composer installed, but \ndo\n have either\nVagrant or docker-compose available, you can run Composer via those:\n\n\n# For Vagrant:\n$ vagrant up\n$ vagrant ssh -c 'composer install'\n# For docker-compose:\n$ docker-compose build\n$ docker-compose run zf composer install\n\n\n\n\nTimeouts\n\n\nIf you see this message:\n\n\n[RuntimeException]      \n  The process timed out. \n\n\n\n\nthen your connection was too slow to download the entire package in time, and\ncomposer timed out. To avoid this, instead of running:\n\n\n$ composer install\n\n\n\n\nrun instead:\n\n\n$ COMPOSER_PROCESS_TIMEOUT=5000 composer install\n\n\n\n\nWindows users using WAMP\n\n\nFor windows users with wamp:\n\n\n\n\nInstall \ncomposer for windows\n.\n   Check composer is properly installed by running:\n\n\n\n\n$ composer\n\n\n\n\n\n\nInstall \nGitHub Desktop\n for windows.\n     Check git is properly installed by running:\n\n\n\n\n$ git\n\n\n\n\n\n\nNow install the skeleton using:\n\n\n\n\n$ composer create-project -s dev zendframework/skeleton-application path/to/install\n\n\n\n\n\n\nWe can now move on to the web server setup.\n\n\nWeb Servers\n\n\nIn this tutorial, we will step you through four different ways to setup your web\nserver:\n\n\n\n\nVia the PHP built-in web server.\n\n\nVia Vagrant.\n\n\nVia docker-compose.\n\n\nUsing Apache.\n\n\n\n\nUsing the Built-in PHP web Server\n\n\nYou can use PHP's built-in web server when developing your application. To do\nthis, start the server from the project's root directory:\n\n\n$ php -S 0.0.0.0:8080 -t public/ public/index.php\n\n\n\n\nThis will make the website available on port 8080 on all network interfaces,\nusing \npublic/index.php\n to handle routing. This means the site is accessible\nvia \nhttp://localhost:8080\n or \nhttp://<your-local-IP>:8080\n.\n\n\nIf you\u2019ve done it right, you should see the following.\n\n\n\n\nTo test that your routing is working, navigate to \nhttp://localhost:8080/1234\n,\nand you should see the following 404 page:\n\n\n\n\n\n\nDevelopment only\n\n\nPHP's built-in web server should be used \nfor development only\n.\n\n\n\n\nUsing Vagrant\n\n\nVagrant\n provides a way to describe and provision\nvirtual machines, and is a common way to provide a coherent and consistent\ndevelopment environment for development teams. The skeleton application provides\na \nVagrantfile\n based on Ubuntu 14.04, and using the \nondrej/php\n PPA to provide\nPHP 7.0. Start it up using:\n\n\n$ vagrant up\n\n\n\n\nOnce it has been built and is running, you can also run composer from the\nvirtual machine. As an example, the following will install dependencies:\n\n\n$ vagrant ssh -c 'composer install'\n\n\n\n\nwhile this will update them:\n\n\n$ vagrant ssh -c 'composer update'\n\n\n\n\nThe image uses Apache 2.4, and maps the host port 8080 to port 80 on the virtual\nmachine.\n\n\nUsing docker-compose\n\n\nDocker\n containers wrap a piece of software and everything needed to run it,\nguaranteeing consistent operation regardless of the host environment; it is an\nalternative to virtual machines, as it runs as a layer on top of the host\nenvironment.\n\n\ndocker-compose\n is a tool for automating\nconfiguration of containers and composing dependencies between them, such as\nvolume storage, networking, etc.\n\n\nThe skeleton application ships with a \nDockerfile\n and configuration for\ndocker-compose; we recommend using docker-compose, as it provides a foundation\nfor mapping additional containers you might need as part of your application,\nincluding a database server, cache servers, and more. To build and start the\nimage, use:\n\n\n$ docker-compose up -d --build\n\n\n\n\nAfter the first build, you can truncate this to:\n\n\n$ docker-compose up -d\n\n\n\n\nOnce built, you can also run commands on the container. The docker-compose\nconfiguration initially only defines one container, with the environment name\n\"zf\"; use that to execute commands, such as updating dependencies via composer:\n\n\n$ docker-compose run zf composer update\n\n\n\n\nThe configuration includes both PHP 7.0 and Apache 2.4, and maps the host port\n8080 to port 80 of the container.\n\n\nUsing the Apache Web Server\n\n\nWe will not cover installing \nApache\n, and will assume\nyou already have it installed. We recommend installing Apache 2.4, and will only\ncover configuration for that version.\n\n\nYou now need to create an Apache virtual host for the application and edit your\nhosts file so that \nhttp://zf2-tutorial.localhost\n will serve \nindex.php\n from\nthe \nzf2-tutorial/public/\n directory.\n\n\nSetting up the virtual host is usually done within \nhttpd.conf\n or\n\nextra/httpd-vhosts.conf\n. If you are using \nhttpd-vhosts.conf\n, ensure that\nthis file is included by your main \nhttpd.conf\n file. Some Linux distributions\n(ex: Ubuntu) package Apache so that configuration files are stored in\n\n/etc/apache2\n and create one file per virtual host inside folder\n\n/etc/apache2/sites-enabled\n. In this case, you would place the virtual host\nblock below into the file \n/etc/apache2/sites-enabled/zf2-tutorial\n.\n\n\nEnsure that \nNameVirtualHost\n is defined and set to \n*:80\n or similar, and then\ndefine a virtual host along these lines:\n\n\n<VirtualHost *:80>\n    ServerName zf2-tutorial.localhost\n    DocumentRoot /path/to/zf2-tutorial/public\n    SetEnv APPLICATION_ENV \"development\"\n    <Directory /path/to/zf2-tutorial/public>\n        DirectoryIndex index.php\n        AllowOverride All\n        Require all granted\n    </Directory>\n</VirtualHost>\n\n\n\n\nMake sure that you update your \n/etc/hosts\n or\n\nc:\\windows\\system32\\drivers\\etc\\hosts\n file so that \nzf2-tutorial.localhost\n is\nmapped to \n127.0.0.1\n. The website can then be accessed using\n\nhttp://zf2-tutorial.localhost\n.\n\n\n127.0.0.1 zf2-tutorial.localhost localhost\n\n\n\n\nRestart Apache.\n\n\nIf you've done so correctly, you will get the same results as covered under\n\nthe PHP built-in web server\n.\n\n\nTo test that your \n.htaccess\n file is working, navigate to\n\nhttp://zf2-tutorial.localhost/1234\n, and you should see the 404 page as noted\nearlier.  If you see a standard Apache 404 error, then you need to fix your\n\n.htaccess\n usage before continuing.\n\n\nIf you're are using IIS with the URL Rewrite Module, import the following:\n\n\nRewriteCond %{REQUEST_FILENAME} !-f\nRewriteRule ^ index.php [NC,L]\n\n\n\n\nYou now have a working skeleton application and we can start adding the specifics for our application.\n\n\nError reporting\n\n\nOptionally, \nwhen using Apache\n, you can use the \nAPPLICATION_ENV\n setting in\nyour \nVirtualHost\n to let PHP output all its errors to the browser. This can be\nuseful during the development of your application.\n\n\nEdit \nzf2-tutorial/public/index.php\n directory and change it to the following:\n\n\n<?php\n\nuse Zend\\Mvc\\Application;\n\n/**\n * Display all errors when APPLICATION_ENV is development.\n */\nif ($_SERVER['APPLICATION_ENV'] === 'development') {\n    error_reporting(E_ALL);\n    ini_set(\"display_errors\", 1);\n}\n\n/**\n * This makes our life easier when dealing with paths. Everything is relative\n * to the application root now.\n */\nchdir(dirname(__DIR__));\n\n// Decline static file requests back to the PHP built-in webserver\nif (php_sapi_name() === 'cli-server') {\n    $path = realpath(__DIR__ . parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH));\n    if (__FILE__ !== $path && is_file($path)) {\n        return false;\n    }\n    unset($path);\n}\n\n// Composer autoloading\ninclude __DIR__ . '/../vendor/autoload.php';\n\nif (! class_exists(Application::class)) {\n    throw new RuntimeException(\n        \"Unable to load application.\\n\"\n        . \"- Type `composer install` if you are developing locally.\\n\"\n        . \"- Type `vagrant ssh -c 'composer install'` if you are using Vagrant.\\n\"\n        . \"- Type `docker-compose run zf composer install` if you are using Docker.\\n\"\n    );\n}\n\n// Run the application!\nApplication::init(require __DIR__ . '/../config/application.config.php')->run();",
            "title": "The Skeleton Application"
        },
        {
            "location": "/getting-started/skeleton-application/#getting-started-a-skeleton-application",
            "text": "In order to build our application, we will start with the ZendSkeletonApplication \navailable on  github . Use  Composer \nto create a new project from scratch:  $ composer create-project -s dev zendframework/skeleton-application path/to/install  This will install an initial set of dependencies, including:   zend-component-installer, which helps automate injection of component\n  configuration into your application.  zend-mvc, the kernel for MVC applications.   The default is to provide the minimum amount of dependencies necessary to run a\nzend-mvc application. However, you may have additional needs that you know at\nthe outset, and, as such, the skeleton also ships with an installer plugin that\nwill prompt you for a number of items.  First, it will prompt:      Do you want a minimal install (no optional packages)? Y/n",
            "title": "Getting started: A skeleton application"
        },
        {
            "location": "/getting-started/skeleton-application/#prompts-and-default-values",
            "text": "All prompts emitted by the installer provide the list of options available,\nand will specify the default option via a capital letter. Default values are\nused if the user presses \"Enter\" with no value. In the previous example, \"Y\"\nis the default.   If you answer \"Y\", or press enter with no selection, the installer will not\nraise any additional prompts, and finish installing your application. If you\nanser \"n\", it will continue prompting you:      Would you like to install caching support? y/N  We will not be demonstrating caching in this tutorial, so either hit \"Enter\", or\n\"n\" followed by \"Enter\".      Would you like to install database support (installs zend-db)? y/N  We  will  be using zend-db extensively in this tutorial, so hit \"y\" followed by\n\"Enter\". You should see the following text appear:      Will install zendframework/zend-db (^2.8.1)\n    When prompted to install as a module, select application.config.php or modules.config.php  The next prompt is:      Would you like to install forms support (installs zend-form)? y/N  This tutorial also uses zend-form, so we will again select \"y\" to install this;\ndoing so emits a similar message to that used for zend-db.  At this point, we can answer \"n\" to the remaining features:      Would you like to install JSON de/serialization support? y/N\n    Would you like to install logging support? y/N\n    Would you like to install MVC-based console support? (We recommend migrating to zf-console, symfony/console, or Aura.CLI) y/N\n    Would you like to install i18n support? y/N\n    Would you like to install the official MVC plugins, including PRG support, identity, and flash messages? y/N\n    Would you like to use the PSR-7 middleware dispatcher? y/N\n    Would you like to install sessions support? y/N\n    Would you like to install MVC testing support? y/N\n    Would you like to install the zend-di integration for zend-servicemanager? y/N  At a certain point, you'll see the following text:  Updating root package\n    Running an update to install optional packages\n\n...\n\nUpdating application configuration...\n\n  Please select which config file you wish to inject 'Zend\\Db' into:\n  [0] Do not inject\n  [1] config/application.config.php\n  Make your selection (default is 0):  We want to enable the various selections we made in the application. As such,\nwe'll choose  1 , which will then give us the following prompt:    Remember this option for other packages of the same type? (y/N)  In our case, we can safely say \"y\", which will mean we will no longer be\nprompted for additional packages. (The only package in the default set of\nprompts that you may not want to enable by default is  Zend\\Test .)  Once the installation is done, the skeleton installer removes itself, and the\nnew application is ready to start!",
            "title": "Prompts and default values"
        },
        {
            "location": "/getting-started/skeleton-application/#downloading-the-skeleton",
            "text": "Another way to install the ZendSkeletonApplication is to use github to\ndownload a compressed archive. Go to\nhttps://github.com/zendframework/ZendSkeletonApplication, click the \"Clone or\ndownload\" button, and select \"Download ZIP\". This will download a file with a\nname like  ZendSkeletonApplication-master.zip  or similar.  Unzip this file into the directory where you keep all your vhosts and rename\nthe resultant directory to  zf2-tutorial .  ZendSkeletonApplication is set up to use  Composer \nto resolve its dependencies. Run the following from within your new\nzf2-tutorial folder to install them:  $ composer self-update\n$ composer install  This takes a while. You should see output like the following:  Installing dependencies from lock file\n- Installing zendframework/zend-component-installer (0.2.0)\n  \n...\n\nGenerating autoload files  At this point, you will be prompted to answer questions as noted above.  Alternately, if you do not have Composer installed, but  do  have either\nVagrant or docker-compose available, you can run Composer via those:  # For Vagrant:\n$ vagrant up\n$ vagrant ssh -c 'composer install'\n# For docker-compose:\n$ docker-compose build\n$ docker-compose run zf composer install",
            "title": "Downloading the skeleton"
        },
        {
            "location": "/getting-started/skeleton-application/#timeouts",
            "text": "If you see this message:  [RuntimeException]      \n  The process timed out.   then your connection was too slow to download the entire package in time, and\ncomposer timed out. To avoid this, instead of running:  $ composer install  run instead:  $ COMPOSER_PROCESS_TIMEOUT=5000 composer install",
            "title": "Timeouts"
        },
        {
            "location": "/getting-started/skeleton-application/#windows-users-using-wamp",
            "text": "For windows users with wamp:   Install  composer for windows .\n   Check composer is properly installed by running:   $ composer   Install  GitHub Desktop  for windows.\n     Check git is properly installed by running:   $ git   Now install the skeleton using:   $ composer create-project -s dev zendframework/skeleton-application path/to/install   We can now move on to the web server setup.",
            "title": "Windows users using WAMP"
        },
        {
            "location": "/getting-started/skeleton-application/#web-servers",
            "text": "In this tutorial, we will step you through four different ways to setup your web\nserver:   Via the PHP built-in web server.  Via Vagrant.  Via docker-compose.  Using Apache.",
            "title": "Web Servers"
        },
        {
            "location": "/getting-started/skeleton-application/#using-the-built-in-php-web-server",
            "text": "You can use PHP's built-in web server when developing your application. To do\nthis, start the server from the project's root directory:  $ php -S 0.0.0.0:8080 -t public/ public/index.php  This will make the website available on port 8080 on all network interfaces,\nusing  public/index.php  to handle routing. This means the site is accessible\nvia  http://localhost:8080  or  http://<your-local-IP>:8080 .  If you\u2019ve done it right, you should see the following.   To test that your routing is working, navigate to  http://localhost:8080/1234 ,\nand you should see the following 404 page:",
            "title": "Using the Built-in PHP web Server"
        },
        {
            "location": "/getting-started/skeleton-application/#development-only",
            "text": "PHP's built-in web server should be used  for development only .",
            "title": "Development only"
        },
        {
            "location": "/getting-started/skeleton-application/#using-vagrant",
            "text": "Vagrant  provides a way to describe and provision\nvirtual machines, and is a common way to provide a coherent and consistent\ndevelopment environment for development teams. The skeleton application provides\na  Vagrantfile  based on Ubuntu 14.04, and using the  ondrej/php  PPA to provide\nPHP 7.0. Start it up using:  $ vagrant up  Once it has been built and is running, you can also run composer from the\nvirtual machine. As an example, the following will install dependencies:  $ vagrant ssh -c 'composer install'  while this will update them:  $ vagrant ssh -c 'composer update'  The image uses Apache 2.4, and maps the host port 8080 to port 80 on the virtual\nmachine.",
            "title": "Using Vagrant"
        },
        {
            "location": "/getting-started/skeleton-application/#using-docker-compose",
            "text": "Docker  containers wrap a piece of software and everything needed to run it,\nguaranteeing consistent operation regardless of the host environment; it is an\nalternative to virtual machines, as it runs as a layer on top of the host\nenvironment.  docker-compose  is a tool for automating\nconfiguration of containers and composing dependencies between them, such as\nvolume storage, networking, etc.  The skeleton application ships with a  Dockerfile  and configuration for\ndocker-compose; we recommend using docker-compose, as it provides a foundation\nfor mapping additional containers you might need as part of your application,\nincluding a database server, cache servers, and more. To build and start the\nimage, use:  $ docker-compose up -d --build  After the first build, you can truncate this to:  $ docker-compose up -d  Once built, you can also run commands on the container. The docker-compose\nconfiguration initially only defines one container, with the environment name\n\"zf\"; use that to execute commands, such as updating dependencies via composer:  $ docker-compose run zf composer update  The configuration includes both PHP 7.0 and Apache 2.4, and maps the host port\n8080 to port 80 of the container.",
            "title": "Using docker-compose"
        },
        {
            "location": "/getting-started/skeleton-application/#using-the-apache-web-server",
            "text": "We will not cover installing  Apache , and will assume\nyou already have it installed. We recommend installing Apache 2.4, and will only\ncover configuration for that version.  You now need to create an Apache virtual host for the application and edit your\nhosts file so that  http://zf2-tutorial.localhost  will serve  index.php  from\nthe  zf2-tutorial/public/  directory.  Setting up the virtual host is usually done within  httpd.conf  or extra/httpd-vhosts.conf . If you are using  httpd-vhosts.conf , ensure that\nthis file is included by your main  httpd.conf  file. Some Linux distributions\n(ex: Ubuntu) package Apache so that configuration files are stored in /etc/apache2  and create one file per virtual host inside folder /etc/apache2/sites-enabled . In this case, you would place the virtual host\nblock below into the file  /etc/apache2/sites-enabled/zf2-tutorial .  Ensure that  NameVirtualHost  is defined and set to  *:80  or similar, and then\ndefine a virtual host along these lines:  <VirtualHost *:80>\n    ServerName zf2-tutorial.localhost\n    DocumentRoot /path/to/zf2-tutorial/public\n    SetEnv APPLICATION_ENV \"development\"\n    <Directory /path/to/zf2-tutorial/public>\n        DirectoryIndex index.php\n        AllowOverride All\n        Require all granted\n    </Directory>\n</VirtualHost>  Make sure that you update your  /etc/hosts  or c:\\windows\\system32\\drivers\\etc\\hosts  file so that  zf2-tutorial.localhost  is\nmapped to  127.0.0.1 . The website can then be accessed using http://zf2-tutorial.localhost .  127.0.0.1 zf2-tutorial.localhost localhost  Restart Apache.  If you've done so correctly, you will get the same results as covered under the PHP built-in web server .  To test that your  .htaccess  file is working, navigate to http://zf2-tutorial.localhost/1234 , and you should see the 404 page as noted\nearlier.  If you see a standard Apache 404 error, then you need to fix your .htaccess  usage before continuing.  If you're are using IIS with the URL Rewrite Module, import the following:  RewriteCond %{REQUEST_FILENAME} !-f\nRewriteRule ^ index.php [NC,L]  You now have a working skeleton application and we can start adding the specifics for our application.",
            "title": "Using the Apache Web Server"
        },
        {
            "location": "/getting-started/skeleton-application/#error-reporting",
            "text": "Optionally,  when using Apache , you can use the  APPLICATION_ENV  setting in\nyour  VirtualHost  to let PHP output all its errors to the browser. This can be\nuseful during the development of your application.  Edit  zf2-tutorial/public/index.php  directory and change it to the following:  <?php\n\nuse Zend\\Mvc\\Application;\n\n/**\n * Display all errors when APPLICATION_ENV is development.\n */\nif ($_SERVER['APPLICATION_ENV'] === 'development') {\n    error_reporting(E_ALL);\n    ini_set(\"display_errors\", 1);\n}\n\n/**\n * This makes our life easier when dealing with paths. Everything is relative\n * to the application root now.\n */\nchdir(dirname(__DIR__));\n\n// Decline static file requests back to the PHP built-in webserver\nif (php_sapi_name() === 'cli-server') {\n    $path = realpath(__DIR__ . parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH));\n    if (__FILE__ !== $path && is_file($path)) {\n        return false;\n    }\n    unset($path);\n}\n\n// Composer autoloading\ninclude __DIR__ . '/../vendor/autoload.php';\n\nif (! class_exists(Application::class)) {\n    throw new RuntimeException(\n        \"Unable to load application.\\n\"\n        . \"- Type `composer install` if you are developing locally.\\n\"\n        . \"- Type `vagrant ssh -c 'composer install'` if you are using Vagrant.\\n\"\n        . \"- Type `docker-compose run zf composer install` if you are using Docker.\\n\"\n    );\n}\n\n// Run the application!\nApplication::init(require __DIR__ . '/../config/application.config.php')->run();",
            "title": "Error reporting"
        },
        {
            "location": "/getting-started/modules/",
            "text": "Modules\n\n\nzend-mvc uses a module system to organise your main application-specific\ncode within each module. The \nApplication\n module provided by the skeleton is used\nto provide bootstrapping, error, and routing configuration to the whole\napplication. It is usually used to provide application level controllers for\nthe home page of an application, but we are not going to use the default\none provided in this tutorial as we want our album list to be the home page,\nwhich will live in our own module.\n\n\nWe are going to put all our code into the \nAlbum\n module which will contain our\ncontrollers, models, forms and views, along with configuration. We\u2019ll also tweak\nthe \nApplication\n module as required.\n\n\nLet\u2019s start with the directories required.\n\n\nSetting up the Album module\n\n\nStart by creating a directory called \nAlbum\n under \nmodule\n with the following\nsubdirectories to hold the module\u2019s files:\n\n\nzf2-tutorial/\n    /module\n        /Album\n            /config\n            /src\n                /Controller\n                /Form\n                /Model\n            /view\n                /album\n                    /album\n\n\n\n\nThe \nAlbum\n module has separate directories for the different types of files we\nwill have. The PHP files that contain classes within the \nAlbum\n namespace live\nin the \nsrc/\n directory. The view directory also has a sub-folder called \nalbum\n\nfor our module's view scripts.\n\n\nIn order to load and configure a module, Zend Framework provides a\n\nModuleManager\n.  This will look for a \nModule\n class in the specified module\nnamespace (i.e., \nAlbum\n); in the case of our new module, that means the class\n\nAlbum\\Module\n, which will be found in \nmodule/Album/src/Module.php\n.\n\n\nLet's create that file now, with the following contents:\n\n\nnamespace Album;\n\nuse Zend\\ModuleManager\\Feature\\ConfigProviderInterface;\n\nclass Module implements ConfigProviderInterface\n{\n    public function getConfig()\n    {\n        return include __DIR__ . '/../config/module.config.php';\n    }\n}\n\n\n\n\nThe \nModuleManager\n will call \ngetConfig()\n automatically for us.\n\n\nAutoloading\n\n\nWhile Zend Framework provides autoloading capabilities via its\n\nzend-loader\n component, we\nrecommend using Composer's autoloading capabilities. As such, we need to inform\nComposer of our new namespace, and where its files live.\n\n\nOpen \ncomposer.json\n in your project root, and look for the \nautoload\n section;\nit should look like the following by default:\n\n\n\"autoload\": {\n    \"psr-4\": {\n        \"Application\\\\\": \"module/Application/src/\"\n    }\n},\n\n\n\n\nWe'll now add our new module to the list, so it now reads:\n\n\n\"autoload\": {\n    \"psr-4\": {\n        \"Application\\\\\": \"module/Application/src/\",\n        \"Album\\\\\": \"module/Album/src/\"\n    }\n},\n\n\n\n\nOnce you've made that change, run the following to ensure Composer updates its\nautoloading rules:\n\n\n$ composer dump-autoload\n\n\n\n\nConfiguration\n\n\nHaving registered the autoloader, let\u2019s have a quick look at the \ngetConfig()\n\nmethod in \nAlbum\\Module\n. This method loads the \nconfig/module.config.php\n file\nunder the module's root directory.\n\n\nCreate a file called \nmodule.config.php\n under\n\nzf2-tutorial/module/Album/config/\n:\n\n\nnamespace Album;\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'controllers' => [\n        'factories' => [\n            Controller\\AlbumController::class => InvokableFactory::class,\n        ],\n    ],\n    'view_manager' => [\n        'template_path_stack' => [\n            'album' => __DIR__ . '/../view',\n        ],\n    ],\n];\n\n\n\n\nThe config information is passed to the relevant components by the\n\nServiceManager\n. We need two initial sections: \ncontrollers\n and\n\nview_manager\n. The controllers section provides a list of all the controllers\nprovided by the module. We will need one controller, \nAlbumController\n; we'll\nreference it by its fully qualified class name, and use the zend-servicemanager\n\nInvokableFactory\n to create instances of it.\n\n\nWithin the \nview_manager\n section, we add our view directory to the\n\nTemplatePathStack\n configuration. This will allow it to find the view scripts\nfor the \nAlbum\n module that are stored in our \nview/\n directory.\n\n\nInforming the application about our new module\n\n\nWe now need to tell the \nModuleManager\n that this new module exists. This is\ndone in the application\u2019s \nconfig/application.config.php\n file which is provided\nby the skeleton application. Update this file so that its \nmodules\n section\ncontains the \nAlbum\n module as well, so the file now looks like this:\n\n\n(Changes required are highlighted using comments; original comments from the\nfile are omitted for brevity.)\n\n\nreturn [\n    'modules' => [\n        'Zend\\Form',\n        'Zend\\Db',\n        'Zend\\Router',\n        'Zend\\Validator',\n        'Application',\n        'Album',                  // <-- Add this line\n    ],\n    'module_listener_options' => [\n        'config_glob_paths'    => [\n            'config/autoload/{{,*.}global,{,*.}local}.php',\n        ],\n        'module_paths' => [\n            './module',\n            './vendor',\n        ],\n    ],\n];\n\n\n\n\nAs you can see, we have added our \nAlbum\n module into the list of modules after\nthe \nApplication\n module.\n\n\nWe have now set up the module ready for putting our custom code into it.",
            "title": "Modules"
        },
        {
            "location": "/getting-started/modules/#modules",
            "text": "zend-mvc uses a module system to organise your main application-specific\ncode within each module. The  Application  module provided by the skeleton is used\nto provide bootstrapping, error, and routing configuration to the whole\napplication. It is usually used to provide application level controllers for\nthe home page of an application, but we are not going to use the default\none provided in this tutorial as we want our album list to be the home page,\nwhich will live in our own module.  We are going to put all our code into the  Album  module which will contain our\ncontrollers, models, forms and views, along with configuration. We\u2019ll also tweak\nthe  Application  module as required.  Let\u2019s start with the directories required.",
            "title": "Modules"
        },
        {
            "location": "/getting-started/modules/#setting-up-the-album-module",
            "text": "Start by creating a directory called  Album  under  module  with the following\nsubdirectories to hold the module\u2019s files:  zf2-tutorial/\n    /module\n        /Album\n            /config\n            /src\n                /Controller\n                /Form\n                /Model\n            /view\n                /album\n                    /album  The  Album  module has separate directories for the different types of files we\nwill have. The PHP files that contain classes within the  Album  namespace live\nin the  src/  directory. The view directory also has a sub-folder called  album \nfor our module's view scripts.  In order to load and configure a module, Zend Framework provides a ModuleManager .  This will look for a  Module  class in the specified module\nnamespace (i.e.,  Album ); in the case of our new module, that means the class Album\\Module , which will be found in  module/Album/src/Module.php .  Let's create that file now, with the following contents:  namespace Album;\n\nuse Zend\\ModuleManager\\Feature\\ConfigProviderInterface;\n\nclass Module implements ConfigProviderInterface\n{\n    public function getConfig()\n    {\n        return include __DIR__ . '/../config/module.config.php';\n    }\n}  The  ModuleManager  will call  getConfig()  automatically for us.",
            "title": "Setting up the Album module"
        },
        {
            "location": "/getting-started/modules/#autoloading",
            "text": "While Zend Framework provides autoloading capabilities via its zend-loader  component, we\nrecommend using Composer's autoloading capabilities. As such, we need to inform\nComposer of our new namespace, and where its files live.  Open  composer.json  in your project root, and look for the  autoload  section;\nit should look like the following by default:  \"autoload\": {\n    \"psr-4\": {\n        \"Application\\\\\": \"module/Application/src/\"\n    }\n},  We'll now add our new module to the list, so it now reads:  \"autoload\": {\n    \"psr-4\": {\n        \"Application\\\\\": \"module/Application/src/\",\n        \"Album\\\\\": \"module/Album/src/\"\n    }\n},  Once you've made that change, run the following to ensure Composer updates its\nautoloading rules:  $ composer dump-autoload",
            "title": "Autoloading"
        },
        {
            "location": "/getting-started/modules/#configuration",
            "text": "Having registered the autoloader, let\u2019s have a quick look at the  getConfig() \nmethod in  Album\\Module . This method loads the  config/module.config.php  file\nunder the module's root directory.  Create a file called  module.config.php  under zf2-tutorial/module/Album/config/ :  namespace Album;\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'controllers' => [\n        'factories' => [\n            Controller\\AlbumController::class => InvokableFactory::class,\n        ],\n    ],\n    'view_manager' => [\n        'template_path_stack' => [\n            'album' => __DIR__ . '/../view',\n        ],\n    ],\n];  The config information is passed to the relevant components by the ServiceManager . We need two initial sections:  controllers  and view_manager . The controllers section provides a list of all the controllers\nprovided by the module. We will need one controller,  AlbumController ; we'll\nreference it by its fully qualified class name, and use the zend-servicemanager InvokableFactory  to create instances of it.  Within the  view_manager  section, we add our view directory to the TemplatePathStack  configuration. This will allow it to find the view scripts\nfor the  Album  module that are stored in our  view/  directory.",
            "title": "Configuration"
        },
        {
            "location": "/getting-started/modules/#informing-the-application-about-our-new-module",
            "text": "We now need to tell the  ModuleManager  that this new module exists. This is\ndone in the application\u2019s  config/application.config.php  file which is provided\nby the skeleton application. Update this file so that its  modules  section\ncontains the  Album  module as well, so the file now looks like this:  (Changes required are highlighted using comments; original comments from the\nfile are omitted for brevity.)  return [\n    'modules' => [\n        'Zend\\Form',\n        'Zend\\Db',\n        'Zend\\Router',\n        'Zend\\Validator',\n        'Application',\n        'Album',                  // <-- Add this line\n    ],\n    'module_listener_options' => [\n        'config_glob_paths'    => [\n            'config/autoload/{{,*.}global,{,*.}local}.php',\n        ],\n        'module_paths' => [\n            './module',\n            './vendor',\n        ],\n    ],\n];  As you can see, we have added our  Album  module into the list of modules after\nthe  Application  module.  We have now set up the module ready for putting our custom code into it.",
            "title": "Informing the application about our new module"
        },
        {
            "location": "/getting-started/routing-and-controllers/",
            "text": "Routing and controllers\n\n\nWe will build a very simple inventory system to display our album collection.\nThe home page will list our collection and allow us to add, edit and delete\nalbums. Hence the following pages are required:\n\n\n\n\n\n\n\n\nPage\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nHome\n\n\nThis will display the list of albums and provide links to edit and delete them. Also, a link to enable adding new albums will be provided.\n\n\n\n\n\n\nAdd new album\n\n\nThis page will provide a form for adding a new album.\n\n\n\n\n\n\nEdit album\n\n\nThis page will provide a form for editing an album.\n\n\n\n\n\n\nDelete album\n\n\nThis page will confirm that we want to delete an album and then delete it.\n\n\n\n\n\n\n\n\nBefore we set up our files, it's important to understand how the framework\nexpects the pages to be organised. Each page of the application is known as an\n\naction\n and actions are grouped into \ncontrollers\n within \nmodules\n. Hence, you\nwould generally group related actions into a controller; for instance, a news\ncontroller might have actions of \ncurrent\n, \narchived\n, and \nview\n.\n\n\nAs we have four pages that all apply to albums, we will group them in a single\ncontroller \nAlbumController\n within our \nAlbum\n module as four actions. The four\nactions will be:\n\n\n\n\n\n\n\n\nPage\n\n\nController\n\n\nAction\n\n\n\n\n\n\n\n\n\n\nHome\n\n\nAlbumController\n\n\nindex\n\n\n\n\n\n\nAdd new album\n\n\nAlbumController\n\n\nadd\n\n\n\n\n\n\nEdit album\n\n\nAlbumController\n\n\nedit\n\n\n\n\n\n\nDelete album\n\n\nAlbumController\n\n\ndelete\n\n\n\n\n\n\n\n\nThe mapping of a URL to a particular action is done using routes that are\ndefined in the module\u2019s \nmodule.config.php\n file. We will add a route for our\nalbum actions. This is the updated module config file with the new code\nhighlighted using comments.\n\n\nnamespace Album;\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'controllers' => [\n        'factories' => [\n            Controller\\AlbumController::class => InvokableFactory::class,\n        ],\n    ],\n\n    // The following section is new and should be added to your file:\n    'router' => [\n        'routes' => [\n            'album' => [\n                'type'    => 'segment',\n                'options' => [\n                    'route'    => '/album[/:action[/:id]]',\n                    'constraints' => [\n                        'action' => '[a-zA-Z][a-zA-Z0-9_-]*',\n                        'id'     => '[0-9]+',\n                    ],\n                    'defaults' => [\n                        'controller' => Controller\\AlbumController::class,\n                        'action'     => 'index',\n                    ],\n                ],\n            ],\n        ],\n    ],\n\n    'view_manager' => [\n        'template_path_stack' => [\n            'album' => __DIR__ . '/../view',\n        ],\n    ],\n];\n\n\n\n\nThe name of the route is \u2018album\u2019 and has a type of \u2018segment\u2019. The segment route\nallows us to specify placeholders in the URL pattern (route) that will be mapped\nto named parameters in the matched route. In this case, the route is\n\n/album[/:action[/:id]]\n which will match any URL that starts with \n/album\n.\nThe next segment will be an optional action name, and then finally the next\nsegment will be mapped to an optional id. The square brackets indicate that a\nsegment is optional. The constraints section allows us to ensure that the\ncharacters within a segment are as expected, so we have limited actions to\nstarting with a letter and then subsequent characters only being alphanumeric,\nunderscore, or hyphen. We also limit the id to digits.\n\n\nThis route allows us to have the following URLs:\n\n\n\n\n\n\n\n\nURL\n\n\nPage\n\n\nAction\n\n\n\n\n\n\n\n\n\n\n/album\n\n\nHome (list of albums)\n\n\nindex\n\n\n\n\n\n\n/album/add\n\n\nAdd new album\n\n\nadd\n\n\n\n\n\n\n/album/edit/2\n\n\nEdit album with an id of 2\n\n\nedit\n\n\n\n\n\n\n/album/delete/4\n\n\nDelete album with an id of 4\n\n\ndelete\n\n\n\n\n\n\n\n\nCreate the controller\n\n\nWe are now ready to set up our controller. For zend-mvc, the controller\nis a class that is generally called \n{Controller name}Controller\n; note that\n\n{Controller name}\n must start with a capital letter. This class lives in a file\ncalled \n{Controller name}Controller.php\n within the \nController\n subdirectory for\nthe module; in our case that is \nmodule/Album/src/Controller/\n. Each action\nis a public method within the controller class that is named \n{action\nname}Action\n, where \n{action name}\n should start with a lower case\nletter.\n\n\n\n\nConventions not strictly enforced\n\n\nThis is by convention. zend-mvc doesn't provide many restrictions on\ncontrollers other than that they must implement the \nZend\\Stdlib\\Dispatchable\n\ninterface. The framework provides two abstract classes that do this for us:\n\nZend\\Mvc\\Controller\\AbstractActionController\n and\n\nZend\\Mvc\\Controller\\AbstractRestfulController\n. We'll be using the standard\n\nAbstractActionController\n, but if you\u2019re intending to write a RESTful web\nservice, \nAbstractRestfulController\n may be useful.\n\n\n\n\nLet\u2019s go ahead and create our controller class in the file\n\nzf2-tutorials/module/Album/src/Controller/AlbumController.php\n:\n\n\nnamespace Album\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass AlbumController extends AbstractActionController\n{\n    public function indexAction()\n    {\n    }\n\n    public function addAction()\n    {\n    }\n\n    public function editAction()\n    {\n    }\n\n    public function deleteAction()\n    {\n    }\n}\n\n\n\n\nWe have now set up the four actions that we want to use. They won't work yet\nuntil we set up the views. The URLs for each action are:\n\n\n\n\n\n\n\n\nURL\n\n\nMethod called\n\n\n\n\n\n\n\n\n\n\nhttp://zf2-tutorial.localhost/album\n\n\nAlbum\\Controller\\AlbumController::indexAction\n\n\n\n\n\n\nhttp://zf2-tutorial.localhost/album/add\n\n\nAlbum\\Controller\\AlbumController::addAction\n\n\n\n\n\n\nhttp://zf2-tutorial.localhost/album/edit\n\n\nAlbum\\Controller\\AlbumController::editAction\n\n\n\n\n\n\nhttp://zf2-tutorial.localhost/album/delete\n\n\nAlbum\\Controller\\AlbumController::deleteAction\n\n\n\n\n\n\n\n\nWe now have a working router and the actions are set up for each page of our\napplication.\n\n\nIt's time to build the view and the model layer.\n\n\nInitialise the view scripts\n\n\nTo integrate the view into our application, we need to create some view script\nfiles. These files will be executed by the \nDefaultViewStrategy\n and will be\npassed any variables or view models that are returned from the controller action\nmethod. These view scripts are stored in our module\u2019s views directory within a\ndirectory named after the controller. Create these four empty files now:\n\n\n\n\nmodule/Album/view/album/album/index.phtml\n\n\nmodule/Album/view/album/album/add.phtml\n\n\nmodule/Album/view/album/album/edit.phtml\n\n\nmodule/Album/view/album/album/delete.phtml\n\n\n\n\nWe can now start filling everything in, starting with our database and models.",
            "title": "Routing and Controllers"
        },
        {
            "location": "/getting-started/routing-and-controllers/#routing-and-controllers",
            "text": "We will build a very simple inventory system to display our album collection.\nThe home page will list our collection and allow us to add, edit and delete\nalbums. Hence the following pages are required:     Page  Description      Home  This will display the list of albums and provide links to edit and delete them. Also, a link to enable adding new albums will be provided.    Add new album  This page will provide a form for adding a new album.    Edit album  This page will provide a form for editing an album.    Delete album  This page will confirm that we want to delete an album and then delete it.     Before we set up our files, it's important to understand how the framework\nexpects the pages to be organised. Each page of the application is known as an action  and actions are grouped into  controllers  within  modules . Hence, you\nwould generally group related actions into a controller; for instance, a news\ncontroller might have actions of  current ,  archived , and  view .  As we have four pages that all apply to albums, we will group them in a single\ncontroller  AlbumController  within our  Album  module as four actions. The four\nactions will be:     Page  Controller  Action      Home  AlbumController  index    Add new album  AlbumController  add    Edit album  AlbumController  edit    Delete album  AlbumController  delete     The mapping of a URL to a particular action is done using routes that are\ndefined in the module\u2019s  module.config.php  file. We will add a route for our\nalbum actions. This is the updated module config file with the new code\nhighlighted using comments.  namespace Album;\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'controllers' => [\n        'factories' => [\n            Controller\\AlbumController::class => InvokableFactory::class,\n        ],\n    ],\n\n    // The following section is new and should be added to your file:\n    'router' => [\n        'routes' => [\n            'album' => [\n                'type'    => 'segment',\n                'options' => [\n                    'route'    => '/album[/:action[/:id]]',\n                    'constraints' => [\n                        'action' => '[a-zA-Z][a-zA-Z0-9_-]*',\n                        'id'     => '[0-9]+',\n                    ],\n                    'defaults' => [\n                        'controller' => Controller\\AlbumController::class,\n                        'action'     => 'index',\n                    ],\n                ],\n            ],\n        ],\n    ],\n\n    'view_manager' => [\n        'template_path_stack' => [\n            'album' => __DIR__ . '/../view',\n        ],\n    ],\n];  The name of the route is \u2018album\u2019 and has a type of \u2018segment\u2019. The segment route\nallows us to specify placeholders in the URL pattern (route) that will be mapped\nto named parameters in the matched route. In this case, the route is /album[/:action[/:id]]  which will match any URL that starts with  /album .\nThe next segment will be an optional action name, and then finally the next\nsegment will be mapped to an optional id. The square brackets indicate that a\nsegment is optional. The constraints section allows us to ensure that the\ncharacters within a segment are as expected, so we have limited actions to\nstarting with a letter and then subsequent characters only being alphanumeric,\nunderscore, or hyphen. We also limit the id to digits.  This route allows us to have the following URLs:     URL  Page  Action      /album  Home (list of albums)  index    /album/add  Add new album  add    /album/edit/2  Edit album with an id of 2  edit    /album/delete/4  Delete album with an id of 4  delete",
            "title": "Routing and controllers"
        },
        {
            "location": "/getting-started/routing-and-controllers/#create-the-controller",
            "text": "We are now ready to set up our controller. For zend-mvc, the controller\nis a class that is generally called  {Controller name}Controller ; note that {Controller name}  must start with a capital letter. This class lives in a file\ncalled  {Controller name}Controller.php  within the  Controller  subdirectory for\nthe module; in our case that is  module/Album/src/Controller/ . Each action\nis a public method within the controller class that is named  {action\nname}Action , where  {action name}  should start with a lower case\nletter.",
            "title": "Create the controller"
        },
        {
            "location": "/getting-started/routing-and-controllers/#conventions-not-strictly-enforced",
            "text": "This is by convention. zend-mvc doesn't provide many restrictions on\ncontrollers other than that they must implement the  Zend\\Stdlib\\Dispatchable \ninterface. The framework provides two abstract classes that do this for us: Zend\\Mvc\\Controller\\AbstractActionController  and Zend\\Mvc\\Controller\\AbstractRestfulController . We'll be using the standard AbstractActionController , but if you\u2019re intending to write a RESTful web\nservice,  AbstractRestfulController  may be useful.   Let\u2019s go ahead and create our controller class in the file zf2-tutorials/module/Album/src/Controller/AlbumController.php :  namespace Album\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass AlbumController extends AbstractActionController\n{\n    public function indexAction()\n    {\n    }\n\n    public function addAction()\n    {\n    }\n\n    public function editAction()\n    {\n    }\n\n    public function deleteAction()\n    {\n    }\n}  We have now set up the four actions that we want to use. They won't work yet\nuntil we set up the views. The URLs for each action are:     URL  Method called      http://zf2-tutorial.localhost/album  Album\\Controller\\AlbumController::indexAction    http://zf2-tutorial.localhost/album/add  Album\\Controller\\AlbumController::addAction    http://zf2-tutorial.localhost/album/edit  Album\\Controller\\AlbumController::editAction    http://zf2-tutorial.localhost/album/delete  Album\\Controller\\AlbumController::deleteAction     We now have a working router and the actions are set up for each page of our\napplication.  It's time to build the view and the model layer.",
            "title": "Conventions not strictly enforced"
        },
        {
            "location": "/getting-started/routing-and-controllers/#initialise-the-view-scripts",
            "text": "To integrate the view into our application, we need to create some view script\nfiles. These files will be executed by the  DefaultViewStrategy  and will be\npassed any variables or view models that are returned from the controller action\nmethod. These view scripts are stored in our module\u2019s views directory within a\ndirectory named after the controller. Create these four empty files now:   module/Album/view/album/album/index.phtml  module/Album/view/album/album/add.phtml  module/Album/view/album/album/edit.phtml  module/Album/view/album/album/delete.phtml   We can now start filling everything in, starting with our database and models.",
            "title": "Initialise the view scripts"
        },
        {
            "location": "/getting-started/database-and-models/",
            "text": "Database and models\n\n\nThe database\n\n\nNow that we have the \nAlbum\n module set up with controller action methods and\nview scripts, it is time to look at the model section of our application.\nRemember that the model is the part that deals with the application's core\npurpose (the so-called \u201cbusiness rules\u201d) and, in our case, deals with the\ndatabase. We will make use of zend-db's \nZend\\Db\\TableGateway\\TableGateway\n to\nfind, insert, update, and delete rows from a database table.\n\n\nWe are going to use Sqlite, via PHP's PDO driver. Create a text file\n\ndata/schema.sql\n with the following contents:\n\n\nCREATE TABLE album ( id INTEGER PRIMARY KEY AUTOINCREMENT, artist varchar(100) NOT NULL, title varchar(100) NOT NULL);\nINSERT INTO album (artist, title) VALUES  ('The  Military  Wives',  'In  My  Dreams');\nINSERT INTO album (artist, title) VALUES  ('Adele',  '21');\nINSERT INTO album (artist, title) VALUES  ('Bruce  Springsteen',  'Wrecking Ball (Deluxe)');\nINSERT INTO album (artist, title) VALUES  ('Lana  Del  Rey',  'Born  To  Die');\nINSERT INTO album (artist, title) VALUES  ('Gotye',  'Making  Mirrors');\n\n\n\n\n(The test data chosen happens to be the Bestsellers on Amazon UK at the time of writing!)\n\n\nNow create the database using the following:\n\n\n$ sqlite data/zftutorial.db < data/schema.sql\n\n\n\n\nSome systems, including Ubuntu, use the command \nsqlite3\n; check to see which\none to use on your system.\n\n\n\n\nUsing PHP to create the database\n\n\nIf you do not have Sqlite installed on your system, you can use PHP to load\nthe database using the same SQL schema file created earlier. Create the file\n\ndata/load_db.php\n with the following contents:\n\n\n<?php\n$db = new PDO('sqlite:' . realpath(__DIR__) . '/zftutorial.db');\n$fh = fopen(__DIR__ . '/schema.sql', 'r');\nwhile ($line = fread($fh, 4096)) {\n    $db->exec($line);\n}\nfclose($fh);\n\n\n\n\nOnce created, execute it:\n\n\n$ php data/load_db.php\n\n\n\n\n\n\nWe now have some data in a database and can write a very simple model for it.\n\n\nThe model files\n\n\nZend Framework does not provide a zend-model component because the model is your\nbusiness logic, and it's up to you to decide how you want it to work. There are\nmany components that you can use for this depending on your needs. One approach\nis to have model classes represent each entity in your application and then use\nmapper objects that load and save entities to the database. Another is to use an\nObject-Relational Mapping (ORM) technology, such as Doctrine or Propel.\n\n\nFor this tutorial, we are going to create a model by creating an \nAlbumTable\n\nclass that consumes a \nZend\\Db\\TableGateway\\TableGateway\n, and in which each\nalbum will be represented as an \nAlbum\n object (known as an \nentity\n). This is\nan implementation of the \nTable Data Gateway\n\ndesign pattern to allow for interfacing with data in a database table. Be aware,\nthough, that the Table Data Gateway pattern can become limiting in larger\nsystems. There is also a temptation to put database access code into controller\naction methods as these are exposed by \nZend\\Db\\TableGateway\\AbstractTableGateway\n.\n\nDon't do this\n!\n\n\nLet's start by creating a file called \nAlbum.php\n under\n\nmodule/Album/src/Model\n:\n\n\nnamespace Album\\Model;\n\nclass Album\n{\n    public $id;\n    public $artist;\n    public $title;\n\n    public function exchangeArray(array $data)\n    {\n        $this->id     = (!empty($data['id'])) ? $data['id'] : null;\n        $this->artist = (!empty($data['artist'])) ? $data['artist'] : null;\n        $this->title  = (!empty($data['title'])) ? $data['title'] : null;\n    }\n}\n\n\n\n\nOur \nAlbum\n entity object is a PHP class. In order to work with zend-db's\n\nTableGateway\n class, we need to implement the \nexchangeArray()\n method; this\nmethod copies the data from the provided array to our entity's properties. We\nwill add an input filter later to ensure the values injected are valid.\n\n\nNext, we create our \nAlbumTable.php\n file in \nmodule/Album/src/Model\n directory like this:\n\n\nnamespace Album\\Model;\n\nuse RuntimeException;\nuse Zend\\Db\\TableGateway\\TableGatewayInterface;\n\nclass AlbumTable\n{\n    private $tableGateway;\n\n    public function __construct(TableGatewayInterface $tableGateway)\n    {\n        $this->tableGateway = $tableGateway;\n    }\n\n    public function fetchAll()\n    {\n        return $this->tableGateway->select();\n    }\n\n    public function getAlbum($id)\n    {\n        $id = (int) $id;\n        $rowset = $this->tableGateway->select(['id' => $id]);\n        $row = $rowset->current();\n        if (! $row) {\n            throw new RuntimeException(sprintf(\n                'Could not find row with identifier %d',\n                $id\n            ));\n        }\n\n        return $row;\n    }\n\n    public function saveAlbum(Album $album)\n    {\n        $data = [\n            'artist' => $album->artist,\n            'title'  => $album->title,\n        ];\n\n        $id = (int) $album->id;\n\n        if ($id === 0) {\n            $this->tableGateway->insert($data);\n            return;\n        }\n\n        if (! $this->getAlbum($id)) {\n            throw new RuntimeException(sprintf(\n                'Cannot update album with identifier %d; does not exist',\n                $id\n            ));\n        }\n\n        $this->tableGateway->update($data, ['id' => $id]);\n    }\n\n    public function deleteAlbum($id)\n    {\n        $this->tableGateway->delete(['id' => (int) $id]);\n    }\n}\n\n\n\n\nThere's a lot going on here. Firstly, we set the protected property\n\n$tableGateway\n to the \nTableGateway\n instance passed in the constructor,\nhinting against the \nTableGatewayInterface\n (which allows us to provide\nalternate implementations easily, including mock instances during testing). We\nwill use this to perform operations on the database table for our albums.\n\n\nWe then create some helper methods that our application will use to interface\nwith the table gateway. \nfetchAll()\n retrieves all albums rows from the database\nas a \nResultSet\n, \ngetAlbum()\n retrieves a single row as an \nAlbum\n object,\n\nsaveAlbum()\n either creates a new row in the database or updates a row that\nalready exists, and \ndeleteAlbum()\n removes the row completely. The code for each\nof these methods is, hopefully, self-explanatory.\n\n\nUsing ServiceManager to configure the table gateway and inject into the AlbumTable\n\n\nIn order to always use the same instance of our \nAlbumTable\n, we will use the\n\nServiceManager\n to define how to create one. This is most easily done in the\n\nModule\n class where we create a method called \ngetServiceConfig()\n which is\nautomatically called by the \nModuleManager\n and applied to the \nServiceManager\n.\nWe'll then be able to retrieve when we need it.\n\n\nTo configure the \nServiceManager\n, we can either supply the name of the class to\nbe instantiated or a factory (closure, callback, or class name of a factory\nclass) that instantiates the object when the \nServiceManager\n needs it. We start\nby implementing \ngetServiceConfig()\n to provide a factory that creates an\n\nAlbumTable\n. Add this method to the bottom of the \nmodule/Album/src/Module.php\n\nfile:\n\n\nnamespace Album;\n\n// Add these import statements:\nuse Zend\\Db\\Adapter\\AdapterInterface;\nuse Zend\\Db\\ResultSet\\ResultSet;\nuse Zend\\Db\\TableGateway\\TableGateway;\nuse Zend\\ModuleManager\\Feature\\ConfigProviderInterface;\n\nclass Module implements ConfigProviderInterface\n{\n    // getConfig() method is here\n\n    // Add this method:\n    public function getServiceConfig()\n    {\n        return [\n            'factories' => [\n                Model\\AlbumTable::class =>  function($container) {\n                    $tableGateway = $container->get(Model\\AlbumTableGateway::class);\n                    return new Model\\AlbumTable($tableGateway);\n                },\n                Model\\AlbumTableGateway::class => function ($container) {\n                    $dbAdapter = $container->get(AdapterInterface::class);\n                    $resultSetPrototype = new ResultSet();\n                    $resultSetPrototype->setArrayObjectPrototype(new Model\\Album());\n                    return new TableGateway('album', $dbAdapter, null, $resultSetPrototype);\n                },\n            ],\n        ];\n    }\n}\n\n\n\n\nThis method returns an array of \nfactories\n that are all merged together by the\n\nModuleManager\n before passing them to the \nServiceManager\n. The factory for\n\nAlbum\\Model\\AlbumTable\n uses the \nServiceManager\n to create an\n\nAlbum\\Model\\AlbumTableGateway\n service representing a \nTableGateway\n to pass to\nits constructor. We also tell the \nServiceManager\n that the \nAlbumTableGateway\n\nservice is created by fetching a \nZend\\Db\\Adapter\\AdapterInterface\n\nimplementation (also from the \nServiceManager\n) and using it to create a\n\nTableGateway\n object. The \nTableGateway\n is told to use an \nAlbum\n object\nwhenever it creates a new result row. The \nTableGateway\n classes use the\nprototype pattern for creation of result sets and entities. This means that\ninstead of instantiating when required, the system clones a previously\ninstantiated object. See\n\nPHP Constructor Best Practices and the Prototype Pattern\n\nfor more details.\n\n\n\n\nFactories\n\n\nThe above demonstrates building factories as closures within your module\nclass. Another option is to build the factory as a \nclass\n, and then map the\nclass in your module configuration. This approach has a number of benefits:\n\n\n\n\nThe code is not parsed or executed unless the factory is invoked.\n\n\nYou can easily unit test the factory to ensure it does what it should.\n\n\nYou can extend the factory if desired.\n\n\nYou can re-use the factory across multiple instances that have related\n  construction.\n\n\n\n\nCreating factories is covered in the \nzend-servicemanager documentation\n.\n\n\n\n\nThe \nZend\\Db\\Adapter\\AdapterInterface\n service is registered by the zend-db\ncomponent.  You may have noticed earlier that \nconfig/application.config.php\n\ncontains the following entries:\n\n\n'modules' => [\n    'Zend\\Form',\n    'Zend\\Db',\n    'Zend\\Router',\n    'Zend\\Validator',\n    /* ... */\n],\n\n\n\n\nAll Zend Framework components that provide zend-servicemanager configuration are\nalso exposed as modules themselves; the prompts as to where to register the\ncomponents during our initial installation occurred to ensure that the above\nentries are created for you.\n\n\nThe end result is that we can already rely on having a factory for the\n\nZend\\Db\\Adapter\\AdapterInterface\n service; now we need to provide configuration\nso it can create an adapter for us.\n\n\nZend Framework's \nModuleManager\n merges all the configuration from each module's\n\nmodule.config.php\n file, and then merges in the files in \nconfig/autoload/\n\n(first \n*.global.php\n files, and then \n*.local.php\n files). We'll add our\ndatabase configuration information to \nglobal.php\n, which you should commit to\nyour version control system. You can use \nlocal.php\n (outside of the VCS) to\nstore the credentials for your database if you want to. Modify\n\nconfig/autoload/global.php\n (in the project root, not inside the \nAlbum\n\nmodule) with following code:\n\n\nreturn [\n    'db' => [\n        'driver' => 'Pdo',\n        'dsn'    => sprintf('sqlite:%s/data/zftutorial.db', realpath(getcwd())),\n    ],\n);\n\n\n\n\nIf you were configuring a database that required credentials, you would put the\ngeneral configuration in your \nconfig/autoload/global.php\n, and then the\nconfiguration for the current environment, including the DSN and credentials, in\nthe \nconfig/autoload/local.php\n file. These get merged when the application\nruns, ensuring you have a full definition, but allows you to keep files with\ncredentials outside of version control.\n\n\nBack to the controller\n\n\nNow that we have a model, we need to inject it into our controller so we can use\nit.\n\n\nFirstly, we'll add a constructor to our controller. Open the file\n\nmodule/Album/src/Controller/AlbumController.php\n and add the following property\nand constructor:\n\n\nnamespace Album\\Controller;\n\n// Add the following import:\nuse Album\\Model\\AlbumTable;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass AlbumController extends AbstractActionController\n{\n    // Add this property:\n    private $table;\n\n    // Add this constructor:\n    public function __construct(AlbumTable $table)\n    {\n        $this->table = $table;\n    }\n\n    /* ... */\n}\n\n\n\n\nOur controller now depends on \nAlbumTable\n, so we will need to create a factory\nfor the controller.  Similar to how we created factories for the model, we'll\ncreate in in our \nModule\n class, only this time, under a new method,\n\nAlbum\\Module::getControllerConfig()\n:\n\n\nnamespace Album;\n\nuse Zend\\Db\\Adapter\\Adapter;\nuse Zend\\Db\\ResultSet\\ResultSet;\nuse Zend\\Db\\TableGateway\\TableGateway;\nuse Zend\\ModuleManager\\Feature\\ConfigProviderInterface;\n\nclass Module implements ConfigProviderInterface\n{\n    // getConfig() and getServiceConfig methods are here\n\n    // Add this method:\n    public function getControllerConfig()\n    {\n        return [\n            'factories' => [\n                Controller\\AlbumController::class =>  function($container) {\n                    return new Controller\\AlbumController(\n                        $container->get(Model\\AlbumTable::class\n                    );\n                },\n            ],\n        ];\n    }\n}\n\n\n\n\nBecause we're now defining our own factory, we can modify our\n\nmodule.config.php\n to remove the definition. Open\n\nmodule/Album/config/module.config.php\n and remove the following lines:\n\n\n<?php\nnamespace Album;\n\n// Remove this:\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    // And remove the entire \"controllers\" section here:\n    'controllers' => [\n        'factories' => [\n            Controller\\AlbumController::class => InvokableFactory::class,\n        ],\n    ],\n\n    /* ... */\n];\n\n\n\n\nWe can now access the property \n$table\n from within our controller whenever we\nneed to interact with our model.\n\n\nListing albums\n\n\nIn order to list the albums, we need to retrieve them from the model and pass\nthem to the view. To do this, we fill in \nindexAction()\n within\n\nAlbumController\n. Update the \nAlbumController::indexAction()\n as follows:\n\n\n// module/Album/src/Controller/AlbumController.php:\n// ...\n    public function indexAction()\n    {\n        return new ViewModel([\n            'albums' => $this->table->fetchAll(),\n        ]);\n    }\n// ...\n\n\n\n\nWith Zend Framework, in order to set variables in the view, we return a\n\nViewModel\n instance where the first parameter of the constructor is an array\ncontaining data we wish to represent. These are then automatically passed to the\nview script. The \nViewModel\n object also allows us to change the view script\nthat is used, but the default is to use \n{module name}/{controller name}/{action\nname}\n. We can now fill in the \nindex.phtml\n view script:\n\n\n<?php\n// module/Album/view/album/album/index.phtml:\n\n$title = 'My albums';\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title); ?></h1>\n<p>\n    <a href=\"<?= $this->url('album', ['action'=>'add']) ?>\">Add new album</a>\n</p>\n\n<table class=\"table\">\n<tr>\n    <th>Title</th>\n    <th>Artist</th>\n    <th>&nbsp;</th>\n</tr>\n<?php foreach ($albums as $album) : ?>\n<tr>\n    <td><?= $this->escapeHtml($album->title) ?></td>\n    <td><?= $this->escapeHtml($album->artist) ?></td>\n    <td>\n        <a href=\"<?= $this->url('album', ['action'=>'edit', 'id' => $album->id]) ?>\">Edit</a>\n        <a href=\"<?= $this->url('album', ['action'=>'delete', 'id' => $album->id]) ?>\">Delete</a>\n    </td>\n</tr>\n<?php endforeach; ?>\n</table>\n\n\n\n\nThe first thing we do is to set the title for the page (used in the layout) and\nalso set the title for the \n<head>\n section using the \nheadTitle()\n view helper\nwhich will display in the browser's title bar. We then create a link to add a\nnew album.\n\n\nThe \nurl()\n view helper is provided by zend-mvc and zend-view, and is used to create\nthe links we need. The first parameter to \nurl()\n is the route name we wish to\nuse for construction of the URL, and the second parameter is an array of\nvariables to substitute into route placeholders. In this case we use our \nalbum\n\nroute which is set up to accept two placeholder variables: \naction\n and \nid\n.\n\n\nWe iterate over the \n$albums\n that we assigned from the controller action.\nzend-view automatically ensures that these variables are extracted into the\nscope of the view script; you may also access them using \n$this->{variable\nname}\n in order to differentiate between variables provided to the view script\nand those created inside it.\n\n\nWe then create a table to display each album's title and artist, and provide\nlinks to allow for editing and deleting the record. A standard \nforeach:\n loop\nis used to iterate over the list of albums, and we use the alternate form using\na colon and \nendforeach;\n as it is easier to scan than to try and match up\nbraces. Again, the \nurl()\n view helper is used to create the edit and delete\nlinks.\n\n\n\n\nEscaping\n\n\nWe always use the \nescapeHtml()\n view helper to help protect ourselves from\n\nCross Site Scripting (XSS) vulnerabilities\n.\n\n\n\n\nIf you open \nhttp://localhost:8080/album\n (or \nhttp://zf2-tutorial.localhost/album\n \nif you are using self-hosted Apache) you should see this:",
            "title": "Database and Models"
        },
        {
            "location": "/getting-started/database-and-models/#database-and-models",
            "text": "",
            "title": "Database and models"
        },
        {
            "location": "/getting-started/database-and-models/#the-database",
            "text": "Now that we have the  Album  module set up with controller action methods and\nview scripts, it is time to look at the model section of our application.\nRemember that the model is the part that deals with the application's core\npurpose (the so-called \u201cbusiness rules\u201d) and, in our case, deals with the\ndatabase. We will make use of zend-db's  Zend\\Db\\TableGateway\\TableGateway  to\nfind, insert, update, and delete rows from a database table.  We are going to use Sqlite, via PHP's PDO driver. Create a text file data/schema.sql  with the following contents:  CREATE TABLE album ( id INTEGER PRIMARY KEY AUTOINCREMENT, artist varchar(100) NOT NULL, title varchar(100) NOT NULL);\nINSERT INTO album (artist, title) VALUES  ('The  Military  Wives',  'In  My  Dreams');\nINSERT INTO album (artist, title) VALUES  ('Adele',  '21');\nINSERT INTO album (artist, title) VALUES  ('Bruce  Springsteen',  'Wrecking Ball (Deluxe)');\nINSERT INTO album (artist, title) VALUES  ('Lana  Del  Rey',  'Born  To  Die');\nINSERT INTO album (artist, title) VALUES  ('Gotye',  'Making  Mirrors');  (The test data chosen happens to be the Bestsellers on Amazon UK at the time of writing!)  Now create the database using the following:  $ sqlite data/zftutorial.db < data/schema.sql  Some systems, including Ubuntu, use the command  sqlite3 ; check to see which\none to use on your system.",
            "title": "The database"
        },
        {
            "location": "/getting-started/database-and-models/#using-php-to-create-the-database",
            "text": "If you do not have Sqlite installed on your system, you can use PHP to load\nthe database using the same SQL schema file created earlier. Create the file data/load_db.php  with the following contents:  <?php\n$db = new PDO('sqlite:' . realpath(__DIR__) . '/zftutorial.db');\n$fh = fopen(__DIR__ . '/schema.sql', 'r');\nwhile ($line = fread($fh, 4096)) {\n    $db->exec($line);\n}\nfclose($fh);  Once created, execute it:  $ php data/load_db.php   We now have some data in a database and can write a very simple model for it.",
            "title": "Using PHP to create the database"
        },
        {
            "location": "/getting-started/database-and-models/#the-model-files",
            "text": "Zend Framework does not provide a zend-model component because the model is your\nbusiness logic, and it's up to you to decide how you want it to work. There are\nmany components that you can use for this depending on your needs. One approach\nis to have model classes represent each entity in your application and then use\nmapper objects that load and save entities to the database. Another is to use an\nObject-Relational Mapping (ORM) technology, such as Doctrine or Propel.  For this tutorial, we are going to create a model by creating an  AlbumTable \nclass that consumes a  Zend\\Db\\TableGateway\\TableGateway , and in which each\nalbum will be represented as an  Album  object (known as an  entity ). This is\nan implementation of the  Table Data Gateway \ndesign pattern to allow for interfacing with data in a database table. Be aware,\nthough, that the Table Data Gateway pattern can become limiting in larger\nsystems. There is also a temptation to put database access code into controller\naction methods as these are exposed by  Zend\\Db\\TableGateway\\AbstractTableGateway . Don't do this !  Let's start by creating a file called  Album.php  under module/Album/src/Model :  namespace Album\\Model;\n\nclass Album\n{\n    public $id;\n    public $artist;\n    public $title;\n\n    public function exchangeArray(array $data)\n    {\n        $this->id     = (!empty($data['id'])) ? $data['id'] : null;\n        $this->artist = (!empty($data['artist'])) ? $data['artist'] : null;\n        $this->title  = (!empty($data['title'])) ? $data['title'] : null;\n    }\n}  Our  Album  entity object is a PHP class. In order to work with zend-db's TableGateway  class, we need to implement the  exchangeArray()  method; this\nmethod copies the data from the provided array to our entity's properties. We\nwill add an input filter later to ensure the values injected are valid.  Next, we create our  AlbumTable.php  file in  module/Album/src/Model  directory like this:  namespace Album\\Model;\n\nuse RuntimeException;\nuse Zend\\Db\\TableGateway\\TableGatewayInterface;\n\nclass AlbumTable\n{\n    private $tableGateway;\n\n    public function __construct(TableGatewayInterface $tableGateway)\n    {\n        $this->tableGateway = $tableGateway;\n    }\n\n    public function fetchAll()\n    {\n        return $this->tableGateway->select();\n    }\n\n    public function getAlbum($id)\n    {\n        $id = (int) $id;\n        $rowset = $this->tableGateway->select(['id' => $id]);\n        $row = $rowset->current();\n        if (! $row) {\n            throw new RuntimeException(sprintf(\n                'Could not find row with identifier %d',\n                $id\n            ));\n        }\n\n        return $row;\n    }\n\n    public function saveAlbum(Album $album)\n    {\n        $data = [\n            'artist' => $album->artist,\n            'title'  => $album->title,\n        ];\n\n        $id = (int) $album->id;\n\n        if ($id === 0) {\n            $this->tableGateway->insert($data);\n            return;\n        }\n\n        if (! $this->getAlbum($id)) {\n            throw new RuntimeException(sprintf(\n                'Cannot update album with identifier %d; does not exist',\n                $id\n            ));\n        }\n\n        $this->tableGateway->update($data, ['id' => $id]);\n    }\n\n    public function deleteAlbum($id)\n    {\n        $this->tableGateway->delete(['id' => (int) $id]);\n    }\n}  There's a lot going on here. Firstly, we set the protected property $tableGateway  to the  TableGateway  instance passed in the constructor,\nhinting against the  TableGatewayInterface  (which allows us to provide\nalternate implementations easily, including mock instances during testing). We\nwill use this to perform operations on the database table for our albums.  We then create some helper methods that our application will use to interface\nwith the table gateway.  fetchAll()  retrieves all albums rows from the database\nas a  ResultSet ,  getAlbum()  retrieves a single row as an  Album  object, saveAlbum()  either creates a new row in the database or updates a row that\nalready exists, and  deleteAlbum()  removes the row completely. The code for each\nof these methods is, hopefully, self-explanatory.",
            "title": "The model files"
        },
        {
            "location": "/getting-started/database-and-models/#using-servicemanager-to-configure-the-table-gateway-and-inject-into-the-albumtable",
            "text": "In order to always use the same instance of our  AlbumTable , we will use the ServiceManager  to define how to create one. This is most easily done in the Module  class where we create a method called  getServiceConfig()  which is\nautomatically called by the  ModuleManager  and applied to the  ServiceManager .\nWe'll then be able to retrieve when we need it.  To configure the  ServiceManager , we can either supply the name of the class to\nbe instantiated or a factory (closure, callback, or class name of a factory\nclass) that instantiates the object when the  ServiceManager  needs it. We start\nby implementing  getServiceConfig()  to provide a factory that creates an AlbumTable . Add this method to the bottom of the  module/Album/src/Module.php \nfile:  namespace Album;\n\n// Add these import statements:\nuse Zend\\Db\\Adapter\\AdapterInterface;\nuse Zend\\Db\\ResultSet\\ResultSet;\nuse Zend\\Db\\TableGateway\\TableGateway;\nuse Zend\\ModuleManager\\Feature\\ConfigProviderInterface;\n\nclass Module implements ConfigProviderInterface\n{\n    // getConfig() method is here\n\n    // Add this method:\n    public function getServiceConfig()\n    {\n        return [\n            'factories' => [\n                Model\\AlbumTable::class =>  function($container) {\n                    $tableGateway = $container->get(Model\\AlbumTableGateway::class);\n                    return new Model\\AlbumTable($tableGateway);\n                },\n                Model\\AlbumTableGateway::class => function ($container) {\n                    $dbAdapter = $container->get(AdapterInterface::class);\n                    $resultSetPrototype = new ResultSet();\n                    $resultSetPrototype->setArrayObjectPrototype(new Model\\Album());\n                    return new TableGateway('album', $dbAdapter, null, $resultSetPrototype);\n                },\n            ],\n        ];\n    }\n}  This method returns an array of  factories  that are all merged together by the ModuleManager  before passing them to the  ServiceManager . The factory for Album\\Model\\AlbumTable  uses the  ServiceManager  to create an Album\\Model\\AlbumTableGateway  service representing a  TableGateway  to pass to\nits constructor. We also tell the  ServiceManager  that the  AlbumTableGateway \nservice is created by fetching a  Zend\\Db\\Adapter\\AdapterInterface \nimplementation (also from the  ServiceManager ) and using it to create a TableGateway  object. The  TableGateway  is told to use an  Album  object\nwhenever it creates a new result row. The  TableGateway  classes use the\nprototype pattern for creation of result sets and entities. This means that\ninstead of instantiating when required, the system clones a previously\ninstantiated object. See PHP Constructor Best Practices and the Prototype Pattern \nfor more details.",
            "title": "Using ServiceManager to configure the table gateway and inject into the AlbumTable"
        },
        {
            "location": "/getting-started/database-and-models/#factories",
            "text": "The above demonstrates building factories as closures within your module\nclass. Another option is to build the factory as a  class , and then map the\nclass in your module configuration. This approach has a number of benefits:   The code is not parsed or executed unless the factory is invoked.  You can easily unit test the factory to ensure it does what it should.  You can extend the factory if desired.  You can re-use the factory across multiple instances that have related\n  construction.   Creating factories is covered in the  zend-servicemanager documentation .   The  Zend\\Db\\Adapter\\AdapterInterface  service is registered by the zend-db\ncomponent.  You may have noticed earlier that  config/application.config.php \ncontains the following entries:  'modules' => [\n    'Zend\\Form',\n    'Zend\\Db',\n    'Zend\\Router',\n    'Zend\\Validator',\n    /* ... */\n],  All Zend Framework components that provide zend-servicemanager configuration are\nalso exposed as modules themselves; the prompts as to where to register the\ncomponents during our initial installation occurred to ensure that the above\nentries are created for you.  The end result is that we can already rely on having a factory for the Zend\\Db\\Adapter\\AdapterInterface  service; now we need to provide configuration\nso it can create an adapter for us.  Zend Framework's  ModuleManager  merges all the configuration from each module's module.config.php  file, and then merges in the files in  config/autoload/ \n(first  *.global.php  files, and then  *.local.php  files). We'll add our\ndatabase configuration information to  global.php , which you should commit to\nyour version control system. You can use  local.php  (outside of the VCS) to\nstore the credentials for your database if you want to. Modify config/autoload/global.php  (in the project root, not inside the  Album \nmodule) with following code:  return [\n    'db' => [\n        'driver' => 'Pdo',\n        'dsn'    => sprintf('sqlite:%s/data/zftutorial.db', realpath(getcwd())),\n    ],\n);  If you were configuring a database that required credentials, you would put the\ngeneral configuration in your  config/autoload/global.php , and then the\nconfiguration for the current environment, including the DSN and credentials, in\nthe  config/autoload/local.php  file. These get merged when the application\nruns, ensuring you have a full definition, but allows you to keep files with\ncredentials outside of version control.",
            "title": "Factories"
        },
        {
            "location": "/getting-started/database-and-models/#back-to-the-controller",
            "text": "Now that we have a model, we need to inject it into our controller so we can use\nit.  Firstly, we'll add a constructor to our controller. Open the file module/Album/src/Controller/AlbumController.php  and add the following property\nand constructor:  namespace Album\\Controller;\n\n// Add the following import:\nuse Album\\Model\\AlbumTable;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass AlbumController extends AbstractActionController\n{\n    // Add this property:\n    private $table;\n\n    // Add this constructor:\n    public function __construct(AlbumTable $table)\n    {\n        $this->table = $table;\n    }\n\n    /* ... */\n}  Our controller now depends on  AlbumTable , so we will need to create a factory\nfor the controller.  Similar to how we created factories for the model, we'll\ncreate in in our  Module  class, only this time, under a new method, Album\\Module::getControllerConfig() :  namespace Album;\n\nuse Zend\\Db\\Adapter\\Adapter;\nuse Zend\\Db\\ResultSet\\ResultSet;\nuse Zend\\Db\\TableGateway\\TableGateway;\nuse Zend\\ModuleManager\\Feature\\ConfigProviderInterface;\n\nclass Module implements ConfigProviderInterface\n{\n    // getConfig() and getServiceConfig methods are here\n\n    // Add this method:\n    public function getControllerConfig()\n    {\n        return [\n            'factories' => [\n                Controller\\AlbumController::class =>  function($container) {\n                    return new Controller\\AlbumController(\n                        $container->get(Model\\AlbumTable::class\n                    );\n                },\n            ],\n        ];\n    }\n}  Because we're now defining our own factory, we can modify our module.config.php  to remove the definition. Open module/Album/config/module.config.php  and remove the following lines:  <?php\nnamespace Album;\n\n// Remove this:\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    // And remove the entire \"controllers\" section here:\n    'controllers' => [\n        'factories' => [\n            Controller\\AlbumController::class => InvokableFactory::class,\n        ],\n    ],\n\n    /* ... */\n];  We can now access the property  $table  from within our controller whenever we\nneed to interact with our model.",
            "title": "Back to the controller"
        },
        {
            "location": "/getting-started/database-and-models/#listing-albums",
            "text": "In order to list the albums, we need to retrieve them from the model and pass\nthem to the view. To do this, we fill in  indexAction()  within AlbumController . Update the  AlbumController::indexAction()  as follows:  // module/Album/src/Controller/AlbumController.php:\n// ...\n    public function indexAction()\n    {\n        return new ViewModel([\n            'albums' => $this->table->fetchAll(),\n        ]);\n    }\n// ...  With Zend Framework, in order to set variables in the view, we return a ViewModel  instance where the first parameter of the constructor is an array\ncontaining data we wish to represent. These are then automatically passed to the\nview script. The  ViewModel  object also allows us to change the view script\nthat is used, but the default is to use  {module name}/{controller name}/{action\nname} . We can now fill in the  index.phtml  view script:  <?php\n// module/Album/view/album/album/index.phtml:\n\n$title = 'My albums';\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title); ?></h1>\n<p>\n    <a href=\"<?= $this->url('album', ['action'=>'add']) ?>\">Add new album</a>\n</p>\n\n<table class=\"table\">\n<tr>\n    <th>Title</th>\n    <th>Artist</th>\n    <th>&nbsp;</th>\n</tr>\n<?php foreach ($albums as $album) : ?>\n<tr>\n    <td><?= $this->escapeHtml($album->title) ?></td>\n    <td><?= $this->escapeHtml($album->artist) ?></td>\n    <td>\n        <a href=\"<?= $this->url('album', ['action'=>'edit', 'id' => $album->id]) ?>\">Edit</a>\n        <a href=\"<?= $this->url('album', ['action'=>'delete', 'id' => $album->id]) ?>\">Delete</a>\n    </td>\n</tr>\n<?php endforeach; ?>\n</table>  The first thing we do is to set the title for the page (used in the layout) and\nalso set the title for the  <head>  section using the  headTitle()  view helper\nwhich will display in the browser's title bar. We then create a link to add a\nnew album.  The  url()  view helper is provided by zend-mvc and zend-view, and is used to create\nthe links we need. The first parameter to  url()  is the route name we wish to\nuse for construction of the URL, and the second parameter is an array of\nvariables to substitute into route placeholders. In this case we use our  album \nroute which is set up to accept two placeholder variables:  action  and  id .  We iterate over the  $albums  that we assigned from the controller action.\nzend-view automatically ensures that these variables are extracted into the\nscope of the view script; you may also access them using  $this->{variable\nname}  in order to differentiate between variables provided to the view script\nand those created inside it.  We then create a table to display each album's title and artist, and provide\nlinks to allow for editing and deleting the record. A standard  foreach:  loop\nis used to iterate over the list of albums, and we use the alternate form using\na colon and  endforeach;  as it is easier to scan than to try and match up\nbraces. Again, the  url()  view helper is used to create the edit and delete\nlinks.",
            "title": "Listing albums"
        },
        {
            "location": "/getting-started/database-and-models/#escaping",
            "text": "We always use the  escapeHtml()  view helper to help protect ourselves from Cross Site Scripting (XSS) vulnerabilities .   If you open  http://localhost:8080/album  (or  http://zf2-tutorial.localhost/album  \nif you are using self-hosted Apache) you should see this:",
            "title": "Escaping"
        },
        {
            "location": "/getting-started/forms-and-actions/",
            "text": "Forms and actions\n\n\nAdding new albums\n\n\nWe can now code up the functionality to add new albums. There are two bits to this part:\n\n\n\n\nDisplay a form for user to provide details.\n\n\nProcess the form submission and store to database.\n\n\n\n\nWe will use zend-form to do this. zend-form manages the various form inputs as\nwell as their validation, the latter of which is handled by the zend-inputfilter\ncomponent. We'll start by creating a new class, \nAlbum\\Form\\AlbumForm\n,\nextending from \nZend\\Form\\Form\n. Create the file\n\nmodule/Album/src/Form/AlbumForm.php\n with the following contents:\n\n\nnamespace Album\\Form;\n\nuse Zend\\Form\\Form;\n\nclass AlbumForm extends Form\n{\n    public function __construct($name = null)\n    {\n        // We will ignore the name provided to the constructor\n        parent::__construct('album');\n\n        $this->add([\n            'name' => 'id',\n            'type' => 'hidden',\n        ]);\n        $this->add([\n            'name' => 'title',\n            'type' => 'text',\n            'options' => [\n                'label' => 'Title',\n            ],\n        ]);\n        $this->add([\n            'name' => 'artist',\n            'type' => 'text',\n            'options' => [\n                'label' => 'Artist',\n            ],\n        ]);\n        $this->add([\n            'name' => 'submit',\n            'type' => 'submit',\n            'attributes' => [\n                'value' => 'Go',\n                'id'    => 'submitbutton',\n            ],\n        ]);\n    }\n}\n\n\n\n\nWithin the constructor of \nAlbumForm\n we do several things. First, we set the\nname of the form as we call the parent's constructor. The, we create four form\nelements: the id, title, artist, and submit button. For each item we set various\nattributes and options, including the label to be displayed.\n\n\n\n\nForm method\n\n\nHTML forms can be sent using \nPOST\n and \nGET\n. zend-form defaults to \nPOST\n;\ntherefore you don't have to be explicit in setting this option. If you want to\nchange it to \nGET\n however, set the method attribute in the constructor:\n\n\n$this->setAttribute('method', 'GET');\n\n\n\n\n\n\nWe also need to set up validation for this form.  \nzend-inputfilter\n\nprovides a general purpose mechanism for input validation. It also provides an\ninterface, \nInputFilterAwareInterface\n, which zend-form will use in order to\nbind an input filter to a given form. We'll add this capability now to our\n\nAlbum\n class.\n\n\n// module/Album/src/Model/Album.php:\nnamespace Album\\Model;\n\n// Add the following import statements:\nuse DomainException;\nuse Zend\\InputFilter\\InputFilter;\nuse Zend\\InputFilter\\InputFilterAwareInterface;\nuse Zend\\InputFilter\\InputFilterInterface;\n\nclass Album implements InputFilterAwareInterface\n{\n    public $id;\n    public $artist;\n    public $title;\n\n    // Add this property:\n    private $inputFilter;\n\n    public function exchangeArray(array $data)\n    {\n        $this->id     = ! empty($data['id']) ? $data['id'] : null;\n        $this->artist = ! empty($data['artist']) ? $data['artist'] : null;\n        $this->title  = ! empty($data['title']) ? $data['title'] : null;\n    }\n\n    public function getArrayCopy()\n    {\n        return [\n            'id'     => $this->id,\n            'artist' => $this->artist,\n            'title'  => $this->title,\n        ];\n    }\n\n    /* Add the following methods: */\n\n    public function setInputFilter(InputFilterInterface $inputFilter)\n    {\n        throw new DomainException(sprintf(\n            '%s does not allow injection of an alternate input filter',\n            __CLASS__\n        ));\n    }\n\n    public function getInputFilter()\n    {\n        if ($this->inputFilter) {\n            return $this->inputFilter;\n        }\n\n        $inputFilter = new InputFilter();\n\n        $inputFilter->add([\n            'name' => 'id',\n            'required' => true,\n            'filters' => [\n                ['name' => 'int'],\n            ],\n        ]);\n\n        $inputFilter->add([\n            'name' => 'artist',\n            'required' => true,\n            'filters' => [\n                ['name' => 'StripTags'],\n                ['name' => 'StringTrim'],\n            ],\n            'validators' => [\n                [\n                    'name' => 'StringLength',\n                    'options' => [\n                        'encoding' => 'UTF-8',\n                        'min' => 1,\n                        'max' => 100,\n                    ],\n                ],\n            ],\n        ]);\n\n        $inputFilter->add([\n            'name' => 'title',\n            'required' => true,\n            'filters' => [\n                ['name' => 'StripTags'],\n                ['name' => 'StringTrim'],\n            ],\n            'validators' => [\n                [\n                    'name' => 'StringLength',\n                    'options' => [\n                        'encoding' => 'UTF-8',\n                        'min' => 1,\n                        'max' => 100,\n                    ],\n                ],\n            ],\n        ]);\n\n        $this->inputFilter = $inputFilter;\n        return $this->inputFilter;\n    }\n}\n\n\n\n\nThe \nInputFilterAwareInterface\n defines two methods: \nsetInputFilter()\n and\n\ngetInputFilter()\n. We only need to implement \ngetInputFilter()\n so we\nthrow an exception from \nsetInputFilter()\n.\n\n\nWithin \ngetInputFilter()\n, we instantiate an \nInputFilter\n and then add the\ninputs that we require. We add one input for each property that we wish to\nfilter or validate. For the \nid\n field we add an \nint\n filter as we only need\nintegers. For the text elements, we add two filters, \nStripTags\n and\n\nStringTrim\n, to remove unwanted HTML and unnecessary white space. We also set\nthem to be \nrequired\n and add a \nStringLength\n validator to ensure that the user\ndoesn't enter more characters than we can store into the database.\n\n\nWe now need to get the form to display and then process it on submission. This\nis done within the \nAlbumController::addAction()\n:\n\n\n// module/Album/src/Controller/AlbumController.php:\n\n// Add the following import statements at the top of the file:\nuse Album\\Form\\AlbumForm;\nuse Album\\Model\\Album;\n\nclass AlbumController extends AbstractActionController\n{\n    /* ... */\n\n    /* Update the following method to read as follows: */\n    public function addAction()\n    {\n        $form = new AlbumForm();\n        $form->get('submit')->setValue('Add');\n\n        $request = $this->getRequest();\n\n        if (! $request->isPost()) {\n            return ['form' => $form];\n        }\n\n        $album = new Album();\n        $form->setInputFilter($album->getInputFilter());\n        $form->setData($request->getPost());\n\n        if (! $form->isValid()) {\n            return ['form' => $form];\n        }\n\n        $album->exchangeArray($form->getData());\n        $this->table->saveAlbum($album);\n        return $this->redirect()->toRoute('album');\n    }\n\n    /* ... */\n}\n\n\n\n\nAfter adding the \nAlbum\n and \nAlbumForm\n classes to the import list, we\nimplement \naddAction()\n. Let's look at the \naddAction()\n code in a little more\ndetail:\n\n\n$form = new AlbumForm();\n$form->get('submit')->setValue('Add');\n\n\n\n\nWe instantiate \nAlbumForm\n and set the label on the submit button to \"Add\". We\ndo this here as we'll want to re-use the form when editing an album and will use\na different label.\n\n\n$request = $this->getRequest();\n\nif (! $request->isPost()) {\n    return ['form' => $form];\n}\n\n\n\n\nIf the request is not a \nPOST\n request, then no form data has been submitted,\nand we need to display the form. zend-mvc allows you to return an array of data\ninstead of a view model if desired; if you do, the array will be used to create\na view model.\n\n\n$album = new Album();\n$form->setInputFilter($album->getInputFilter());\n$form->setData($request->getPost());\n\n\n\n\nAt this point, we know we have a form submission. We create an \nAlbum\n instance,\nand pass its input filter on to the form; additionally, we pass the submitted\ndata from the request instance to the form.\n\n\nif (! $form->isValid()) {\n    return ['form' => $form];\n}\n\n\n\n\nIf form validation fails, we want to redisplay the form. At this point, the form\ncontains information about what fields failed validation, and why, and this\ninformation will be communicated to the view layer.\n\n\n$album->exchangeArray($form->getData());\n$this->getAlbumTable()->saveAlbum($album);\n\n\n\n\nIf the form is valid, then we grab the data from the form and store to the model\nusing \nsaveAlbum()\n.\n\n\nreturn $this->redirect()->toRoute('album');\n\n\n\n\nAfter we have saved the new album row, we redirect back to the list of albums\nusing the \nRedirect\n controller plugin.\n\n\nWe now need to render the form in the \nadd.phtml\n view script:\n\n\n<?php\n// module/Album/view/album/album/add.phtml:\n\n$title = 'Add new album';\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title) ?></h1>\n<?php\n$form->setAttribute('action', $this->url('album', ['action' => 'add']));\n$form->prepare();\n\necho $this->form()->openTag($form);\necho $this->formHidden($form->get('id'));\necho $this->formRow($form->get('title'));\necho $this->formRow($form->get('artist'));\necho $this->formSubmit($form->get('submit'));\necho $this->form()->closeTag();\n\n\n\n\nWe display a title as before, and then we render the form. zend-form provides\nseveral view helpers to make this a little easier. The \nform()\n view helper has\nan \nopenTag()\n and \ncloseTag()\n method which we use to open and close the form.\nThen for each element with a label, we can use \nformRow()\n to render the label,\ninput, and any validation error messages; for the two elements that are\nstandalone and have no validation rules, we use \nformHidden()\n and\n\nformSubmit()\n.\n\n\nAlternatively, the process of rendering the form can be simplified by using the\nbundled \nformCollection\n view helper. For example, in the view script above\nreplace all the form-rendering echo statements with:\n\n\necho $this->formCollection($form);\n\n\n\n\nThis will iterate over the form structure, calling the appropriate label,\nelement, and error view helpers for each element, but you still have to wrap\n\nformCollection($form)\n with the open and close form tags. This helps reduce the\ncomplexity of your view script in situations where the default HTML rendering of\nthe form is acceptable.\n\n\nYou should now be able to use the \"Add new album\" link on the home page of the\napplication to add a new album record, resulting in something like the\nfollowing:\n\n\n\n\nThis doesn't look all that great! The reason is because Bootstrap, the CSS\nfoundation used in the skeleton, has specialized markup for displaying forms! We\ncan address that in our view script by:\n\n\n\n\nAdding markup around the elements.\n\n\nRendering labels, elements, and error messages separately.\n\n\nAdding attributes to elements.\n\n\n\n\nUpdate your \nadd.phtml\n view script to read as follows:\n\n\n<?php\n$title = 'Add new album';\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title) ?></h1>\n<?php\n// This provides a default CSS class and placeholder text for the title element:\n$album = $form->get('title');\n$album->setAttribute('class', 'form-control');\n$album->setAttribute('placeholder', 'Album title');\n\n// This provides a default CSS class and placeholder text for the artist element:\n$artist = $form->get('artist');\n$artist->setAttribute('class', 'form-control');\n$artist->setAttribute('placeholder', 'Artist');\n\n// This provides CSS classes for the submit button:\n$submit = $form->get('submit');\n$submit->setAttribute('class', 'btn btn-primary');\n\n$form->setAttribute('action', $this->url('album', ['action' => 'add']));\n$form->prepare();\n\necho $this->form()->openTag($form);\n?>\n<?php // Wrap the elements in divs marked as form groups, and render the\n      // label, element, and errors separately within ?>\n<div class=\"form-group\">\n    <?= $this->formLabel($album) ?>\n    <?= $this->formElement($album) ?>\n    <?= $this->formElementErrors()->render($album, ['class' => 'help-block']) ?>\n</div>\n\n<div class=\"form-group\">\n    <?= $this->formLabel($artist) ?>\n    <?= $this->formElement($artist) ?>\n    <?= $this->formElementErrors()->render($artist, ['class' => 'help-block']) ?>\n</div>\n\n<?php\necho $this->formSubmit($submit);\necho $this->formHidden($form->get('id'));\necho $this->form()->closeTag();\n\n\n\n\nThe results we get are much better:\n\n\n\n\nThe above is meant to demonstrate both the ease of use of the default form\nfeatures, as well as some of the customizations possible when rendering forms.\nYou should be able to generate any markup necessary for your site.\n\n\nEditing an album\n\n\nEditing an album is almost identical to adding one, so the code is very similar.\nThis time we use \neditAction()\n in the \nAlbumController\n:\n\n\n// module/Album/src/Controller/AlbumController.php:\n// ...\n\n    public function editAction()\n    {\n        $id = (int) $this->params()->fromRoute('id', 0);\n\n        if (0 === $id) {\n            return $this->redirect()->toRoute('album', ['action' => 'add']);\n        }\n\n        // Retrieve the album with the specified id. Doing so raises\n        // an exception if the album is not found, which should result\n        // in redirecting to the landing page.\n        try {\n            $album = $this->table->getAlbum($id);\n        } catch (\\Exception $e) {\n            return $this->redirect()->toRoute('album', ['action' => 'index']);\n        }\n\n        $form = new AlbumForm();\n        $form->bind($album);\n        $form->get('submit')->setAttribute('value', 'Edit');\n\n        $request = $this->getRequest();\n        $viewData = ['id' => $id, 'form' => $form];\n\n        if (! $request->isPost()) {\n            return $viewData;\n        }\n\n        $form->setInputFilter($album->getInputFilter());\n        $form->setData($request->getPost());\n\n        if (! $form->isValid()) {\n            return $viewData;\n        }\n\n        $this->table->saveAlbum($album);\n\n        // Redirect to album list\n        return $this->redirect()->toRoute('album', ['action' => 'index']);\n    }\n\n\n\n\nThis code should look comfortably familiar. Let's look at the differences from\nadding an album. Firstly, we look for the \nid\n that is in the matched route and\nuse it to load the album to be edited:\n\n\n$id = (int) $this->params()->fromRoute('id', 0);\n\nif (0 === $id) {\n    return $this->redirect()->toRoute('album', ['action' => 'add']);\n}\n\n// Retrieve the album with the specified id. Doing so raises\n// an exception if the album is not found, which should result\n// in redirecting to the landing page.\ntry {\n    $album = $this->table->getAlbum($id);\n} catch (\\Exception $e) {\n    return $this->redirect()->toRoute('album', ['action' => 'index']);\n}\n\n\n\n\nparams\n is a controller plugin that provides a convenient way to retrieve\nparameters from the matched route. We use it to retrieve the \nid\n from the route\nwe created within the Album module's \nmodule.config.php\n. If the \nid\n is zero,\nthen we redirect to the add action, otherwise, we continue by getting the album\nentity from the database.\n\n\nWe have to check to make sure that the album with the specified \nid\n can\nactually be found. If it cannot, then the data access method throws an\nexception. We catch that exception and re-route the user to the index page.\n\n\n$form = new AlbumForm();\n$form->bind($album);\n$form->get('submit')->setAttribute('value', 'Edit');\n\n\n\n\nThe form's \nbind()\n method attaches the model to the form. This is used in two ways:\n\n\n\n\nWhen displaying the form, the initial values for each element are extracted\n  from the model.\n\n\nAfter successful validation in \nisValid()\n, the data from the form is put back\n  into the model.\n\n\n\n\nThese operations are done using a \nhydrator\n object. There are a number of\nhydrators, but the default one is \nZend\\Hydrator\\ArraySerializable\n which\nexpects to find two methods in the model: \ngetArrayCopy()\n and\n\nexchangeArray()\n. We have already written \nexchangeArray()\n in our \nAlbum\n\nentity, so we now need to write \ngetArrayCopy()\n:\n\n\n// module/Album/src/Model/Album.php:\n// ...\n\n    public function exchangeArray($data)\n    {\n        $this->id     = (isset($data['id']))     ? $data['id']     : null;\n        $this->artist = (isset($data['artist'])) ? $data['artist'] : null;\n        $this->title  = (isset($data['title']))  ? $data['title']  : null;\n    }\n\n    // Add the following method:\n    public function getArrayCopy()\n    {\n        return [\n            'id'     => $this->id,\n            'artist' => $this->artist,\n            'title'  => $this->title,\n        ];\n    }\n\n// ...\n\n\n\n\nAs a result of using \nbind()\n with its hydrator, we do not need to populate the\nform's data back into the \n$album\n as that's already been done, so we can just\ncall the mapper's \nsaveAlbum()\n method to store the changes back to the\ndatabase.\n\n\nThe view template, \nedit.phtml\n, looks very similar to the one for adding an album:\n\n\n<?php\n// module/Album/view/album/album/edit.phtml:\n\n$title = 'Edit album';\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title) ?></h1>\n<?php\n$album = $form->get('title');\n$album->setAttribute('class', 'form-control');\n$album->setAttribute('placeholder', 'Album title');\n\n$artist = $form->get('artist');\n$artist->setAttribute('class', 'form-control');\n$artist->setAttribute('placeholder', 'Artist');\n\n$submit = $form->get('submit');\n$submit->setAttribute('class', 'btn btn-primary');\n\n$form->setAttribute('action', $this->url('album', [\n    'action' => 'edit',\n    'id'     => $id,\n]));\n$form->prepare();\n\necho $this->form()->openTag($form);\n?>\n<div class=\"form-group\">\n    <?= $this->formLabel($album) ?>\n    <?= $this->formElement($album) ?>\n    <?= $this->formElementErrors()->render($album, ['class' => 'help-block']) ?>\n</div>\n\n<div class=\"form-group\">\n    <?= $this->formLabel($artist) ?>\n    <?= $this->formElement($artist) ?>\n    <?= $this->formElementErrors()->render($artist, ['class' => 'help-block']) ?>\n</div>\n\n<?php\necho $this->formSubmit($submit);\necho $this->formHidden($form->get('id'));\necho $this->form()->closeTag();\n\n\n\n\nThe only changes are to use the \u2018Edit Album' title and set the form's action to\nthe 'edit' action too, using the current album identifier.\n\n\nYou should now be able to edit albums.\n\n\nDeleting an album\n\n\nTo round out our application, we need to add deletion. We have a \"Delete\" link\nnext to each album on our list page, and the naive approach would be to do a\ndelete when it's clicked. This would be wrong. Remembering our HTTP spec, we\nrecall that you shouldn't do an irreversible action using GET and should use\nPOST instead.\n\n\nWe shall show a confirmation form when the user clicks delete, and if they then\nclick \"yes\", we will do the deletion. As the form is trivial, we'll code it\ndirectly into our view (zend-form is, after all, optional!).\n\n\nLet's start with the action code in \nAlbumController::deleteAction()\n:\n\n\n// module/Album/src/Album/Controller/AlbumController.php:\n//...\n    // Add content to the following method:\n    public function deleteAction()\n    {\n        $id = (int) $this->params()->fromRoute('id', 0);\n        if (!$id) {\n            return $this->redirect()->toRoute('album');\n        }\n\n        $request = $this->getRequest();\n        if ($request->isPost()) {\n            $del = $request->getPost('del', 'No');\n\n            if ($del == 'Yes') {\n                $id = (int) $request->getPost('id');\n                $this->getAlbumTable()->deleteAlbum($id);\n            }\n\n            // Redirect to list of albums\n            return $this->redirect()->toRoute('album');\n        }\n\n        return array(\n            'id'    => $id,\n            'album' => $this->getAlbumTable()->getAlbum($id)\n        );\n    }\n//...\n\n\n\n\nAs before, we get the \nid\n from the matched route, and check the request object's \nisPost()\n to determine whether to show the confirmation page or to delete the album. We use the table object to delete the row using the \ndeleteAlbum()\n method and then redirect back the list of albums. If the request is not a POST, then we retrieve the correct database record and assign to the view, along with the \nid\n.\n\n\nThe view script is a simple form:\n\n\n<?php\n// module/Album/view/album/album/delete.phtml:\n\n$title = 'Delete album';\n$url   = $this->url('album', ['action' => 'delete', 'id' => $id]);\n\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title) ?></h1>\n\n<p>\n    Are you sure that you want to delete\n    \"<?= $this->escapeHtml($album->title) ?>\" by\n    \"<?= $this->escapeHtml($album->artist) ?>\"?\n</p>\n\n<form action=\"<?= $url ?>\" method=\"post\">\n<div class=\"form-group\">\n    <input type=\"hidden\" name=\"id\" value=\"<?= (int) $album->id ?>\" />\n    <input type=\"submit\" class=\"btn btn-danger\" name=\"del\" value=\"Yes\" />\n    <input type=\"submit\" class=\"btn btn-success\" name=\"del\" value=\"No\" />\n</div>\n</form>\n\n\n\n\nIn this script, we display a confirmation message to the user and then a form\nwith \"Yes\" and \"No\" buttons. In the action, we checked specifically for the\n\"Yes\" value when doing the deletion.\n\n\nEnsuring that the home page displays the list of albums\n\n\nOne final point. At the moment, the home page, \nhttp://zf2-tutorial.localhost/\n\ndoesn't display the list of albums.\n\n\nThis is due to a route set up in the \nApplication\n module's \nmodule.config.php\n.\nTo change it, open \nmodule/Application/config/module.config.php\n and find the\nhome route:\n\n\n'home' => [\n    'type' => Literal::class,\n    'options' => [\n        'route'    => '/',\n        'defaults' => [\n            'controller' => Controller\\IndexController::class,\n            'action'     => 'index',\n        ],\n    ],\n],\n\n\n\n\nImport \nAlbum\\Controller\\AlbumController\n at the top of the file:\n\n\nuse Album\\Controller\\AlbumController;\n\n\n\n\nand change the \ncontroller\n from \nController\\IndexController::class\n to \nAlbumController::class\n:\n\n\n'home' => [\n    'type' => Literal::class,\n    'options' => [\n        'route'    => '/',\n        'defaults' => [\n            'controller' => AlbumController::class, // <-- change here\n            'action'     => 'index',\n        ],\n    ],\n],\n\n\n\n\nThat's it \u2014 you now have a fully working application!",
            "title": "Forms and Actions"
        },
        {
            "location": "/getting-started/forms-and-actions/#forms-and-actions",
            "text": "",
            "title": "Forms and actions"
        },
        {
            "location": "/getting-started/forms-and-actions/#adding-new-albums",
            "text": "We can now code up the functionality to add new albums. There are two bits to this part:   Display a form for user to provide details.  Process the form submission and store to database.   We will use zend-form to do this. zend-form manages the various form inputs as\nwell as their validation, the latter of which is handled by the zend-inputfilter\ncomponent. We'll start by creating a new class,  Album\\Form\\AlbumForm ,\nextending from  Zend\\Form\\Form . Create the file module/Album/src/Form/AlbumForm.php  with the following contents:  namespace Album\\Form;\n\nuse Zend\\Form\\Form;\n\nclass AlbumForm extends Form\n{\n    public function __construct($name = null)\n    {\n        // We will ignore the name provided to the constructor\n        parent::__construct('album');\n\n        $this->add([\n            'name' => 'id',\n            'type' => 'hidden',\n        ]);\n        $this->add([\n            'name' => 'title',\n            'type' => 'text',\n            'options' => [\n                'label' => 'Title',\n            ],\n        ]);\n        $this->add([\n            'name' => 'artist',\n            'type' => 'text',\n            'options' => [\n                'label' => 'Artist',\n            ],\n        ]);\n        $this->add([\n            'name' => 'submit',\n            'type' => 'submit',\n            'attributes' => [\n                'value' => 'Go',\n                'id'    => 'submitbutton',\n            ],\n        ]);\n    }\n}  Within the constructor of  AlbumForm  we do several things. First, we set the\nname of the form as we call the parent's constructor. The, we create four form\nelements: the id, title, artist, and submit button. For each item we set various\nattributes and options, including the label to be displayed.",
            "title": "Adding new albums"
        },
        {
            "location": "/getting-started/forms-and-actions/#form-method",
            "text": "HTML forms can be sent using  POST  and  GET . zend-form defaults to  POST ;\ntherefore you don't have to be explicit in setting this option. If you want to\nchange it to  GET  however, set the method attribute in the constructor:  $this->setAttribute('method', 'GET');   We also need to set up validation for this form.   zend-inputfilter \nprovides a general purpose mechanism for input validation. It also provides an\ninterface,  InputFilterAwareInterface , which zend-form will use in order to\nbind an input filter to a given form. We'll add this capability now to our Album  class.  // module/Album/src/Model/Album.php:\nnamespace Album\\Model;\n\n// Add the following import statements:\nuse DomainException;\nuse Zend\\InputFilter\\InputFilter;\nuse Zend\\InputFilter\\InputFilterAwareInterface;\nuse Zend\\InputFilter\\InputFilterInterface;\n\nclass Album implements InputFilterAwareInterface\n{\n    public $id;\n    public $artist;\n    public $title;\n\n    // Add this property:\n    private $inputFilter;\n\n    public function exchangeArray(array $data)\n    {\n        $this->id     = ! empty($data['id']) ? $data['id'] : null;\n        $this->artist = ! empty($data['artist']) ? $data['artist'] : null;\n        $this->title  = ! empty($data['title']) ? $data['title'] : null;\n    }\n\n    public function getArrayCopy()\n    {\n        return [\n            'id'     => $this->id,\n            'artist' => $this->artist,\n            'title'  => $this->title,\n        ];\n    }\n\n    /* Add the following methods: */\n\n    public function setInputFilter(InputFilterInterface $inputFilter)\n    {\n        throw new DomainException(sprintf(\n            '%s does not allow injection of an alternate input filter',\n            __CLASS__\n        ));\n    }\n\n    public function getInputFilter()\n    {\n        if ($this->inputFilter) {\n            return $this->inputFilter;\n        }\n\n        $inputFilter = new InputFilter();\n\n        $inputFilter->add([\n            'name' => 'id',\n            'required' => true,\n            'filters' => [\n                ['name' => 'int'],\n            ],\n        ]);\n\n        $inputFilter->add([\n            'name' => 'artist',\n            'required' => true,\n            'filters' => [\n                ['name' => 'StripTags'],\n                ['name' => 'StringTrim'],\n            ],\n            'validators' => [\n                [\n                    'name' => 'StringLength',\n                    'options' => [\n                        'encoding' => 'UTF-8',\n                        'min' => 1,\n                        'max' => 100,\n                    ],\n                ],\n            ],\n        ]);\n\n        $inputFilter->add([\n            'name' => 'title',\n            'required' => true,\n            'filters' => [\n                ['name' => 'StripTags'],\n                ['name' => 'StringTrim'],\n            ],\n            'validators' => [\n                [\n                    'name' => 'StringLength',\n                    'options' => [\n                        'encoding' => 'UTF-8',\n                        'min' => 1,\n                        'max' => 100,\n                    ],\n                ],\n            ],\n        ]);\n\n        $this->inputFilter = $inputFilter;\n        return $this->inputFilter;\n    }\n}  The  InputFilterAwareInterface  defines two methods:  setInputFilter()  and getInputFilter() . We only need to implement  getInputFilter()  so we\nthrow an exception from  setInputFilter() .  Within  getInputFilter() , we instantiate an  InputFilter  and then add the\ninputs that we require. We add one input for each property that we wish to\nfilter or validate. For the  id  field we add an  int  filter as we only need\nintegers. For the text elements, we add two filters,  StripTags  and StringTrim , to remove unwanted HTML and unnecessary white space. We also set\nthem to be  required  and add a  StringLength  validator to ensure that the user\ndoesn't enter more characters than we can store into the database.  We now need to get the form to display and then process it on submission. This\nis done within the  AlbumController::addAction() :  // module/Album/src/Controller/AlbumController.php:\n\n// Add the following import statements at the top of the file:\nuse Album\\Form\\AlbumForm;\nuse Album\\Model\\Album;\n\nclass AlbumController extends AbstractActionController\n{\n    /* ... */\n\n    /* Update the following method to read as follows: */\n    public function addAction()\n    {\n        $form = new AlbumForm();\n        $form->get('submit')->setValue('Add');\n\n        $request = $this->getRequest();\n\n        if (! $request->isPost()) {\n            return ['form' => $form];\n        }\n\n        $album = new Album();\n        $form->setInputFilter($album->getInputFilter());\n        $form->setData($request->getPost());\n\n        if (! $form->isValid()) {\n            return ['form' => $form];\n        }\n\n        $album->exchangeArray($form->getData());\n        $this->table->saveAlbum($album);\n        return $this->redirect()->toRoute('album');\n    }\n\n    /* ... */\n}  After adding the  Album  and  AlbumForm  classes to the import list, we\nimplement  addAction() . Let's look at the  addAction()  code in a little more\ndetail:  $form = new AlbumForm();\n$form->get('submit')->setValue('Add');  We instantiate  AlbumForm  and set the label on the submit button to \"Add\". We\ndo this here as we'll want to re-use the form when editing an album and will use\na different label.  $request = $this->getRequest();\n\nif (! $request->isPost()) {\n    return ['form' => $form];\n}  If the request is not a  POST  request, then no form data has been submitted,\nand we need to display the form. zend-mvc allows you to return an array of data\ninstead of a view model if desired; if you do, the array will be used to create\na view model.  $album = new Album();\n$form->setInputFilter($album->getInputFilter());\n$form->setData($request->getPost());  At this point, we know we have a form submission. We create an  Album  instance,\nand pass its input filter on to the form; additionally, we pass the submitted\ndata from the request instance to the form.  if (! $form->isValid()) {\n    return ['form' => $form];\n}  If form validation fails, we want to redisplay the form. At this point, the form\ncontains information about what fields failed validation, and why, and this\ninformation will be communicated to the view layer.  $album->exchangeArray($form->getData());\n$this->getAlbumTable()->saveAlbum($album);  If the form is valid, then we grab the data from the form and store to the model\nusing  saveAlbum() .  return $this->redirect()->toRoute('album');  After we have saved the new album row, we redirect back to the list of albums\nusing the  Redirect  controller plugin.  We now need to render the form in the  add.phtml  view script:  <?php\n// module/Album/view/album/album/add.phtml:\n\n$title = 'Add new album';\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title) ?></h1>\n<?php\n$form->setAttribute('action', $this->url('album', ['action' => 'add']));\n$form->prepare();\n\necho $this->form()->openTag($form);\necho $this->formHidden($form->get('id'));\necho $this->formRow($form->get('title'));\necho $this->formRow($form->get('artist'));\necho $this->formSubmit($form->get('submit'));\necho $this->form()->closeTag();  We display a title as before, and then we render the form. zend-form provides\nseveral view helpers to make this a little easier. The  form()  view helper has\nan  openTag()  and  closeTag()  method which we use to open and close the form.\nThen for each element with a label, we can use  formRow()  to render the label,\ninput, and any validation error messages; for the two elements that are\nstandalone and have no validation rules, we use  formHidden()  and formSubmit() .  Alternatively, the process of rendering the form can be simplified by using the\nbundled  formCollection  view helper. For example, in the view script above\nreplace all the form-rendering echo statements with:  echo $this->formCollection($form);  This will iterate over the form structure, calling the appropriate label,\nelement, and error view helpers for each element, but you still have to wrap formCollection($form)  with the open and close form tags. This helps reduce the\ncomplexity of your view script in situations where the default HTML rendering of\nthe form is acceptable.  You should now be able to use the \"Add new album\" link on the home page of the\napplication to add a new album record, resulting in something like the\nfollowing:   This doesn't look all that great! The reason is because Bootstrap, the CSS\nfoundation used in the skeleton, has specialized markup for displaying forms! We\ncan address that in our view script by:   Adding markup around the elements.  Rendering labels, elements, and error messages separately.  Adding attributes to elements.   Update your  add.phtml  view script to read as follows:  <?php\n$title = 'Add new album';\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title) ?></h1>\n<?php\n// This provides a default CSS class and placeholder text for the title element:\n$album = $form->get('title');\n$album->setAttribute('class', 'form-control');\n$album->setAttribute('placeholder', 'Album title');\n\n// This provides a default CSS class and placeholder text for the artist element:\n$artist = $form->get('artist');\n$artist->setAttribute('class', 'form-control');\n$artist->setAttribute('placeholder', 'Artist');\n\n// This provides CSS classes for the submit button:\n$submit = $form->get('submit');\n$submit->setAttribute('class', 'btn btn-primary');\n\n$form->setAttribute('action', $this->url('album', ['action' => 'add']));\n$form->prepare();\n\necho $this->form()->openTag($form);\n?>\n<?php // Wrap the elements in divs marked as form groups, and render the\n      // label, element, and errors separately within ?>\n<div class=\"form-group\">\n    <?= $this->formLabel($album) ?>\n    <?= $this->formElement($album) ?>\n    <?= $this->formElementErrors()->render($album, ['class' => 'help-block']) ?>\n</div>\n\n<div class=\"form-group\">\n    <?= $this->formLabel($artist) ?>\n    <?= $this->formElement($artist) ?>\n    <?= $this->formElementErrors()->render($artist, ['class' => 'help-block']) ?>\n</div>\n\n<?php\necho $this->formSubmit($submit);\necho $this->formHidden($form->get('id'));\necho $this->form()->closeTag();  The results we get are much better:   The above is meant to demonstrate both the ease of use of the default form\nfeatures, as well as some of the customizations possible when rendering forms.\nYou should be able to generate any markup necessary for your site.",
            "title": "Form method"
        },
        {
            "location": "/getting-started/forms-and-actions/#editing-an-album",
            "text": "Editing an album is almost identical to adding one, so the code is very similar.\nThis time we use  editAction()  in the  AlbumController :  // module/Album/src/Controller/AlbumController.php:\n// ...\n\n    public function editAction()\n    {\n        $id = (int) $this->params()->fromRoute('id', 0);\n\n        if (0 === $id) {\n            return $this->redirect()->toRoute('album', ['action' => 'add']);\n        }\n\n        // Retrieve the album with the specified id. Doing so raises\n        // an exception if the album is not found, which should result\n        // in redirecting to the landing page.\n        try {\n            $album = $this->table->getAlbum($id);\n        } catch (\\Exception $e) {\n            return $this->redirect()->toRoute('album', ['action' => 'index']);\n        }\n\n        $form = new AlbumForm();\n        $form->bind($album);\n        $form->get('submit')->setAttribute('value', 'Edit');\n\n        $request = $this->getRequest();\n        $viewData = ['id' => $id, 'form' => $form];\n\n        if (! $request->isPost()) {\n            return $viewData;\n        }\n\n        $form->setInputFilter($album->getInputFilter());\n        $form->setData($request->getPost());\n\n        if (! $form->isValid()) {\n            return $viewData;\n        }\n\n        $this->table->saveAlbum($album);\n\n        // Redirect to album list\n        return $this->redirect()->toRoute('album', ['action' => 'index']);\n    }  This code should look comfortably familiar. Let's look at the differences from\nadding an album. Firstly, we look for the  id  that is in the matched route and\nuse it to load the album to be edited:  $id = (int) $this->params()->fromRoute('id', 0);\n\nif (0 === $id) {\n    return $this->redirect()->toRoute('album', ['action' => 'add']);\n}\n\n// Retrieve the album with the specified id. Doing so raises\n// an exception if the album is not found, which should result\n// in redirecting to the landing page.\ntry {\n    $album = $this->table->getAlbum($id);\n} catch (\\Exception $e) {\n    return $this->redirect()->toRoute('album', ['action' => 'index']);\n}  params  is a controller plugin that provides a convenient way to retrieve\nparameters from the matched route. We use it to retrieve the  id  from the route\nwe created within the Album module's  module.config.php . If the  id  is zero,\nthen we redirect to the add action, otherwise, we continue by getting the album\nentity from the database.  We have to check to make sure that the album with the specified  id  can\nactually be found. If it cannot, then the data access method throws an\nexception. We catch that exception and re-route the user to the index page.  $form = new AlbumForm();\n$form->bind($album);\n$form->get('submit')->setAttribute('value', 'Edit');  The form's  bind()  method attaches the model to the form. This is used in two ways:   When displaying the form, the initial values for each element are extracted\n  from the model.  After successful validation in  isValid() , the data from the form is put back\n  into the model.   These operations are done using a  hydrator  object. There are a number of\nhydrators, but the default one is  Zend\\Hydrator\\ArraySerializable  which\nexpects to find two methods in the model:  getArrayCopy()  and exchangeArray() . We have already written  exchangeArray()  in our  Album \nentity, so we now need to write  getArrayCopy() :  // module/Album/src/Model/Album.php:\n// ...\n\n    public function exchangeArray($data)\n    {\n        $this->id     = (isset($data['id']))     ? $data['id']     : null;\n        $this->artist = (isset($data['artist'])) ? $data['artist'] : null;\n        $this->title  = (isset($data['title']))  ? $data['title']  : null;\n    }\n\n    // Add the following method:\n    public function getArrayCopy()\n    {\n        return [\n            'id'     => $this->id,\n            'artist' => $this->artist,\n            'title'  => $this->title,\n        ];\n    }\n\n// ...  As a result of using  bind()  with its hydrator, we do not need to populate the\nform's data back into the  $album  as that's already been done, so we can just\ncall the mapper's  saveAlbum()  method to store the changes back to the\ndatabase.  The view template,  edit.phtml , looks very similar to the one for adding an album:  <?php\n// module/Album/view/album/album/edit.phtml:\n\n$title = 'Edit album';\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title) ?></h1>\n<?php\n$album = $form->get('title');\n$album->setAttribute('class', 'form-control');\n$album->setAttribute('placeholder', 'Album title');\n\n$artist = $form->get('artist');\n$artist->setAttribute('class', 'form-control');\n$artist->setAttribute('placeholder', 'Artist');\n\n$submit = $form->get('submit');\n$submit->setAttribute('class', 'btn btn-primary');\n\n$form->setAttribute('action', $this->url('album', [\n    'action' => 'edit',\n    'id'     => $id,\n]));\n$form->prepare();\n\necho $this->form()->openTag($form);\n?>\n<div class=\"form-group\">\n    <?= $this->formLabel($album) ?>\n    <?= $this->formElement($album) ?>\n    <?= $this->formElementErrors()->render($album, ['class' => 'help-block']) ?>\n</div>\n\n<div class=\"form-group\">\n    <?= $this->formLabel($artist) ?>\n    <?= $this->formElement($artist) ?>\n    <?= $this->formElementErrors()->render($artist, ['class' => 'help-block']) ?>\n</div>\n\n<?php\necho $this->formSubmit($submit);\necho $this->formHidden($form->get('id'));\necho $this->form()->closeTag();  The only changes are to use the \u2018Edit Album' title and set the form's action to\nthe 'edit' action too, using the current album identifier.  You should now be able to edit albums.",
            "title": "Editing an album"
        },
        {
            "location": "/getting-started/forms-and-actions/#deleting-an-album",
            "text": "To round out our application, we need to add deletion. We have a \"Delete\" link\nnext to each album on our list page, and the naive approach would be to do a\ndelete when it's clicked. This would be wrong. Remembering our HTTP spec, we\nrecall that you shouldn't do an irreversible action using GET and should use\nPOST instead.  We shall show a confirmation form when the user clicks delete, and if they then\nclick \"yes\", we will do the deletion. As the form is trivial, we'll code it\ndirectly into our view (zend-form is, after all, optional!).  Let's start with the action code in  AlbumController::deleteAction() :  // module/Album/src/Album/Controller/AlbumController.php:\n//...\n    // Add content to the following method:\n    public function deleteAction()\n    {\n        $id = (int) $this->params()->fromRoute('id', 0);\n        if (!$id) {\n            return $this->redirect()->toRoute('album');\n        }\n\n        $request = $this->getRequest();\n        if ($request->isPost()) {\n            $del = $request->getPost('del', 'No');\n\n            if ($del == 'Yes') {\n                $id = (int) $request->getPost('id');\n                $this->getAlbumTable()->deleteAlbum($id);\n            }\n\n            // Redirect to list of albums\n            return $this->redirect()->toRoute('album');\n        }\n\n        return array(\n            'id'    => $id,\n            'album' => $this->getAlbumTable()->getAlbum($id)\n        );\n    }\n//...  As before, we get the  id  from the matched route, and check the request object's  isPost()  to determine whether to show the confirmation page or to delete the album. We use the table object to delete the row using the  deleteAlbum()  method and then redirect back the list of albums. If the request is not a POST, then we retrieve the correct database record and assign to the view, along with the  id .  The view script is a simple form:  <?php\n// module/Album/view/album/album/delete.phtml:\n\n$title = 'Delete album';\n$url   = $this->url('album', ['action' => 'delete', 'id' => $id]);\n\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title) ?></h1>\n\n<p>\n    Are you sure that you want to delete\n    \"<?= $this->escapeHtml($album->title) ?>\" by\n    \"<?= $this->escapeHtml($album->artist) ?>\"?\n</p>\n\n<form action=\"<?= $url ?>\" method=\"post\">\n<div class=\"form-group\">\n    <input type=\"hidden\" name=\"id\" value=\"<?= (int) $album->id ?>\" />\n    <input type=\"submit\" class=\"btn btn-danger\" name=\"del\" value=\"Yes\" />\n    <input type=\"submit\" class=\"btn btn-success\" name=\"del\" value=\"No\" />\n</div>\n</form>  In this script, we display a confirmation message to the user and then a form\nwith \"Yes\" and \"No\" buttons. In the action, we checked specifically for the\n\"Yes\" value when doing the deletion.",
            "title": "Deleting an album"
        },
        {
            "location": "/getting-started/forms-and-actions/#ensuring-that-the-home-page-displays-the-list-of-albums",
            "text": "One final point. At the moment, the home page,  http://zf2-tutorial.localhost/ \ndoesn't display the list of albums.  This is due to a route set up in the  Application  module's  module.config.php .\nTo change it, open  module/Application/config/module.config.php  and find the\nhome route:  'home' => [\n    'type' => Literal::class,\n    'options' => [\n        'route'    => '/',\n        'defaults' => [\n            'controller' => Controller\\IndexController::class,\n            'action'     => 'index',\n        ],\n    ],\n],  Import  Album\\Controller\\AlbumController  at the top of the file:  use Album\\Controller\\AlbumController;  and change the  controller  from  Controller\\IndexController::class  to  AlbumController::class :  'home' => [\n    'type' => Literal::class,\n    'options' => [\n        'route'    => '/',\n        'defaults' => [\n            'controller' => AlbumController::class, // <-- change here\n            'action'     => 'index',\n        ],\n    ],\n],  That's it \u2014 you now have a fully working application!",
            "title": "Ensuring that the home page displays the list of albums"
        },
        {
            "location": "/getting-started/conclusion/",
            "text": "Conclusion\n\n\nThis concludes our brief look at building a simple, but fully functional,\nZend Framework zend-mvc application.\n\n\nIn this tutorial we but briefly touched quite a number of different parts of the\nframework.\n\n\nThe most important part of applications built with zend-mvc are the\n\nmodules\n, the\nbuilding blocks of any \nzend-mvc application\n.\n\n\nTo ease the work with dependencies inside our applications, we use the\n\nservice manager\n.\n\n\nTo be able to map a request to controllers and their actions, we use\n\nroutes\n.\n\n\nData persistence was performed using\n\nzend-db\n to communicate with\na relational database. Input data is filtered and validated with \ninput\nfilters\n,\nand, together with \nzend-form\n,\nthey provide a strong bridge between the domain model and the view layer.\n\n\nzend-view\n is\nresponsible for the View in the MVC stack, together with a vast amount of\n\nview helpers\n.",
            "title": "Conclusion"
        },
        {
            "location": "/getting-started/conclusion/#conclusion",
            "text": "This concludes our brief look at building a simple, but fully functional,\nZend Framework zend-mvc application.  In this tutorial we but briefly touched quite a number of different parts of the\nframework.  The most important part of applications built with zend-mvc are the modules , the\nbuilding blocks of any  zend-mvc application .  To ease the work with dependencies inside our applications, we use the service manager .  To be able to map a request to controllers and their actions, we use routes .  Data persistence was performed using zend-db  to communicate with\na relational database. Input data is filtered and validated with  input\nfilters ,\nand, together with  zend-form ,\nthey provide a strong bridge between the domain model and the view layer.  zend-view  is\nresponsible for the View in the MVC stack, together with a vast amount of view helpers .",
            "title": "Conclusion"
        },
        {
            "location": "/advanced-config/",
            "text": "Advanced Configuration Tricks\n\n\nConfiguration of zend-mvc applications happens in several steps:\n\n\n\n\nInitial configuration is passed to the \nApplication\n instance and used to seed\n  the \nModuleManager\n and \nServiceManager\n. In this tutorial, we will call this\n  configuration \nsystem configuration\n.\n\n\nThe \nModuleManager\n's \nConfigListener\n aggregates configuration and merges it\n  while modules are being loaded. In this tutorial, we will call this\n  configuration \napplication configuration\n.\n\n\nOnce configuration is aggregated from all modules, the \nConfigListener\n will\n  also merge application configuration globbed in specified directories\n  (typically \nconfig/autoload/\n).\n\n\nFinally, immediately prior to the merged application configuration being\n  passed to the \nServiceManager\n, it is passed to a special \nEVENT_MERGE_CONFIG\n\n  event to allow further modification.\n\n\n\n\nIn this tutorial, we'll look at the exact sequence, and how you can tie into it.\n\n\nSystem configuration\n\n\nTo begin module loading, we have to tell the \nApplication\n instance about the\navailable modules and where they live, optionally provide some information to\nthe default module listeners (e.g., where application configuration lives, and\nwhat files to load; whether to cache merged configuration, and where; etc.), and\noptionally seed the \nServiceManager\n. For purposes of this tutorial we will call\nthis the \nsystem configuration\n.\n\n\nWhen using the skeleton application, the \nsystem configuration\n is by default\nin \nconfig/application.config.php\n. The defaults look like this:\n\n\n<?php\nreturn [\n    // This should be an array of module namespaces used in the application.\n    'modules' => [\n        'Application',\n    ],\n\n    // These are various options for the listeners attached to the ModuleManager\n    'module_listener_options' => [\n        // This should be an array of paths in which modules reside.\n        // If a string key is provided, the listener will consider that a module\n        // namespace, the value of that key the specific path to that module's\n        // Module class.\n        'module_paths' => [\n            './module',\n            './vendor',\n        ],\n\n        // An array of paths from which to glob configuration files after\n        // modules are loaded. These effectively overide configuration\n        // provided by modules themselves. Paths may use GLOB_BRACE notation.\n        'config_glob_paths' => [\n            'config/autoload/{{,*.}global,{,*.}local}.php',\n        ],\n\n        // Whether or not to enable a configuration cache.\n        // If enabled, the merged configuration will be cached and used in\n        // subsequent requests.\n        //'config_cache_enabled' => $booleanValue,\n\n        // The key used to create the configuration cache file name.\n        //'config_cache_key' => $stringKey,\n\n        // Whether or not to enable a module class map cache.\n        // If enabled, creates a module class map cache which will be used\n        // by in future requests, to reduce the autoloading process.\n        //'module_map_cache_enabled' => $booleanValue,\n\n        // The key used to create the class map cache file name.\n        //'module_map_cache_key' => $stringKey,\n\n        // The path in which to cache merged configuration.\n        //'cache_dir' => $stringPath,\n\n        // Whether or not to enable modules dependency checking.\n        // Enabled by default, prevents usage of modules that depend on other modules\n        // that weren't loaded.\n        // 'check_dependencies' => true,\n    ],\n\n    // Used to create an own service manager. May contain one or more child arrays.\n    //'service_listener_options' => [\n    //     array(\n    //         'service_manager' => $stringServiceManagerName,\n    //         'config_key'      => $stringConfigKey,\n    //         'interface'       => $stringOptionalInterface,\n    //         'method'          => $stringRequiredMethodName,\n    //     ],\n    // ]\n\n   // Initial configuration with which to seed the ServiceManager.\n   // Should be compatible with Zend\\ServiceManager\\Config.\n   // 'service_manager' => [],\n];\n\n\n\n\nThe system configuration is for the bits and pieces related to the MVC that run\nbefore your application is ready. The configuration is usually brief, and quite\nminimal.\n\n\nAlso, system configuration is used \nimmediately\n, and is not merged with any\nother configuration \u2014 which means, with the exception of the values under\nthe \nservice_manager\n key, it cannot be overridden by a module.\n\n\nThis leads us to our first trick: how do you provide environment-specific system\nconfiguration?\n\n\nEnvironment-specific system configuration\n\n\nWhat happens when you want to change the set of modules you use based on the\nenvironment? Or if the configuration caching should be enabled based on\nenvironment?\n\n\nIt is for this reason that the default system configuration we provide in the\nskeleton application is in PHP; providing it in PHP means you can\nprogrammatically manipulate it.\n\n\nAs an example, let's make the following requirements:\n\n\n\n\nWe want to use the \nZendDeveloperTools\n module in development only.\n\n\nWe want to have configuration caching on in production only.\n\n\n\n\nTo make this happen, we'll set an environment variable in our web server\nconfiguration, \nAPP_ENV\n. In Apache, you'd put a directive like the following in\neither your system-wide \napache.conf\n or \nhttpd.conf\n, or in the definition for\nyour virtual host; alternately, it can be placed in an \n.htaccess\n file.\n\n\nSetEnv \"APP_ENV\" \"development\"\n\n\n\n\nFor other web servers, consult the web server documentation to determine how to\nset environment variables.\n\n\nTo simplify matters, we'll assume the environment is \"production\" if no\nenvironment variable is present.\n\n\nWe'll modify the \nconfig/application.config.php\n file to read as follows:\n\n\n\n\nTODO\n\n\nRewrite this example to follow how zend-development mode works, as the changes\nintroduced in this example will break how zend-component-installer works!\n\n\n\n\n<?php\n$env = getenv('APP_ENV') ?: 'production';\n\n// Use the $env value to determine which modules to load\n$modules = [\n    'Application',\n];\n\nif ($env == 'development') {\n    $modules[] = 'ZendDeveloperTools';\n}\n\nreturn [\n    'modules' => $modules,\n\n    'module_listener_options' => [\n        'module_paths' => [\n            './module',\n            './vendor',\n        ],\n\n        'config_glob_paths' => [\n            'config/autoload/{{,*.}global,{,*.}local}.php',\n        ],\n\n        // Use the $env value to determine the state of the flag\n        'config_cache_enabled' => ($env == 'production'),\n\n        'config_cache_key' => 'app_config',\n\n        // Use the $env value to determine the state of the flag\n        'module_map_cache_enabled' => ($env === 'production'),\n\n        'module_map_cache_key' => 'module_map',\n\n        'cache_dir' => 'data/config/',\n\n        // Use the $env value to determine the state of the flag\n        'check_dependencies' => ($env !== 'production'),\n    ],\n];\n\n\n\n\nThis approach gives you flexibility to alter system-level settings.\n\n\nHowever, how about altering \napplication\n \nspecific\n settings (not system\nconfiguration) based on the environment?\n\n\nEnvironment-specific application configuration\n\n\nSometimes you want to change application configuration to load things such as\ndatabase adapters, log writers, cache adapters, and more based on the\nenvironment. These are typically managed in the service manager, and may be\ndefined by modules. You can override them at the application level via\n\nZend\\ModuleManager\\Listener\\ConfigListener\n, by specifying a glob path in the\n\nsystem configuration\n \u2014 the \nmodule_listener_options.config_glob_paths\n\nkey from the previous examples.\n\n\nThe default value for this is \nconfig/autoload/{{,*.}global,{,*.}local}.php\n.\nWhat this means is that it will look for \napplication configuration\n files in\nthe \nconfig/autoload\n directory, in the following order:\n\n\n\n\nglobal.php\n\n\n*.global.php\n\n\nlocal.php\n\n\n*.local.php\n\n\n\n\nThis allows you to define application-level defaults in \"global\" configuration\nfiles, which you would then commit to your version control system, and\nenvironment-specific overrides in your \"local\" configuration files, which you\nwould \nomit\n from version control.\n\n\nThis is a great solution for development, as it allows you to specify alternate\nconfiguration that's specific to your development environment without worrying\nabout accidently deploying it. However, what if you have more environments\n&mdash such as a \"testing\" or \"staging\" environment \u2014 and they each have\ntheir own specific overrides?\n\n\nAgain, the application environment variable comes to play. We can alter the glob\npath in the system configuration slightly:\n\n\n'config_glob_paths' => [\n    sprintf('config/autoload/{,*.}{global,%s,local}.php', $env)\n],\n\n\n\n\nThe above will allow you to define an additional set of application\nconfiguration files per environment; furthermore, these will be loaded \nonly\n if\nthat environment is detected!\n\n\nAs an example, consider the following tree of configuration files:\n\n\nconfig/\n    autoload/\n        global.php\n        local.php\n        users.development.php\n        users.testing.php\n        users.local.php\n\n\n\n\nIf \n$env\n evaluates to \ntesting\n, then the following files will be merged, in\nthe following order:\n\n\nglobal.php\nusers.testing.php\nlocal.php\nusers.local.php\n\n\n\n\nNote that \nusers.development.php\n is not loaded \u2014 this is because it will\nnot match the glob pattern!\n\n\nAlso, because of the order in which they are loaded, you can predict which\nvalues will overwrite the others, allowing you to both selectively overwrite as\nwell as debug later.\n\n\n\n\nOrder of config merging\n\n\nThe files under \nconfig/autoload/\n are merged \nafter\n your module\nconfiguration, detailed in next section. We have detailed it here, however, as\nsetting up the \napplication configuration\n glob path happens within the\n\nsystem configuration\n (\nconfig/application.config.php\n).\n\n\n\n\nModule Configuration\n\n\nOne responsibility of modules is to provide their own configuration to the\napplication. Modules have two general mechanisms for doing this.\n\n\nFirst\n, modules that either implement\n\nZend\\ModuleManager\\Feature\\ConfigProviderInterface\n and/or a \ngetConfig()\n\nmethod can return their configuration. The default, recommended implementation\nof the \ngetConfig()\n method is:\n\n\npublic function getConfig()\n{\n    return include __DIR__ . '/config/module.config.php';\n}\n\n\n\n\nwhere \nmodule.config.php\n returns a PHP array. From that PHP array you can\nprovide general configuration as well as configuration for all the available\n\nManager\n classes provided by the ServiceManager. Please refer to the\n\nConfiguration mapping table\n to see which\nconfiguration key is used for each specific \nManager\n.\n\n\nSecond\n, modules can implement a number of interfaces and/or methods related\nto specific service manager or plugin manager configuration. You will find an\noverview of all interfaces and their matching Module Configuration functions\ninside the \nConfiguration mapping table\n.\n\n\nMost interfaces are in the \nZend\\ModuleManager\\Feature\n namespace (some have\nmoved to the individual components), and each is expected to return an array of\nconfiguration for a service manager, as denoted in the section on\n\ndefault service configuration\n.\n\n\nConfiguration mapping table\n\n\n\n\n\n\n\n\nManager name\n\n\nInterface name\n\n\nModule method name\n\n\nConfig key name\n\n\n\n\n\n\n\n\n\n\nControllerPluginManager\n\n\nControllerPluginProviderInterface\n\n\ngetControllerPluginConfig()\n\n\ncontroller_plugins\n\n\n\n\n\n\nControllerManager\n\n\nControllerProviderInterface\n\n\ngetControllerConfig()\n\n\ncontrollers\n\n\n\n\n\n\nFilterManager\n\n\nFilterProviderInterface\n\n\ngetFilterConfig()\n\n\nfilters\n\n\n\n\n\n\nFormElementManager\n\n\nFormElementProviderInterface\n\n\ngetFormElementConfig()\n\n\nform_elements\n\n\n\n\n\n\nHydratorManager\n\n\nHydratorProviderInterface\n\n\ngetHydratorConfig()\n\n\nhydrators\n\n\n\n\n\n\nInputFilterManager\n\n\nInputFilterProviderInterface\n\n\ngetInputFilterConfig()\n\n\ninput_filters\n\n\n\n\n\n\nRoutePluginManager\n\n\nRouteProviderInterface\n\n\ngetRouteConfig()\n\n\nroute_manager\n\n\n\n\n\n\nSerializerAdapterManager\n\n\nSerializerProviderInterface\n\n\ngetSerializerConfig()\n\n\nserializers\n\n\n\n\n\n\nServiceLocator\n\n\nServiceProviderInterface\n\n\ngetServiceConfig()\n\n\nservice_manager\n\n\n\n\n\n\nValidatorManager\n\n\nValidatorProviderInterface\n\n\ngetValidatorConfig()\n\n\nvalidators\n\n\n\n\n\n\nViewHelperManager\n\n\nViewHelperProviderInterface\n\n\ngetViewHelperConfig()\n\n\nview_helpers\n\n\n\n\n\n\nLogProcessorManager\n\n\nLogProcessorProviderInterface\n\n\ngetLogProcessorConfig\n\n\nlog_processors\n\n\n\n\n\n\nLogWriterManager\n\n\nLogWriterProviderInterface\n\n\ngetLogWriterConfig\n\n\nlog_writers\n\n\n\n\n\n\n\n\nConfiguration Priority\n\n\nConsidering that you may have service configuration in your module configuration file, what has precedence?\n\n\nThe order in which they are merged is:\n\n\n\n\nconfiguration returned by the various service configuration methods in a module class\n\n\nconfiguration returned by \ngetConfig()\n\n\n\n\nIn other words, your \ngetConfig()\n wins over the various service configuration\nmethods. Additionally, and of particular note: the configuration returned from\nthose methods will \nnot\n be cached.\n\n\n\n\nUse cases for service configuration methods\n\n\nUse the various service configuration methods when you need to define closures\nor instance callbacks for factories, abstract factories, and initializers.\nThis prevents caching problems, and also allows you to write your\nconfiguration files in other markup formats.\n\n\n\n\nManipulating merged configuration\n\n\nOccasionally you will want to not just override an application configuration\nkey, but actually remove it. Since merging will not remove keys, how can you\nhandle this?\n\n\nZend\\ModuleManager\\Listener\\ConfigListener\n triggers a special event,\n\nZend\\ModuleManager\\ModuleEvent::EVENT_MERGE_CONFIG\n, after merging all\nconfiguration, but prior to it being passed to the \nServiceManager\n. By\nlistening to this event, you can inspect the merged configuration and manipulate\nit.\n\n\nThe \nConfigListener\n itself listens to the event at priority 1000 (i.e., very\nhigh), which is when the configuration is merged. You can tie into this to\nmodify the merged configuration from your module, via the \ninit()\n method.\n\n\nnamespace Foo;\n\nuse Zend\\ModuleManager\\ModuleEvent;\nuse Zend\\ModuleManager\\ModuleManager;\n\nclass Module\n{\n    public function init(ModuleManager $moduleManager)\n    {\n        $events = $moduleManager->getEventManager();\n\n        // Registering a listener at default priority, 1, which will trigger\n        // after the ConfigListener merges config.\n        $events->attach(ModuleEvent::EVENT_MERGE_CONFIG, array($this, 'onMergeConfig'));\n    }\n\n    public function onMergeConfig(ModuleEvent $e)\n    {\n        $configListener = $e->getConfigListener();\n        $config         = $configListener->getMergedConfig(false);\n\n        // Modify the configuration; here, we'll remove a specific key:\n        if (isset($config['some_key'])) {\n            unset($config['some_key']);\n        }\n\n        // Pass the changed configuration back to the listener:\n        $configListener->setMergedConfig($config);\n    }\n}\n\n\n\n\nAt this point, the merged application configuration will no longer contain the\nkey \nsome_key\n.\n\n\n\n\nCached configuration and merging\n\n\nIf a cached config is used by the \nModuleManager\n, the \nEVENT_MERGE_CONFIG\n\nevent will not be triggered. However, typically that means that what is cached\nwill be what was originally manipulated by your listener.\n\n\n\n\nConfiguration merging workflow\n\n\nTo cap off the tutorial, let's review how and when configuration is defined and\nmerged.\n\n\n\n\nSystem configuration\n\n\nDefined in \nconfig/application.config.php\n\n\nNo merging occurs\n\n\nAllows manipulation programmatically, which allows the ability to:\n\n\nAlter flags based on computed values\n\n\nAlter the configuration glob path based on computed values\n\n\nConfiguration is passed to the \nApplication\n instance, and then the\n  \nModuleManager\n in order to initialize the system.\n\n\n\n\n\n\nApplication configuration\n\n\nThe \nModuleManager\n loops through each module class in the order defined in the \nsystem configuration\n\n\nService configuration defined in \nModule\n class methods is aggregated\n\n\nConfiguration returned by \nModule::getConfig()\n is aggregated\n\n\nFiles detected from the \nservice configuration\n \nconfig_glob_paths\n\n  setting are merged, based on the order they resolve in the glob path.\n\n\nConfigListener\n triggers \nEVENT_MERGE_CONFIG\n:\n\n\nConfigListener\n merges configuration\n\n\nAny other event listeners manipulate the configuration\n\n\nMerged configuration is finally passed to the \nServiceManager",
            "title": "Advanced Configuration"
        },
        {
            "location": "/advanced-config/#advanced-configuration-tricks",
            "text": "Configuration of zend-mvc applications happens in several steps:   Initial configuration is passed to the  Application  instance and used to seed\n  the  ModuleManager  and  ServiceManager . In this tutorial, we will call this\n  configuration  system configuration .  The  ModuleManager 's  ConfigListener  aggregates configuration and merges it\n  while modules are being loaded. In this tutorial, we will call this\n  configuration  application configuration .  Once configuration is aggregated from all modules, the  ConfigListener  will\n  also merge application configuration globbed in specified directories\n  (typically  config/autoload/ ).  Finally, immediately prior to the merged application configuration being\n  passed to the  ServiceManager , it is passed to a special  EVENT_MERGE_CONFIG \n  event to allow further modification.   In this tutorial, we'll look at the exact sequence, and how you can tie into it.",
            "title": "Advanced Configuration Tricks"
        },
        {
            "location": "/advanced-config/#system-configuration",
            "text": "To begin module loading, we have to tell the  Application  instance about the\navailable modules and where they live, optionally provide some information to\nthe default module listeners (e.g., where application configuration lives, and\nwhat files to load; whether to cache merged configuration, and where; etc.), and\noptionally seed the  ServiceManager . For purposes of this tutorial we will call\nthis the  system configuration .  When using the skeleton application, the  system configuration  is by default\nin  config/application.config.php . The defaults look like this:  <?php\nreturn [\n    // This should be an array of module namespaces used in the application.\n    'modules' => [\n        'Application',\n    ],\n\n    // These are various options for the listeners attached to the ModuleManager\n    'module_listener_options' => [\n        // This should be an array of paths in which modules reside.\n        // If a string key is provided, the listener will consider that a module\n        // namespace, the value of that key the specific path to that module's\n        // Module class.\n        'module_paths' => [\n            './module',\n            './vendor',\n        ],\n\n        // An array of paths from which to glob configuration files after\n        // modules are loaded. These effectively overide configuration\n        // provided by modules themselves. Paths may use GLOB_BRACE notation.\n        'config_glob_paths' => [\n            'config/autoload/{{,*.}global,{,*.}local}.php',\n        ],\n\n        // Whether or not to enable a configuration cache.\n        // If enabled, the merged configuration will be cached and used in\n        // subsequent requests.\n        //'config_cache_enabled' => $booleanValue,\n\n        // The key used to create the configuration cache file name.\n        //'config_cache_key' => $stringKey,\n\n        // Whether or not to enable a module class map cache.\n        // If enabled, creates a module class map cache which will be used\n        // by in future requests, to reduce the autoloading process.\n        //'module_map_cache_enabled' => $booleanValue,\n\n        // The key used to create the class map cache file name.\n        //'module_map_cache_key' => $stringKey,\n\n        // The path in which to cache merged configuration.\n        //'cache_dir' => $stringPath,\n\n        // Whether or not to enable modules dependency checking.\n        // Enabled by default, prevents usage of modules that depend on other modules\n        // that weren't loaded.\n        // 'check_dependencies' => true,\n    ],\n\n    // Used to create an own service manager. May contain one or more child arrays.\n    //'service_listener_options' => [\n    //     array(\n    //         'service_manager' => $stringServiceManagerName,\n    //         'config_key'      => $stringConfigKey,\n    //         'interface'       => $stringOptionalInterface,\n    //         'method'          => $stringRequiredMethodName,\n    //     ],\n    // ]\n\n   // Initial configuration with which to seed the ServiceManager.\n   // Should be compatible with Zend\\ServiceManager\\Config.\n   // 'service_manager' => [],\n];  The system configuration is for the bits and pieces related to the MVC that run\nbefore your application is ready. The configuration is usually brief, and quite\nminimal.  Also, system configuration is used  immediately , and is not merged with any\nother configuration \u2014 which means, with the exception of the values under\nthe  service_manager  key, it cannot be overridden by a module.  This leads us to our first trick: how do you provide environment-specific system\nconfiguration?",
            "title": "System configuration"
        },
        {
            "location": "/advanced-config/#environment-specific-system-configuration",
            "text": "What happens when you want to change the set of modules you use based on the\nenvironment? Or if the configuration caching should be enabled based on\nenvironment?  It is for this reason that the default system configuration we provide in the\nskeleton application is in PHP; providing it in PHP means you can\nprogrammatically manipulate it.  As an example, let's make the following requirements:   We want to use the  ZendDeveloperTools  module in development only.  We want to have configuration caching on in production only.   To make this happen, we'll set an environment variable in our web server\nconfiguration,  APP_ENV . In Apache, you'd put a directive like the following in\neither your system-wide  apache.conf  or  httpd.conf , or in the definition for\nyour virtual host; alternately, it can be placed in an  .htaccess  file.  SetEnv \"APP_ENV\" \"development\"  For other web servers, consult the web server documentation to determine how to\nset environment variables.  To simplify matters, we'll assume the environment is \"production\" if no\nenvironment variable is present.  We'll modify the  config/application.config.php  file to read as follows:",
            "title": "Environment-specific system configuration"
        },
        {
            "location": "/advanced-config/#todo",
            "text": "Rewrite this example to follow how zend-development mode works, as the changes\nintroduced in this example will break how zend-component-installer works!   <?php\n$env = getenv('APP_ENV') ?: 'production';\n\n// Use the $env value to determine which modules to load\n$modules = [\n    'Application',\n];\n\nif ($env == 'development') {\n    $modules[] = 'ZendDeveloperTools';\n}\n\nreturn [\n    'modules' => $modules,\n\n    'module_listener_options' => [\n        'module_paths' => [\n            './module',\n            './vendor',\n        ],\n\n        'config_glob_paths' => [\n            'config/autoload/{{,*.}global,{,*.}local}.php',\n        ],\n\n        // Use the $env value to determine the state of the flag\n        'config_cache_enabled' => ($env == 'production'),\n\n        'config_cache_key' => 'app_config',\n\n        // Use the $env value to determine the state of the flag\n        'module_map_cache_enabled' => ($env === 'production'),\n\n        'module_map_cache_key' => 'module_map',\n\n        'cache_dir' => 'data/config/',\n\n        // Use the $env value to determine the state of the flag\n        'check_dependencies' => ($env !== 'production'),\n    ],\n];  This approach gives you flexibility to alter system-level settings.  However, how about altering  application   specific  settings (not system\nconfiguration) based on the environment?",
            "title": "TODO"
        },
        {
            "location": "/advanced-config/#environment-specific-application-configuration",
            "text": "Sometimes you want to change application configuration to load things such as\ndatabase adapters, log writers, cache adapters, and more based on the\nenvironment. These are typically managed in the service manager, and may be\ndefined by modules. You can override them at the application level via Zend\\ModuleManager\\Listener\\ConfigListener , by specifying a glob path in the system configuration  \u2014 the  module_listener_options.config_glob_paths \nkey from the previous examples.  The default value for this is  config/autoload/{{,*.}global,{,*.}local}.php .\nWhat this means is that it will look for  application configuration  files in\nthe  config/autoload  directory, in the following order:   global.php  *.global.php  local.php  *.local.php   This allows you to define application-level defaults in \"global\" configuration\nfiles, which you would then commit to your version control system, and\nenvironment-specific overrides in your \"local\" configuration files, which you\nwould  omit  from version control.  This is a great solution for development, as it allows you to specify alternate\nconfiguration that's specific to your development environment without worrying\nabout accidently deploying it. However, what if you have more environments\n&mdash such as a \"testing\" or \"staging\" environment \u2014 and they each have\ntheir own specific overrides?  Again, the application environment variable comes to play. We can alter the glob\npath in the system configuration slightly:  'config_glob_paths' => [\n    sprintf('config/autoload/{,*.}{global,%s,local}.php', $env)\n],  The above will allow you to define an additional set of application\nconfiguration files per environment; furthermore, these will be loaded  only  if\nthat environment is detected!  As an example, consider the following tree of configuration files:  config/\n    autoload/\n        global.php\n        local.php\n        users.development.php\n        users.testing.php\n        users.local.php  If  $env  evaluates to  testing , then the following files will be merged, in\nthe following order:  global.php\nusers.testing.php\nlocal.php\nusers.local.php  Note that  users.development.php  is not loaded \u2014 this is because it will\nnot match the glob pattern!  Also, because of the order in which they are loaded, you can predict which\nvalues will overwrite the others, allowing you to both selectively overwrite as\nwell as debug later.",
            "title": "Environment-specific application configuration"
        },
        {
            "location": "/advanced-config/#order-of-config-merging",
            "text": "The files under  config/autoload/  are merged  after  your module\nconfiguration, detailed in next section. We have detailed it here, however, as\nsetting up the  application configuration  glob path happens within the system configuration  ( config/application.config.php ).",
            "title": "Order of config merging"
        },
        {
            "location": "/advanced-config/#module-configuration",
            "text": "One responsibility of modules is to provide their own configuration to the\napplication. Modules have two general mechanisms for doing this.  First , modules that either implement Zend\\ModuleManager\\Feature\\ConfigProviderInterface  and/or a  getConfig() \nmethod can return their configuration. The default, recommended implementation\nof the  getConfig()  method is:  public function getConfig()\n{\n    return include __DIR__ . '/config/module.config.php';\n}  where  module.config.php  returns a PHP array. From that PHP array you can\nprovide general configuration as well as configuration for all the available Manager  classes provided by the ServiceManager. Please refer to the Configuration mapping table  to see which\nconfiguration key is used for each specific  Manager .  Second , modules can implement a number of interfaces and/or methods related\nto specific service manager or plugin manager configuration. You will find an\noverview of all interfaces and their matching Module Configuration functions\ninside the  Configuration mapping table .  Most interfaces are in the  Zend\\ModuleManager\\Feature  namespace (some have\nmoved to the individual components), and each is expected to return an array of\nconfiguration for a service manager, as denoted in the section on default service configuration .",
            "title": "Module Configuration"
        },
        {
            "location": "/advanced-config/#configuration-mapping-table",
            "text": "Manager name  Interface name  Module method name  Config key name      ControllerPluginManager  ControllerPluginProviderInterface  getControllerPluginConfig()  controller_plugins    ControllerManager  ControllerProviderInterface  getControllerConfig()  controllers    FilterManager  FilterProviderInterface  getFilterConfig()  filters    FormElementManager  FormElementProviderInterface  getFormElementConfig()  form_elements    HydratorManager  HydratorProviderInterface  getHydratorConfig()  hydrators    InputFilterManager  InputFilterProviderInterface  getInputFilterConfig()  input_filters    RoutePluginManager  RouteProviderInterface  getRouteConfig()  route_manager    SerializerAdapterManager  SerializerProviderInterface  getSerializerConfig()  serializers    ServiceLocator  ServiceProviderInterface  getServiceConfig()  service_manager    ValidatorManager  ValidatorProviderInterface  getValidatorConfig()  validators    ViewHelperManager  ViewHelperProviderInterface  getViewHelperConfig()  view_helpers    LogProcessorManager  LogProcessorProviderInterface  getLogProcessorConfig  log_processors    LogWriterManager  LogWriterProviderInterface  getLogWriterConfig  log_writers",
            "title": "Configuration mapping table"
        },
        {
            "location": "/advanced-config/#configuration-priority",
            "text": "Considering that you may have service configuration in your module configuration file, what has precedence?  The order in which they are merged is:   configuration returned by the various service configuration methods in a module class  configuration returned by  getConfig()   In other words, your  getConfig()  wins over the various service configuration\nmethods. Additionally, and of particular note: the configuration returned from\nthose methods will  not  be cached.",
            "title": "Configuration Priority"
        },
        {
            "location": "/advanced-config/#use-cases-for-service-configuration-methods",
            "text": "Use the various service configuration methods when you need to define closures\nor instance callbacks for factories, abstract factories, and initializers.\nThis prevents caching problems, and also allows you to write your\nconfiguration files in other markup formats.",
            "title": "Use cases for service configuration methods"
        },
        {
            "location": "/advanced-config/#manipulating-merged-configuration",
            "text": "Occasionally you will want to not just override an application configuration\nkey, but actually remove it. Since merging will not remove keys, how can you\nhandle this?  Zend\\ModuleManager\\Listener\\ConfigListener  triggers a special event, Zend\\ModuleManager\\ModuleEvent::EVENT_MERGE_CONFIG , after merging all\nconfiguration, but prior to it being passed to the  ServiceManager . By\nlistening to this event, you can inspect the merged configuration and manipulate\nit.  The  ConfigListener  itself listens to the event at priority 1000 (i.e., very\nhigh), which is when the configuration is merged. You can tie into this to\nmodify the merged configuration from your module, via the  init()  method.  namespace Foo;\n\nuse Zend\\ModuleManager\\ModuleEvent;\nuse Zend\\ModuleManager\\ModuleManager;\n\nclass Module\n{\n    public function init(ModuleManager $moduleManager)\n    {\n        $events = $moduleManager->getEventManager();\n\n        // Registering a listener at default priority, 1, which will trigger\n        // after the ConfigListener merges config.\n        $events->attach(ModuleEvent::EVENT_MERGE_CONFIG, array($this, 'onMergeConfig'));\n    }\n\n    public function onMergeConfig(ModuleEvent $e)\n    {\n        $configListener = $e->getConfigListener();\n        $config         = $configListener->getMergedConfig(false);\n\n        // Modify the configuration; here, we'll remove a specific key:\n        if (isset($config['some_key'])) {\n            unset($config['some_key']);\n        }\n\n        // Pass the changed configuration back to the listener:\n        $configListener->setMergedConfig($config);\n    }\n}  At this point, the merged application configuration will no longer contain the\nkey  some_key .",
            "title": "Manipulating merged configuration"
        },
        {
            "location": "/advanced-config/#cached-configuration-and-merging",
            "text": "If a cached config is used by the  ModuleManager , the  EVENT_MERGE_CONFIG \nevent will not be triggered. However, typically that means that what is cached\nwill be what was originally manipulated by your listener.",
            "title": "Cached configuration and merging"
        },
        {
            "location": "/advanced-config/#configuration-merging-workflow",
            "text": "To cap off the tutorial, let's review how and when configuration is defined and\nmerged.   System configuration  Defined in  config/application.config.php  No merging occurs  Allows manipulation programmatically, which allows the ability to:  Alter flags based on computed values  Alter the configuration glob path based on computed values  Configuration is passed to the  Application  instance, and then the\n   ModuleManager  in order to initialize the system.    Application configuration  The  ModuleManager  loops through each module class in the order defined in the  system configuration  Service configuration defined in  Module  class methods is aggregated  Configuration returned by  Module::getConfig()  is aggregated  Files detected from the  service configuration   config_glob_paths \n  setting are merged, based on the order they resolve in the glob path.  ConfigListener  triggers  EVENT_MERGE_CONFIG :  ConfigListener  merges configuration  Any other event listeners manipulate the configuration  Merged configuration is finally passed to the  ServiceManager",
            "title": "Configuration merging workflow"
        },
        {
            "location": "/db-adapter/",
            "text": "Setting up a database adapter\n\n\n\n\nTODO\n\n\nCompletely rewrite this to only demonstrate:\n\n\n\n\nUsing factories to inject adapters into controllers, etc.\n\n\nDemonstrating configuration of the default adapter\n\n\nDemonstrating retrieval of the default adapter for purposes of injection\n\n\nUsing the abstract factory to create named adapters\n\n\nDemonstrating configuration of named adapters\n\n\nDemonstrating retrieval of named adapters for purposes of injection\n\n\n\n\n\n\nIn most cases, e.g. in your controllers, your database adapter can be fetched\ndirectly from the service manager. Some classes however, like\n\nZend\\Validator\\DbRecordExists\n, are not aware of the service manager, but still\nneed an adapter to function.\n\n\nThere are many different ways to provide this functionality to your application.\nBelow are a few examples.\n\n\nBasic setup\n\n\nNormally you will setup your database adapter using a factory in the service\nmanager in your configuration. It might look something like this:\n\n\n// config/autoload/global.php\nuse Zend\\Db\\Adapter\\Adapter;\nuse Zend\\Db\\Adapter\\AdapterServiceFactory;\n\nreturn [\n    'db' => [\n        'driver' => 'Pdo',\n        'dsn'    => 'mysql:dbname=zf2tutorial;host=localhost',\n    ],\n    'service_manager' => [\n        'factories' => [\n            Adapter::class => AdapterServiceFactory::class,\n        ],\n    ],\n];\n\n\n\n\nThe adapter can then be accessed in any ServiceLocatorAware classes.\n\n\npublic function getAdapter()\n{\n    if (! $this->adapter) {\n        $sm = $this->getServiceLocator();\n        $this->adapter = $sm->get('Zend\\Db\\Adapter\\Adapter');\n    }\n    return $this->adapter;\n}\n\n\n\n\nMore information on adapter options can be found in the docs for\n\nZend\\Db\\Adapter\n.\n\n\nSetting a static adapter\n\n\nIn order to utilize this adapter in non-ServiceLocatorAware classes, you can use\n\nZend\\Db\\TableGateway\\Feature\\GlobalAdapterFeature::setStaticAdapter()\n to set a\nstatic adapter:\n\n\n// config/autoload/global.php\nuse Zend\\Db\\Adapter\\Adapter;\nuse Zend\\Db\\Adapter\\AdapterServiceFactory;\nuse Zend\\Db\\TableGateway\\Feature\\GlobalAdapterFeature;\n\nreturn [\n    'db' => [\n        'driver'         => 'Pdo',\n        'dsn'            => 'mysql:dbname=zf2tutorial;host=localhost',\n    ],\n    'service_manager' => [\n        'factories' => [\n            Adapter::class => function ($serviceManager) {\n                $adapterFactory = new AdapterServiceFactory();\n                $adapter = $adapterFactory->createService($serviceManager);\n                GlobalAdapterFeature::setStaticAdapter($adapter);\n                return $adapter;\n            }\n        ],\n    ],\n];\n\n\n\n\nThe adapter can then later be fetched using\n\nZend\\Db\\TableGateway\\Feature\\GlobalAdapterFeature::getStaticAdapter()\n for use\nin e.g. \nZend\\Validator\\DbRecordExists\n:\n\n\nuse Zend\\Db\\TableGateway\\Feature\\GlobalAdapterFeature;\nuse Zend\\Validator\\Db\\RecordExists;\n\n$validator = new RecordExists([\n    'table'   => 'users',\n    'field'   => 'emailaddress',\n    'adapter' => GlobalAdapterFeature::getStaticAdapter()\n]);",
            "title": "Setting Up A Database Adapter"
        },
        {
            "location": "/db-adapter/#setting-up-a-database-adapter",
            "text": "",
            "title": "Setting up a database adapter"
        },
        {
            "location": "/db-adapter/#todo",
            "text": "Completely rewrite this to only demonstrate:   Using factories to inject adapters into controllers, etc.  Demonstrating configuration of the default adapter  Demonstrating retrieval of the default adapter for purposes of injection  Using the abstract factory to create named adapters  Demonstrating configuration of named adapters  Demonstrating retrieval of named adapters for purposes of injection    In most cases, e.g. in your controllers, your database adapter can be fetched\ndirectly from the service manager. Some classes however, like Zend\\Validator\\DbRecordExists , are not aware of the service manager, but still\nneed an adapter to function.  There are many different ways to provide this functionality to your application.\nBelow are a few examples.",
            "title": "TODO"
        },
        {
            "location": "/db-adapter/#basic-setup",
            "text": "Normally you will setup your database adapter using a factory in the service\nmanager in your configuration. It might look something like this:  // config/autoload/global.php\nuse Zend\\Db\\Adapter\\Adapter;\nuse Zend\\Db\\Adapter\\AdapterServiceFactory;\n\nreturn [\n    'db' => [\n        'driver' => 'Pdo',\n        'dsn'    => 'mysql:dbname=zf2tutorial;host=localhost',\n    ],\n    'service_manager' => [\n        'factories' => [\n            Adapter::class => AdapterServiceFactory::class,\n        ],\n    ],\n];  The adapter can then be accessed in any ServiceLocatorAware classes.  public function getAdapter()\n{\n    if (! $this->adapter) {\n        $sm = $this->getServiceLocator();\n        $this->adapter = $sm->get('Zend\\Db\\Adapter\\Adapter');\n    }\n    return $this->adapter;\n}  More information on adapter options can be found in the docs for Zend\\Db\\Adapter .",
            "title": "Basic setup"
        },
        {
            "location": "/db-adapter/#setting-a-static-adapter",
            "text": "In order to utilize this adapter in non-ServiceLocatorAware classes, you can use Zend\\Db\\TableGateway\\Feature\\GlobalAdapterFeature::setStaticAdapter()  to set a\nstatic adapter:  // config/autoload/global.php\nuse Zend\\Db\\Adapter\\Adapter;\nuse Zend\\Db\\Adapter\\AdapterServiceFactory;\nuse Zend\\Db\\TableGateway\\Feature\\GlobalAdapterFeature;\n\nreturn [\n    'db' => [\n        'driver'         => 'Pdo',\n        'dsn'            => 'mysql:dbname=zf2tutorial;host=localhost',\n    ],\n    'service_manager' => [\n        'factories' => [\n            Adapter::class => function ($serviceManager) {\n                $adapterFactory = new AdapterServiceFactory();\n                $adapter = $adapterFactory->createService($serviceManager);\n                GlobalAdapterFeature::setStaticAdapter($adapter);\n                return $adapter;\n            }\n        ],\n    ],\n];  The adapter can then later be fetched using Zend\\Db\\TableGateway\\Feature\\GlobalAdapterFeature::getStaticAdapter()  for use\nin e.g.  Zend\\Validator\\DbRecordExists :  use Zend\\Db\\TableGateway\\Feature\\GlobalAdapterFeature;\nuse Zend\\Validator\\Db\\RecordExists;\n\n$validator = new RecordExists([\n    'table'   => 'users',\n    'field'   => 'emailaddress',\n    'adapter' => GlobalAdapterFeature::getStaticAdapter()\n]);",
            "title": "Setting a static adapter"
        },
        {
            "location": "/event-manager/",
            "text": "Using the EventManager\n\n\n\n\nTODO\n\n\n\n\nWeasel words\n\n\nEnsure usage is up-to-date with current API\n\n\n\n\n\n\nThis tutorial explores the various features of \nZend\\EventManager\n.\n\n\nTerminology\n\n\n\n\nAn \nEvent\n is a named action.\n\n\nA \nListener\n is any PHP callback that reacts to an \nevent\n.\n\n\nAn \nEventManager\n \naggregates\n listeners for one or more named events, and\n  \ntriggers\n events.\n\n\n\n\nTypically, an \nevent\n will be modeled as an object, containing metadata\nsurrounding when and how it was triggered, including the event name, what object\ntriggered the event (the \"target\"), and what parameters were provided. Events\nare \nnamed\n, which allows a single \nlistener\n to branch logic based on the\nevent.\n\n\nGetting started\n\n\nThe minimal things necessary to start using events are:\n\n\n\n\nAn \nEventManager\n instance\n\n\nOne or more listeners on one or more events\n\n\nA call to \ntrigger()\n an event\n\n\n\n\nThe simplest example looks something like this:\n\n\nuse Zend\\EventManager\\EventManager;\n\n$events = new EventManager();\n$events->attach('do', function ($e) {\n    $event = $e->getName();\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\", with parameters %s',\n        $event,\n        json_encode($params)\n    );\n});\n\n$params = ['foo' => 'bar', 'baz' => 'bat'];\n$events->trigger('do', null, $params);\n\n\n\n\nThe above will result in the following:\n\n\nHandled event \"do\", with parameters {\"foo\":\"bar\",\"baz\":\"bat\"}\n\n\n\n\n\n\nClosures are not required\n\n\nThroughout this tutorial, we use closures as listeners. However, any valid PHP\ncallback can be attached as a listeners: PHP function names, static class\nmethods, object instance methods, functors, or closures. We use closures\nwithin this post simply for illustration and simplicity.\n\n\n\n\nIf you were paying attention to the example, you will have noted the \nnull\n\nargument. Why is it there?\n\n\nTypically, you will compose an \nEventManager\n within a class, to allow\ntriggering actions within methods. The middle argument to \ntrigger()\n is the\n\"target\", and in the case described, would be the current object instance. This\ngives event listeners access to the calling object, which can often be useful.\n\n\nuse Zend\\EventManager\\EventManager;\nuse Zend\\EventManager\\EventManagerAwareInterface;\nuse Zend\\EventManager\\EventManagerInterface;\n\nclass Example implements EventManagerAwareInterface\n{\n    protected $events;\n\n    public function setEventManager(EventManagerInterface $events)\n    {\n        $events->setIdentifiers([\n            __CLASS__,\n            get_class($this)\n        ]);\n        $this->events = $events;\n    }\n\n    public function getEventManager()\n    {\n        if (! $this->events) {\n            $this->setEventManager(new EventManager());\n        }\n        return $this->events;\n    }\n\n    public function doIt($foo, $baz)\n    {\n        $params = compact('foo', 'baz');\n        $this->getEventManager()->trigger(__FUNCTION__, $this, $params);\n    }\n\n}\n\n$example = new Example();\n\n$example->getEventManager()->attach('doIt', function($e) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget()); // \"Example\"\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\" on target \"%s\", with parameters %s',\n        $event,\n        $target,\n        json_encode($params)\n    );\n});\n\n$example->doIt('bar', 'bat');\n\n\n\n\nThe above is basically the same as the first example. The main difference is\nthat we're now using that middle argument in order to pass the target, the\ninstance of \nExample\n, on to the listeners. Our listener is now retrieving that\n(\n$e->getTarget()\n), and doing something with it.\n\n\nIf you're reading this critically, you should have a new question: What is the\ncall to \nsetIdentifiers()\n for?\n\n\nShared managers\n\n\nOne aspect that the \nEventManager\n implementation provides is an ability to\ncompose a \nSharedEventManagerInterface\n implementation.\n\n\nZend\\EventManager\\SharedEventManagerInterface\n describes an object that\naggregates listeners for events attached to objects with specific \nidentifiers\n.\nIt does not trigger events itself. Instead, an \nEventManager\n instance that\ncomposes a \nSharedEventManager\n will query the \nSharedEventManager\n for\nlisteners on identifiers it's interested in, and trigger those listeners as\nwell.\n\n\nHow does this work, exactly?\n\n\nConsider the following:\n\n\nuse Zend\\EventManager\\SharedEventManager;\n\n$sharedEvents = new SharedEventManager();\n$sharedEvents->attach('Example', 'do', function ($e) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget()); // \"Example\"\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\" on target \"%s\", with parameters %s',\n        $event,\n        $target,\n        json_encode($params)\n    );\n});\n\n\n\n\nThis looks almost identical to the previous example; the key difference is that\nthere is an additional argument at the \nstart\n of the list, \n'Example'\n. This\ncode is basically saying, \"Listen to the 'do' event of the 'Example' target,\nand, when notified, execute this callback.\"\n\n\nThis is where the \nsetIdentifiers()\n argument of \nEventManager\n comes into play.\nThe method allows passing a string, or an array of strings, defining the name or\nnames of the context or targets the given instance will be interested in. If an\narray is given, then any listener on any of the targets given will be notified.\n\n\nSo, getting back to our example, let's assume that the above shared listener is\nregistered, and also that the \nExample\n class is defined as above. We can then\nexecute the following:\n\n\n$example = new Example();\n$example->getEventManager()->setSharedManager($sharedEvents);\n$example->do('bar', 'bat');\n\n\n\n\nand expect the following to be \necho\n'd:\n\n\nHandled event \"do\" on target \"Example\", with parameters {\"foo\":\"bar\",\"baz\":\"bat\"}\n\n\n\n\nNow, let's say we extended \nExample\n as follows:\n\n\nclass SubExample extends Example\n{\n}\n\n\n\n\nOne interesting aspect of our \nsetEventManager()\n method is that we defined it\nto listen both on \n__CLASS__\n and \nget_class($this)\n. This means that calling\n\ndo()\n on our \nSubExample\n class would also trigger the shared listener! It also\nmeans that, if desired, we could attach to specifically \nSubExample\n, and\nlisteners attached to only the \nExample\n target would not be triggered.\n\n\nFinally, the names used as contexts or targets need not be class names; they can\nbe some name that only has meaning in your application if desired. As an\nexample, you could have a set of classes that respond to \"log\" or \"cache\"\n\u2014 and listeners on these would be notified by any of them.\n\n\n\n\nUse class names as identifiers\n\n\nWe recommend using class names, interface names, and/or abstract class names\nfor identifiers. This makes determining what events are available easier, as\nwell as finding which listeners might be attaching to those events. Interfaces\nmake a particularly good use case, as they allow attaching to a group of\nrelated classes a single operation.\n\n\n\n\nAt any point, if you do not want to notify shared listeners, pass a \nnull\n value\nto \nsetSharedManager()\n:\n\n\n$events->setSharedManager(null);\n\n\n\n\nand they will be ignored. If at any point, you want to enable them again, pass\nthe \nSharedEventManager\n instance:\n\n\n$events->setSharedManager($sharedEvents);\n\n\n\n\nWildcards\n\n\nSo far, with both a normal \nEventManager\n instance and with the\n\nSharedEventManager\n instance, we've seen the usage of singular strings\nrepresenting the event and target names to which we want to attach. What if you\nwant to attach a listener to multiple events or targets?\n\n\nThe answer is to supply an array of events or targets, or a wildcard, \n*\n.\n\n\nConsider the following examples:\n\n\n// Multiple named events:\n$events->attach(\n    ['foo', 'bar', 'baz'], // events\n    $listener\n);\n\n// All events via wildcard:\n$events->attach(\n    '*', // all events\n    $listener\n);\n\n// Multiple named targets:\n$sharedEvents->attach(\n    ['Foo', 'Bar', 'Baz'], // targets\n    'doSomething', // named event\n    $listener\n);\n\n// All targets via wildcard\n$sharedEvents->attach(\n    '*', // all targets\n    'doSomething', // named event\n    $listener\n);\n\n// Mix and match: multiple named events on multiple named targets:\n$sharedEvents->attach(\n    ['Foo', 'Bar', 'Baz'], // targets\n    ['foo', 'bar', 'baz'], // events\n    $listener\n);\n\n// Mix and match: all events on multiple named targets:\n$sharedEvents->attach(\n    ['Foo', 'Bar', 'Baz'], // targets\n    '*', // events\n    $listener\n);\n\n// Mix and match: multiple named events on all targets:\n$sharedEvents->attach(\n    '*', // targets\n    ['foo', 'bar', 'baz'], // events\n    $listener\n);\n\n// Mix and match: all events on all targets:\n$sharedEvents->attach(\n    '*', // targets\n    '*', // events\n    $listener\n);\n\n\n\n\nThe ability to specify multiple targets and/or events when attaching can slim\ndown your code immensely.\n\n\nListener aggregates\n\n\nAnother approach to listening to multiple events is via a concept of listener\naggregates, represented by \nZend\\EventManager\\ListenerAggregateInterface\n. Via\nthis approach, a single class can listen to multiple events, attaching one or\nmore instance methods as listeners.\n\n\nThis interface defines two methods, \nattach(EventManagerInterface $events)\n and\n\ndetach(EventManagerInterface $events)\n. Basically, you pass an \nEventManager\n\ninstance to one and/or the other, and then it's up to the implementing class to\ndetermine what to do.\n\n\nAs an example:\n\n\nuse Zend\\EventManager\\EventInterface;\nuse Zend\\EventManager\\EventManagerInterface;\nuse Zend\\EventManager\\ListenerAggregateInterface;\nuse Zend\\Log\\Logger;\n\nclass LogEvents implements ListenerAggregateInterface\n{\n    protected $listeners = [];\n    protected $log;\n\n    public function __construct(Logger $log)\n    {\n        $this->log = $log;\n    }\n\n    public function attach(EventManagerInterface $events)\n    {\n        $this->listeners[] = $events->attach('do', [$this, 'log']);\n        $this->listeners[] = $events->attach('doSomethingElse', [$this, 'log']);\n    }\n\n    public function detach(EventCollection $events)\n    {\n        foreach ($this->listeners as $index => $listener) {\n            if ($events->detach($listener)) {\n                unset($this->listeners[$index]);\n            }\n        }\n    }\n\n    public function log(EventInterface $e)\n    {\n        $event  = $e->getName();\n        $params = $e->getParams();\n        $this->log->info(sprintf('%s: %s', $event, json_encode($params)));\n    }\n}\n\n\n\n\nYou can attach this using either \nattach()\n or \nattachAggregate()\n:\n\n\n$logListener = new LogEvents($logger);\n\n$events->attachAggregate($logListener); // OR\n$events->attach($logListener);\n\n\n\n\nAny events the aggregate attaches to will then be notified when triggered.\n\n\nWhy bother? For a couple of reasons:\n\n\n\n\nAggregates allow you to have stateful listeners. The above example\n  demonstrates this via the composition of the logger; another example would be\n  tracking configuration options.\n\n\nAggregates make detaching listeners easier. When you call \nattach()\n\n  normally, you receive a \nZend\\Stdlib\\CallbackHandler\n instance; the only way\n  to \ndetach()\n a listener is to pass that instance back \u2014 which means\n  if you want to detach later, you need to keep that instance somewhere.\n  Aggregates typically do this for you \u2014 as you can see in the example above.\n\n\n\n\nIntrospecting results\n\n\nSometimes you'll want to know what your listeners returned. One thing to\nremember is that you may have multiple listeners on the same event; the\ninterface for results must be consistent regardless of the number of listeners.\n\n\nThe \nEventManager\n implementation by default returns a\n\nZend\\EventManager\\ResponseCollection\n instance. This class extends PHP's\n\nSplStack\n, allowing you to loop through responses in reverse order (since the\nlast one executed is likely the one you're most interested in). It also\nimplements the following methods:\n\n\n\n\nfirst()\n will retrieve the first result received\n\n\nlast()\n will retrieve the last result received\n\n\ncontains($value)\n allows you to test all values to see if a given one was\n  received, and returns simply a boolean \ntrue\n if found, and \nfalse\n if not.\n\n\n\n\nTypically, you should not worry about the return values from events, as the\nobject triggering the event shouldn't really have much insight into what\nlisteners are attached. However, sometimes you may want to short-circuit\nexecution if interesting results are obtained.\n\n\nShort-circuiting listener execution\n\n\nYou may want to short-ciruit execution if a particular result is obtained, or if\na listener determines that something is wrong, or that it can return something\nquicker than the target.\n\n\nAs examples, one rationale for adding an \nEventManager\n is as a caching\nmechanism. You can trigger one event early in the method, returning if a cache\nis found, and trigger another event late in the method, seeding the cache.\n\n\nThe \nEventManager\n component offers two ways to handle this. The first is to\npass a callback as the last argument to \ntrigger()\n; if that callback returns a\nboolean \ntrue\n, execution is halted.\n\n\nHere's an example:\n\n\npublic function someExpensiveCall($criteria1, $criteria2)\n{\n    $params  = compact('criteria1', 'criteria2');\n    $results = $this->getEventManager()->trigger(\n        __FUNCTION__, \n        $this, \n        $params, \n        function ($r) {\n            return ($r instanceof SomeResultClass);\n        }\n    );\n    if ($results->stopped()) {\n        return $results->last();\n    }\n\n    // ... do some work ...\n}\n\n\n\n\nWith this paradigm, we know that the likely reason of execution halting is due\nto the last result meeting the test callback criteria; as such, we simply return\nthat last result.\n\n\nThe other way to halt execution is within a listener, acting on the \nEvent\n\nobject it receives. In this case, the listener calls \nstopPropagation(true)\n,\nand the \nEventManager\n will then return without notifying any additional\nlisteners.\n\n\n$events->attach('do', function ($e) {\n    $e->stopPropagation();\n    return new SomeResultClass();\n});\n\n\n\n\nThis, of course, raises some ambiguity when using the trigger paradigm, as you\ncan no longer be certain that the last result meets the criteria it's searching\non. As such, we recommend that you standardize on one approach or the other.\n\n\nKeeping it in order\n\n\nOn occasion, you may be concerned about the order in which listeners execute. As\nan example, you may want to do any logging early, to ensure that if\nshort-circuiting occurs, you've logged; or if implementing a cache, you may want\nto return early if a cache hit is found, and execute late when saving to a\ncache.\n\n\nEach of \nEventManager::attach()\n and \nSharedEventManager::attach()\n accept one\nadditional argument, a \npriority\n. By default, if this is omitted, listeners get\na priority of 1, and are executed in the order in which they are attached.\nHowever, if you provide a priority value, you can influence order of execution.\n\n\n\n\nHigher priority values execute \nearlier\n.\n\n\nLower (negative) priority values execute \nlater\n.\n\n\n\n\nTo borrow an example from earlier:\n\n\n$priority = 100;\n$events->attach('Example', 'do', function($e) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget()); // \"Example\"\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\" on target \"%s\", with parameters %s',\n        $event,\n        $target,\n        json_encode($params)\n    );\n}, $priority);\n\n\n\n\nThis would execute with high priority, meaning it would execute early. If we\nchanged \n$priority\n to \n-100\n, it would execute with low priority, executing\nlate.\n\n\nWhile you can't necessarily know all the listeners attached, chances are you can\nmake adequate guesses when necessary in order to set appropriate priority\nvalues. We advise avoiding setting a priority value unless absolutely necessary.\n\n\nCustom event objects\n\n\nHopefully some of you have been wondering, \"where and when is the Event object\ncreated\"? In all of the examples above, it's created based on the arguments\npassed to \ntrigger()\n \u2014 the event name, target, and parameters. Sometimes,\nhowever, you may want greater control over the object.\n\n\nAs an example, one thing that looks like a code smell is when you have code like\nthis:\n\n\n$routeMatch = $e->getParam('route-match', false);\nif (! $routeMatch) {\n    // Oh noes! we cannot do our work! whatever shall we do?!?!?!\n}\n\n\n\n\nThe problems with this are several. First, relying on string keys is going to\nvery quickly run into problems \u2014 typos when setting or retrieving the\nargument can lead to hard to debug situations. Second, we now have a\ndocumentation issue; how do we document expected arguments? how do we document\nwhat we're shoving into the event? Third, as a side effect, we can't use IDE or\neditor hinting support \u2014 string keys give these tools nothing to work\nwith.\n\n\nSimilarly, consider how you might represent a computational result of a method\nwhen triggering an event. As an example:\n\n\n// in the method:\n$params['__RESULT'] = $computedResult;\n$events->trigger(__FUNCTION__ . '.post', $this, $params);\n\n// in the listener:\n$result = $e->getParam('__RESULT__');\nif (! $result) {\n    // Oh noes! we cannot do our work! whatever shall we do?!?!?!\n}\n\n\n\n\nSure, that key may be unique, but it suffers from a lot of the same issues.\n\n\nSo, the solution is to create custom events. As an example, we have a custom\n\nMvcEvent\n in the ZF2 MVC layer. This event composes the application instance,\nthe router, the route match object, request and response objects, the view\nmodel, and also a result. We end up with code like this in our listeners:\n\n\n$response = $e->getResponse();\n$result   = $e->getResult();\nif (is_string($result)) {\n    $content = $view->render('layout.phtml', ['content' => $result]);\n    $response->setContent($content);\n}\n\n\n\n\nBut how do we use this custom event? Simple: \ntrigger()\n can accept an event\nobject instead of any of the event name, target, or params arguments.\n\n\n$event = new CustomEvent();\n$event->setSomeKey($value);\n\n// Injected with event name and target:\n$events->trigger('foo', $this, $event);\n\n// Injected with event name:\n$event->setTarget($this);\n$events->trigger('foo', $event);\n\n// Fully encapsulates all necessary properties:\n$event->setName('foo');\n$event->setTarget($this);\n$events->trigger($event);\n\n// Passing a callback following the event object works for \n// short-circuiting, too.\n$results = $events->trigger('foo', $this, $event, $callback);\n\n\n\n\nThis is a really powerful technique for domain-specific event systems, and\ndefinitely worth experimenting with.\n\n\nPutting it together: Implementing a simple caching system\n\n\nIn previous sections, I indicated that short-circuiting is a way to potentially\nimplement a caching solution. Let's create a full example.\n\n\nFirst, let's define a method that could use caching. You'll note that in most of\nthe examples, I've used \n__FUNCTION__\n as the event name; this is a good\npractice, as it makes it simple to create a macro for triggering events, as well\nas helps to keep event names unique (as they're usually within the context of\nthe triggering class). However, in the case of a caching example, this would\nlead to identical events being triggered. As such, I recommend postfixing the\nevent name with semantic names: \"do.pre\", \"do.post\", \"do.error\", etc. I'll use\nthat convention in this example.\n\n\nAdditionally, you'll notice that the \n$params\n I pass to the event is usually\nthe list of parameters passed to the method. This is because those are often not\nstored in the object, and also to ensure the listeners have the exact same\ncontext as the calling method. But it raises an interesting problem in this\nexample: what name do we give the result of the method? One standard that has\nemerged is the use of \n__RESULT__\n, as double-underscored variables are\ntypically reserved for the sytem.\n\n\nHere's what the method will look like:\n\n\npublic function someExpensiveCall($criteria1, $criteria2)\n{\n    $params  = compact('criteria1', 'criteria2');\n    $results = $this->getEventManager()->trigger(\n        __FUNCTION__ . '.pre',\n        $this,\n        $params,\n        function ($r) {\n            return ($r instanceof SomeResultClass);\n        }\n    );\n    if ($results->stopped()) {\n        return $results->last();\n    }\n\n    // ... do some work ...\n\n    $params['__RESULT__'] = $calculatedResult;\n    $this->events()->trigger(__FUNCTION__ . '.post', $this, $params);\n    return $calculatedResult;\n}\n\n\n\n\nNow, to provide some caching listeners. We'll need to attach to each of the\n\"someExpensiveCall.pre\" and \"someExpensiveCall.post\" methods. In the former\ncase, if a cache hit is detected, we return it, and move on. In the latter, we\nstore the value in the cache.\n\n\nWe'll assume \n$cache\n is defined, and follows the paradigms of \nZend\\Cache\n.\nWe'll want to return early if a hit is detected, and execute late when saving a\ncache (in case the result is modified by another listener). As such, we'll set\nthe \"someExpensiveCall.pre\" listener to execute with priority \n100\n, and the\n\"someExpensiveCall.post\" listener to execute with priority \n-100\n.\n\n\n$events->attach('someExpensiveCall.pre', function($e) use ($cache) {\n    $params = $e->getParams();\n    $key    = md5(json_encode($params));\n    $hit    = $cache->load($key);\n    return $hit;\n}, 100);\n\n$events->attach('someExpensiveCall.post', function($e) use ($cache) {\n    $params = $e->getParams();\n    $result = $params['__RESULT__'];\n    unset($params['__RESULT__']);\n    $key    = md5(json_encode($params));\n    $cache->save($result, $key);\n}, -100);\n\n\n\n\n\n\nListenerAggregates allow stateful listeners\n\n\nThe above could have been done within a \nListenerAggregate\n, which would have\nallowed keeping the \n$cache\n instance as a stateful property, instead of\nimporting it into closures.\n\n\n\n\nAnother approach would be to move the body of the method to a listener as well,\nwhich would allow using the priority system in order to implement caching. That\nwould look like this:\n\n\npublic function setEventManager(EventManagerInterface $events)\n{\n    $this->events = $events;\n    $events->setIdentifiers([__CLASS__, get_class($this)));\n    $events->attach('someExpensiveCall', [$this, 'doSomeExpensiveCall']);\n}\n\npublic function someExpensiveCall($criteria1, $criteria2)\n{\n    $params  = compact('criteria1', 'criteria2');\n    $results = $this->getEventManager()->trigger(\n        __FUNCTION__,\n        $this,\n        $params,\n        function ($r) {\n            return ($r instanceof SomeResultClass);\n        }\n    );\n    return $results->last();\n}\n\npublic function doSomeExpensiveCall($e)\n{\n    // ... do some work ...\n    $e->setParam('__RESULT__', $calculatedResult);\n    return $calculatedResult;\n}\n\n\n\n\nThe listeners would then attach to the \"someExpensiveCall\" event, with the cache\nlookup listener listening at high priority, and the cache storage listener\nlistening at low (negative) priority.\n\n\nSure, we could probably simply add caching to the object itself \u2014 but this\napproach allows the same handlers to be attached to multiple events, or to\nattach multiple listeners to the same events (e.g. an argument validator, a\nlogger and a cache manager). The point is that if you design your object with\nevents in mind, you can easily make it more flexible and extensible, without\nrequiring developers to actually extend it \u2014 they can simply attach\nlisteners.\n\n\nConclusion\n\n\nThe \nEventManager\n is a powerful component. It drives the workflow of the MVC\nlayer, and is used in countless components to provide hook points for developers\nto manipulate the workflow. It can be put to any number of uses inside your own\ncode, and is an important part of your Zend Framework toolbox.",
            "title": "Using the EventManager"
        },
        {
            "location": "/event-manager/#using-the-eventmanager",
            "text": "",
            "title": "Using the EventManager"
        },
        {
            "location": "/event-manager/#todo",
            "text": "Weasel words  Ensure usage is up-to-date with current API    This tutorial explores the various features of  Zend\\EventManager .",
            "title": "TODO"
        },
        {
            "location": "/event-manager/#terminology",
            "text": "An  Event  is a named action.  A  Listener  is any PHP callback that reacts to an  event .  An  EventManager   aggregates  listeners for one or more named events, and\n   triggers  events.   Typically, an  event  will be modeled as an object, containing metadata\nsurrounding when and how it was triggered, including the event name, what object\ntriggered the event (the \"target\"), and what parameters were provided. Events\nare  named , which allows a single  listener  to branch logic based on the\nevent.",
            "title": "Terminology"
        },
        {
            "location": "/event-manager/#getting-started",
            "text": "The minimal things necessary to start using events are:   An  EventManager  instance  One or more listeners on one or more events  A call to  trigger()  an event   The simplest example looks something like this:  use Zend\\EventManager\\EventManager;\n\n$events = new EventManager();\n$events->attach('do', function ($e) {\n    $event = $e->getName();\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\", with parameters %s',\n        $event,\n        json_encode($params)\n    );\n});\n\n$params = ['foo' => 'bar', 'baz' => 'bat'];\n$events->trigger('do', null, $params);  The above will result in the following:  Handled event \"do\", with parameters {\"foo\":\"bar\",\"baz\":\"bat\"}",
            "title": "Getting started"
        },
        {
            "location": "/event-manager/#closures-are-not-required",
            "text": "Throughout this tutorial, we use closures as listeners. However, any valid PHP\ncallback can be attached as a listeners: PHP function names, static class\nmethods, object instance methods, functors, or closures. We use closures\nwithin this post simply for illustration and simplicity.   If you were paying attention to the example, you will have noted the  null \nargument. Why is it there?  Typically, you will compose an  EventManager  within a class, to allow\ntriggering actions within methods. The middle argument to  trigger()  is the\n\"target\", and in the case described, would be the current object instance. This\ngives event listeners access to the calling object, which can often be useful.  use Zend\\EventManager\\EventManager;\nuse Zend\\EventManager\\EventManagerAwareInterface;\nuse Zend\\EventManager\\EventManagerInterface;\n\nclass Example implements EventManagerAwareInterface\n{\n    protected $events;\n\n    public function setEventManager(EventManagerInterface $events)\n    {\n        $events->setIdentifiers([\n            __CLASS__,\n            get_class($this)\n        ]);\n        $this->events = $events;\n    }\n\n    public function getEventManager()\n    {\n        if (! $this->events) {\n            $this->setEventManager(new EventManager());\n        }\n        return $this->events;\n    }\n\n    public function doIt($foo, $baz)\n    {\n        $params = compact('foo', 'baz');\n        $this->getEventManager()->trigger(__FUNCTION__, $this, $params);\n    }\n\n}\n\n$example = new Example();\n\n$example->getEventManager()->attach('doIt', function($e) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget()); // \"Example\"\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\" on target \"%s\", with parameters %s',\n        $event,\n        $target,\n        json_encode($params)\n    );\n});\n\n$example->doIt('bar', 'bat');  The above is basically the same as the first example. The main difference is\nthat we're now using that middle argument in order to pass the target, the\ninstance of  Example , on to the listeners. Our listener is now retrieving that\n( $e->getTarget() ), and doing something with it.  If you're reading this critically, you should have a new question: What is the\ncall to  setIdentifiers()  for?",
            "title": "Closures are not required"
        },
        {
            "location": "/event-manager/#shared-managers",
            "text": "One aspect that the  EventManager  implementation provides is an ability to\ncompose a  SharedEventManagerInterface  implementation.  Zend\\EventManager\\SharedEventManagerInterface  describes an object that\naggregates listeners for events attached to objects with specific  identifiers .\nIt does not trigger events itself. Instead, an  EventManager  instance that\ncomposes a  SharedEventManager  will query the  SharedEventManager  for\nlisteners on identifiers it's interested in, and trigger those listeners as\nwell.  How does this work, exactly?  Consider the following:  use Zend\\EventManager\\SharedEventManager;\n\n$sharedEvents = new SharedEventManager();\n$sharedEvents->attach('Example', 'do', function ($e) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget()); // \"Example\"\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\" on target \"%s\", with parameters %s',\n        $event,\n        $target,\n        json_encode($params)\n    );\n});  This looks almost identical to the previous example; the key difference is that\nthere is an additional argument at the  start  of the list,  'Example' . This\ncode is basically saying, \"Listen to the 'do' event of the 'Example' target,\nand, when notified, execute this callback.\"  This is where the  setIdentifiers()  argument of  EventManager  comes into play.\nThe method allows passing a string, or an array of strings, defining the name or\nnames of the context or targets the given instance will be interested in. If an\narray is given, then any listener on any of the targets given will be notified.  So, getting back to our example, let's assume that the above shared listener is\nregistered, and also that the  Example  class is defined as above. We can then\nexecute the following:  $example = new Example();\n$example->getEventManager()->setSharedManager($sharedEvents);\n$example->do('bar', 'bat');  and expect the following to be  echo 'd:  Handled event \"do\" on target \"Example\", with parameters {\"foo\":\"bar\",\"baz\":\"bat\"}  Now, let's say we extended  Example  as follows:  class SubExample extends Example\n{\n}  One interesting aspect of our  setEventManager()  method is that we defined it\nto listen both on  __CLASS__  and  get_class($this) . This means that calling do()  on our  SubExample  class would also trigger the shared listener! It also\nmeans that, if desired, we could attach to specifically  SubExample , and\nlisteners attached to only the  Example  target would not be triggered.  Finally, the names used as contexts or targets need not be class names; they can\nbe some name that only has meaning in your application if desired. As an\nexample, you could have a set of classes that respond to \"log\" or \"cache\"\n\u2014 and listeners on these would be notified by any of them.",
            "title": "Shared managers"
        },
        {
            "location": "/event-manager/#use-class-names-as-identifiers",
            "text": "We recommend using class names, interface names, and/or abstract class names\nfor identifiers. This makes determining what events are available easier, as\nwell as finding which listeners might be attaching to those events. Interfaces\nmake a particularly good use case, as they allow attaching to a group of\nrelated classes a single operation.   At any point, if you do not want to notify shared listeners, pass a  null  value\nto  setSharedManager() :  $events->setSharedManager(null);  and they will be ignored. If at any point, you want to enable them again, pass\nthe  SharedEventManager  instance:  $events->setSharedManager($sharedEvents);",
            "title": "Use class names as identifiers"
        },
        {
            "location": "/event-manager/#wildcards",
            "text": "So far, with both a normal  EventManager  instance and with the SharedEventManager  instance, we've seen the usage of singular strings\nrepresenting the event and target names to which we want to attach. What if you\nwant to attach a listener to multiple events or targets?  The answer is to supply an array of events or targets, or a wildcard,  * .  Consider the following examples:  // Multiple named events:\n$events->attach(\n    ['foo', 'bar', 'baz'], // events\n    $listener\n);\n\n// All events via wildcard:\n$events->attach(\n    '*', // all events\n    $listener\n);\n\n// Multiple named targets:\n$sharedEvents->attach(\n    ['Foo', 'Bar', 'Baz'], // targets\n    'doSomething', // named event\n    $listener\n);\n\n// All targets via wildcard\n$sharedEvents->attach(\n    '*', // all targets\n    'doSomething', // named event\n    $listener\n);\n\n// Mix and match: multiple named events on multiple named targets:\n$sharedEvents->attach(\n    ['Foo', 'Bar', 'Baz'], // targets\n    ['foo', 'bar', 'baz'], // events\n    $listener\n);\n\n// Mix and match: all events on multiple named targets:\n$sharedEvents->attach(\n    ['Foo', 'Bar', 'Baz'], // targets\n    '*', // events\n    $listener\n);\n\n// Mix and match: multiple named events on all targets:\n$sharedEvents->attach(\n    '*', // targets\n    ['foo', 'bar', 'baz'], // events\n    $listener\n);\n\n// Mix and match: all events on all targets:\n$sharedEvents->attach(\n    '*', // targets\n    '*', // events\n    $listener\n);  The ability to specify multiple targets and/or events when attaching can slim\ndown your code immensely.",
            "title": "Wildcards"
        },
        {
            "location": "/event-manager/#listener-aggregates",
            "text": "Another approach to listening to multiple events is via a concept of listener\naggregates, represented by  Zend\\EventManager\\ListenerAggregateInterface . Via\nthis approach, a single class can listen to multiple events, attaching one or\nmore instance methods as listeners.  This interface defines two methods,  attach(EventManagerInterface $events)  and detach(EventManagerInterface $events) . Basically, you pass an  EventManager \ninstance to one and/or the other, and then it's up to the implementing class to\ndetermine what to do.  As an example:  use Zend\\EventManager\\EventInterface;\nuse Zend\\EventManager\\EventManagerInterface;\nuse Zend\\EventManager\\ListenerAggregateInterface;\nuse Zend\\Log\\Logger;\n\nclass LogEvents implements ListenerAggregateInterface\n{\n    protected $listeners = [];\n    protected $log;\n\n    public function __construct(Logger $log)\n    {\n        $this->log = $log;\n    }\n\n    public function attach(EventManagerInterface $events)\n    {\n        $this->listeners[] = $events->attach('do', [$this, 'log']);\n        $this->listeners[] = $events->attach('doSomethingElse', [$this, 'log']);\n    }\n\n    public function detach(EventCollection $events)\n    {\n        foreach ($this->listeners as $index => $listener) {\n            if ($events->detach($listener)) {\n                unset($this->listeners[$index]);\n            }\n        }\n    }\n\n    public function log(EventInterface $e)\n    {\n        $event  = $e->getName();\n        $params = $e->getParams();\n        $this->log->info(sprintf('%s: %s', $event, json_encode($params)));\n    }\n}  You can attach this using either  attach()  or  attachAggregate() :  $logListener = new LogEvents($logger);\n\n$events->attachAggregate($logListener); // OR\n$events->attach($logListener);  Any events the aggregate attaches to will then be notified when triggered.  Why bother? For a couple of reasons:   Aggregates allow you to have stateful listeners. The above example\n  demonstrates this via the composition of the logger; another example would be\n  tracking configuration options.  Aggregates make detaching listeners easier. When you call  attach() \n  normally, you receive a  Zend\\Stdlib\\CallbackHandler  instance; the only way\n  to  detach()  a listener is to pass that instance back \u2014 which means\n  if you want to detach later, you need to keep that instance somewhere.\n  Aggregates typically do this for you \u2014 as you can see in the example above.",
            "title": "Listener aggregates"
        },
        {
            "location": "/event-manager/#introspecting-results",
            "text": "Sometimes you'll want to know what your listeners returned. One thing to\nremember is that you may have multiple listeners on the same event; the\ninterface for results must be consistent regardless of the number of listeners.  The  EventManager  implementation by default returns a Zend\\EventManager\\ResponseCollection  instance. This class extends PHP's SplStack , allowing you to loop through responses in reverse order (since the\nlast one executed is likely the one you're most interested in). It also\nimplements the following methods:   first()  will retrieve the first result received  last()  will retrieve the last result received  contains($value)  allows you to test all values to see if a given one was\n  received, and returns simply a boolean  true  if found, and  false  if not.   Typically, you should not worry about the return values from events, as the\nobject triggering the event shouldn't really have much insight into what\nlisteners are attached. However, sometimes you may want to short-circuit\nexecution if interesting results are obtained.",
            "title": "Introspecting results"
        },
        {
            "location": "/event-manager/#short-circuiting-listener-execution",
            "text": "You may want to short-ciruit execution if a particular result is obtained, or if\na listener determines that something is wrong, or that it can return something\nquicker than the target.  As examples, one rationale for adding an  EventManager  is as a caching\nmechanism. You can trigger one event early in the method, returning if a cache\nis found, and trigger another event late in the method, seeding the cache.  The  EventManager  component offers two ways to handle this. The first is to\npass a callback as the last argument to  trigger() ; if that callback returns a\nboolean  true , execution is halted.  Here's an example:  public function someExpensiveCall($criteria1, $criteria2)\n{\n    $params  = compact('criteria1', 'criteria2');\n    $results = $this->getEventManager()->trigger(\n        __FUNCTION__, \n        $this, \n        $params, \n        function ($r) {\n            return ($r instanceof SomeResultClass);\n        }\n    );\n    if ($results->stopped()) {\n        return $results->last();\n    }\n\n    // ... do some work ...\n}  With this paradigm, we know that the likely reason of execution halting is due\nto the last result meeting the test callback criteria; as such, we simply return\nthat last result.  The other way to halt execution is within a listener, acting on the  Event \nobject it receives. In this case, the listener calls  stopPropagation(true) ,\nand the  EventManager  will then return without notifying any additional\nlisteners.  $events->attach('do', function ($e) {\n    $e->stopPropagation();\n    return new SomeResultClass();\n});  This, of course, raises some ambiguity when using the trigger paradigm, as you\ncan no longer be certain that the last result meets the criteria it's searching\non. As such, we recommend that you standardize on one approach or the other.",
            "title": "Short-circuiting listener execution"
        },
        {
            "location": "/event-manager/#keeping-it-in-order",
            "text": "On occasion, you may be concerned about the order in which listeners execute. As\nan example, you may want to do any logging early, to ensure that if\nshort-circuiting occurs, you've logged; or if implementing a cache, you may want\nto return early if a cache hit is found, and execute late when saving to a\ncache.  Each of  EventManager::attach()  and  SharedEventManager::attach()  accept one\nadditional argument, a  priority . By default, if this is omitted, listeners get\na priority of 1, and are executed in the order in which they are attached.\nHowever, if you provide a priority value, you can influence order of execution.   Higher priority values execute  earlier .  Lower (negative) priority values execute  later .   To borrow an example from earlier:  $priority = 100;\n$events->attach('Example', 'do', function($e) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget()); // \"Example\"\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\" on target \"%s\", with parameters %s',\n        $event,\n        $target,\n        json_encode($params)\n    );\n}, $priority);  This would execute with high priority, meaning it would execute early. If we\nchanged  $priority  to  -100 , it would execute with low priority, executing\nlate.  While you can't necessarily know all the listeners attached, chances are you can\nmake adequate guesses when necessary in order to set appropriate priority\nvalues. We advise avoiding setting a priority value unless absolutely necessary.",
            "title": "Keeping it in order"
        },
        {
            "location": "/event-manager/#custom-event-objects",
            "text": "Hopefully some of you have been wondering, \"where and when is the Event object\ncreated\"? In all of the examples above, it's created based on the arguments\npassed to  trigger()  \u2014 the event name, target, and parameters. Sometimes,\nhowever, you may want greater control over the object.  As an example, one thing that looks like a code smell is when you have code like\nthis:  $routeMatch = $e->getParam('route-match', false);\nif (! $routeMatch) {\n    // Oh noes! we cannot do our work! whatever shall we do?!?!?!\n}  The problems with this are several. First, relying on string keys is going to\nvery quickly run into problems \u2014 typos when setting or retrieving the\nargument can lead to hard to debug situations. Second, we now have a\ndocumentation issue; how do we document expected arguments? how do we document\nwhat we're shoving into the event? Third, as a side effect, we can't use IDE or\neditor hinting support \u2014 string keys give these tools nothing to work\nwith.  Similarly, consider how you might represent a computational result of a method\nwhen triggering an event. As an example:  // in the method:\n$params['__RESULT'] = $computedResult;\n$events->trigger(__FUNCTION__ . '.post', $this, $params);\n\n// in the listener:\n$result = $e->getParam('__RESULT__');\nif (! $result) {\n    // Oh noes! we cannot do our work! whatever shall we do?!?!?!\n}  Sure, that key may be unique, but it suffers from a lot of the same issues.  So, the solution is to create custom events. As an example, we have a custom MvcEvent  in the ZF2 MVC layer. This event composes the application instance,\nthe router, the route match object, request and response objects, the view\nmodel, and also a result. We end up with code like this in our listeners:  $response = $e->getResponse();\n$result   = $e->getResult();\nif (is_string($result)) {\n    $content = $view->render('layout.phtml', ['content' => $result]);\n    $response->setContent($content);\n}  But how do we use this custom event? Simple:  trigger()  can accept an event\nobject instead of any of the event name, target, or params arguments.  $event = new CustomEvent();\n$event->setSomeKey($value);\n\n// Injected with event name and target:\n$events->trigger('foo', $this, $event);\n\n// Injected with event name:\n$event->setTarget($this);\n$events->trigger('foo', $event);\n\n// Fully encapsulates all necessary properties:\n$event->setName('foo');\n$event->setTarget($this);\n$events->trigger($event);\n\n// Passing a callback following the event object works for \n// short-circuiting, too.\n$results = $events->trigger('foo', $this, $event, $callback);  This is a really powerful technique for domain-specific event systems, and\ndefinitely worth experimenting with.",
            "title": "Custom event objects"
        },
        {
            "location": "/event-manager/#putting-it-together-implementing-a-simple-caching-system",
            "text": "In previous sections, I indicated that short-circuiting is a way to potentially\nimplement a caching solution. Let's create a full example.  First, let's define a method that could use caching. You'll note that in most of\nthe examples, I've used  __FUNCTION__  as the event name; this is a good\npractice, as it makes it simple to create a macro for triggering events, as well\nas helps to keep event names unique (as they're usually within the context of\nthe triggering class). However, in the case of a caching example, this would\nlead to identical events being triggered. As such, I recommend postfixing the\nevent name with semantic names: \"do.pre\", \"do.post\", \"do.error\", etc. I'll use\nthat convention in this example.  Additionally, you'll notice that the  $params  I pass to the event is usually\nthe list of parameters passed to the method. This is because those are often not\nstored in the object, and also to ensure the listeners have the exact same\ncontext as the calling method. But it raises an interesting problem in this\nexample: what name do we give the result of the method? One standard that has\nemerged is the use of  __RESULT__ , as double-underscored variables are\ntypically reserved for the sytem.  Here's what the method will look like:  public function someExpensiveCall($criteria1, $criteria2)\n{\n    $params  = compact('criteria1', 'criteria2');\n    $results = $this->getEventManager()->trigger(\n        __FUNCTION__ . '.pre',\n        $this,\n        $params,\n        function ($r) {\n            return ($r instanceof SomeResultClass);\n        }\n    );\n    if ($results->stopped()) {\n        return $results->last();\n    }\n\n    // ... do some work ...\n\n    $params['__RESULT__'] = $calculatedResult;\n    $this->events()->trigger(__FUNCTION__ . '.post', $this, $params);\n    return $calculatedResult;\n}  Now, to provide some caching listeners. We'll need to attach to each of the\n\"someExpensiveCall.pre\" and \"someExpensiveCall.post\" methods. In the former\ncase, if a cache hit is detected, we return it, and move on. In the latter, we\nstore the value in the cache.  We'll assume  $cache  is defined, and follows the paradigms of  Zend\\Cache .\nWe'll want to return early if a hit is detected, and execute late when saving a\ncache (in case the result is modified by another listener). As such, we'll set\nthe \"someExpensiveCall.pre\" listener to execute with priority  100 , and the\n\"someExpensiveCall.post\" listener to execute with priority  -100 .  $events->attach('someExpensiveCall.pre', function($e) use ($cache) {\n    $params = $e->getParams();\n    $key    = md5(json_encode($params));\n    $hit    = $cache->load($key);\n    return $hit;\n}, 100);\n\n$events->attach('someExpensiveCall.post', function($e) use ($cache) {\n    $params = $e->getParams();\n    $result = $params['__RESULT__'];\n    unset($params['__RESULT__']);\n    $key    = md5(json_encode($params));\n    $cache->save($result, $key);\n}, -100);",
            "title": "Putting it together: Implementing a simple caching system"
        },
        {
            "location": "/event-manager/#listeneraggregates-allow-stateful-listeners",
            "text": "The above could have been done within a  ListenerAggregate , which would have\nallowed keeping the  $cache  instance as a stateful property, instead of\nimporting it into closures.   Another approach would be to move the body of the method to a listener as well,\nwhich would allow using the priority system in order to implement caching. That\nwould look like this:  public function setEventManager(EventManagerInterface $events)\n{\n    $this->events = $events;\n    $events->setIdentifiers([__CLASS__, get_class($this)));\n    $events->attach('someExpensiveCall', [$this, 'doSomeExpensiveCall']);\n}\n\npublic function someExpensiveCall($criteria1, $criteria2)\n{\n    $params  = compact('criteria1', 'criteria2');\n    $results = $this->getEventManager()->trigger(\n        __FUNCTION__,\n        $this,\n        $params,\n        function ($r) {\n            return ($r instanceof SomeResultClass);\n        }\n    );\n    return $results->last();\n}\n\npublic function doSomeExpensiveCall($e)\n{\n    // ... do some work ...\n    $e->setParam('__RESULT__', $calculatedResult);\n    return $calculatedResult;\n}  The listeners would then attach to the \"someExpensiveCall\" event, with the cache\nlookup listener listening at high priority, and the cache storage listener\nlistening at low (negative) priority.  Sure, we could probably simply add caching to the object itself \u2014 but this\napproach allows the same handlers to be attached to multiple events, or to\nattach multiple listeners to the same events (e.g. an argument validator, a\nlogger and a cache manager). The point is that if you design your object with\nevents in mind, you can easily make it more flexible and extensible, without\nrequiring developers to actually extend it \u2014 they can simply attach\nlisteners.",
            "title": "ListenerAggregates allow stateful listeners"
        },
        {
            "location": "/event-manager/#conclusion",
            "text": "The  EventManager  is a powerful component. It drives the workflow of the MVC\nlayer, and is used in countless components to provide hook points for developers\nto manipulate the workflow. It can be put to any number of uses inside your own\ncode, and is an important part of your Zend Framework toolbox.",
            "title": "Conclusion"
        },
        {
            "location": "/i18n/",
            "text": "Internationalization\n\n\nIf you are building a site for an international audience, you will likely want\nto provide localized versions of common strings on your website, including menu\nitems, form labels, button labels, and more. Additionally, some websites require\nthat route path segments be localized.\n\n\nZend Framework provides internationalization (i18n) tools via the\n\nzend-i18n\n component, and\nintegration with zend-mvc via the \nzend-mvc-i18n\n\ncomponent.\n\n\nInstallation\n\n\nInstall zend-mvc-i18n via Composer:\n\n\n$ composer require zendframework/zend-mvc-i18n\n\n\n\n\nAssuming you are using \nzend-component-installer\n\n(which is installed by default with the skeleton application), this will prompt\nyou to install the component as a module in your application; make sure you\nselect either \napplication.config.php\n or \nmodules.config.php\n for the location.\n\n\nOnce installed, this component exposes several services, including:\n\n\n\n\nMvcTranslator\n, which implements the zend-i18n \nTranslatorInterface\n, as well\n  as the version specific to zend-validator, providing an instance that can be\n  used for all application contexts.\n\n\nA \"translator aware\" router.\n\n\n\n\nBy default, until you configure translations, installation has no practical\neffect. So the next step is creating translations to use in your application.\n\n\nCreating translations\n\n\nThe \nzend-i18n Translation chapter\n\ncovers the details of adding translations to your application. You can use PHP\narrays, INI files, or the popular gettext package (which allows you to use\nindustry standard tools such as \npoedit\n to\nedit translations).\n\n\n\n\nOnce you have some translation sources, you will need to put them somewhere your\napplication can access them. Options include:\n\n\n\n\nIn a subdirectory of the module that defines and/or consumes the translation\n  strings. As an example, \nmodule/Application/language/\n.\n\n\nIn your application data directory; e.g., \ndata/language/\n.\n\n\n\n\nMake sure you follow the guidelines from the zend-i18n documentation with\nregards to naming your files. Additionally, you may want to further segregate\nany such directory by text domain.\n\n\nFrom here, you need to configure the translator to use your files. This requires\nadding configuration in either your module or application configuration files\nthat provides:\n\n\n\n\nThe default locale if none is provided.\n\n\nTranslation file patterns, which include:\n\n\nthe translation source type (e.g., \ngettext\n, \nphparray\n, \nini\n)\n\n\nthe base directory in which they are stored\n\n\na file pattern for identifying the files to use\n\n\n\n\nAs examples:\n\n\n// in a module's module.config.php:\n'translator' => [\n    'locale' => 'en_US',\n    'translation_file_patterns' => [\n        [\n            'type'     => 'gettext',\n            'base_dir' => __DIR__ . '/../language',\n            'pattern'  => '%s.mo',\n        ],\n    ],\n],\n\n// or in config/autoload/global.php:\n'translator' => [\n    'locale' => 'en_US',\n    'translation_file_patterns' => [\n        [\n            'type'     => 'gettext',\n            'base_dir' => getcwd() .  '/data/language',\n            'pattern'  => '%s.mo',\n        ],\n    ],\n],\n\n\n\n\nOnce the above configuration is in place, the translator will be active in your\napplication, allowing you to use it.\n\n\nTranslating strings in templates\n\n\nOnce you have defined some strings to translate, and configured the application\nto use them, you can translate them in your application. The \ntranslate()\n\nand \ntranslatePlural()\n\nview helpers allow you to provide translations within your view scripts.\n\n\nAs an example, you might want to translate the string \"All rights reserved\" in\nyour footer. You could do the following in your layout script:\n\n\n<p>&copy; 2016 by Examples Ltd. <?= $this->translate('All rights reserved') ?></p>\n\n\n\n\nTranslating route segments\n\n\nIn order to enable route translation, you need to do two things:\n\n\n\n\nTell the router to use the translation-aware route class.\n\n\nOptionally, tell it which text domain to use (if not using the default text domain).\n\n\n\n\nTo tell the application to use the translation-aware route class, we can update\nour routing configuration. Underneath the top-level \nrouter\n key, we'll add the\n\nrouter_class\n key:\n\n\n// In a module.config.php file, or config/autoload/global.php:\n'router' => [\n    'router_class' => Zend\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack::class,\n    'routes' => [\n        /* ... */\n    ],\n],\n\n\n\n\nIf you want to use an alternate text domain, you can do so via the\n\ntranslator_text_domain\n key, also directly below the \nrouter\n key:\n\n\n// In a module.config.php file, or config/autoload/global.php:\n'router' => [\n    'router_class' => Zend\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack::class,\n    'translator_text_domain' => 'router',\n    'routes' => [\n        /* ... */\n    ],\n],\n\n\n\n\nNow that the router is aware of translations, we can use translatable strings in\nour routes. To do so, surround the string capable of translation with braces\n(\n{}\n). As an example:\n\n\n'route' => '/{login}',\n\n\n\n\nspecifies the word \"login\" as translatable.",
            "title": "Internationalization"
        },
        {
            "location": "/i18n/#internationalization",
            "text": "If you are building a site for an international audience, you will likely want\nto provide localized versions of common strings on your website, including menu\nitems, form labels, button labels, and more. Additionally, some websites require\nthat route path segments be localized.  Zend Framework provides internationalization (i18n) tools via the zend-i18n  component, and\nintegration with zend-mvc via the  zend-mvc-i18n \ncomponent.",
            "title": "Internationalization"
        },
        {
            "location": "/i18n/#installation",
            "text": "Install zend-mvc-i18n via Composer:  $ composer require zendframework/zend-mvc-i18n  Assuming you are using  zend-component-installer \n(which is installed by default with the skeleton application), this will prompt\nyou to install the component as a module in your application; make sure you\nselect either  application.config.php  or  modules.config.php  for the location.  Once installed, this component exposes several services, including:   MvcTranslator , which implements the zend-i18n  TranslatorInterface , as well\n  as the version specific to zend-validator, providing an instance that can be\n  used for all application contexts.  A \"translator aware\" router.   By default, until you configure translations, installation has no practical\neffect. So the next step is creating translations to use in your application.",
            "title": "Installation"
        },
        {
            "location": "/i18n/#creating-translations",
            "text": "The  zend-i18n Translation chapter \ncovers the details of adding translations to your application. You can use PHP\narrays, INI files, or the popular gettext package (which allows you to use\nindustry standard tools such as  poedit  to\nedit translations).   Once you have some translation sources, you will need to put them somewhere your\napplication can access them. Options include:   In a subdirectory of the module that defines and/or consumes the translation\n  strings. As an example,  module/Application/language/ .  In your application data directory; e.g.,  data/language/ .   Make sure you follow the guidelines from the zend-i18n documentation with\nregards to naming your files. Additionally, you may want to further segregate\nany such directory by text domain.  From here, you need to configure the translator to use your files. This requires\nadding configuration in either your module or application configuration files\nthat provides:   The default locale if none is provided.  Translation file patterns, which include:  the translation source type (e.g.,  gettext ,  phparray ,  ini )  the base directory in which they are stored  a file pattern for identifying the files to use   As examples:  // in a module's module.config.php:\n'translator' => [\n    'locale' => 'en_US',\n    'translation_file_patterns' => [\n        [\n            'type'     => 'gettext',\n            'base_dir' => __DIR__ . '/../language',\n            'pattern'  => '%s.mo',\n        ],\n    ],\n],\n\n// or in config/autoload/global.php:\n'translator' => [\n    'locale' => 'en_US',\n    'translation_file_patterns' => [\n        [\n            'type'     => 'gettext',\n            'base_dir' => getcwd() .  '/data/language',\n            'pattern'  => '%s.mo',\n        ],\n    ],\n],  Once the above configuration is in place, the translator will be active in your\napplication, allowing you to use it.",
            "title": "Creating translations"
        },
        {
            "location": "/i18n/#translating-strings-in-templates",
            "text": "Once you have defined some strings to translate, and configured the application\nto use them, you can translate them in your application. The  translate() \nand  translatePlural() \nview helpers allow you to provide translations within your view scripts.  As an example, you might want to translate the string \"All rights reserved\" in\nyour footer. You could do the following in your layout script:  <p>&copy; 2016 by Examples Ltd. <?= $this->translate('All rights reserved') ?></p>",
            "title": "Translating strings in templates"
        },
        {
            "location": "/i18n/#translating-route-segments",
            "text": "In order to enable route translation, you need to do two things:   Tell the router to use the translation-aware route class.  Optionally, tell it which text domain to use (if not using the default text domain).   To tell the application to use the translation-aware route class, we can update\nour routing configuration. Underneath the top-level  router  key, we'll add the router_class  key:  // In a module.config.php file, or config/autoload/global.php:\n'router' => [\n    'router_class' => Zend\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack::class,\n    'routes' => [\n        /* ... */\n    ],\n],  If you want to use an alternate text domain, you can do so via the translator_text_domain  key, also directly below the  router  key:  // In a module.config.php file, or config/autoload/global.php:\n'router' => [\n    'router_class' => Zend\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack::class,\n    'translator_text_domain' => 'router',\n    'routes' => [\n        /* ... */\n    ],\n],  Now that the router is aware of translations, we can use translatable strings in\nour routes. To do so, surround the string capable of translation with braces\n( {} ). As an example:  'route' => '/{login}',  specifies the word \"login\" as translatable.",
            "title": "Translating route segments"
        },
        {
            "location": "/navigation/",
            "text": "Using zend-navigation in your Album Module\n\n\nIn this tutorial we will use the \nzend-navigation component\n\nto add a navigation menu to the black bar at the top of the screen, and add\nbreadcrumbs above the main site content.\n\n\n\n\nTODO\n\n\nUpdate this to follow the changes made in the getting-started guide.\n\n\n\n\nPreparation\n\n\nIn a real world application, the album browser would be only a portion of a\nworking website. Usually the user would land on a homepage first, and be able to\nview albums by using a standard navigation menu. So that we have a site that is\nmore realistic than just the albums feature, lets make the standard skeleton\nwelcome page our homepage, with the /album route still showing our album module.\nIn order to make this change, we need to undo some work we did earlier.\nCurrently, navigating to the root of your app (\n/\n) routes you to the\n\nAlbumController\n's default action. Let's undo this route change so we have two\ndiscrete entry points to the app, a home page, and an albums area.\n\n\n// In module/Application/config/module.config.php:\n'home' => [\n   'type' => 'Zend\\Router\\Http\\Literal',\n    'options' => [\n        'route'    => '/',\n        'defaults' => [\n            'controller' => 'Application\\Controller\\Index', // <-- change back here\n            'action'     => 'index',\n        ],\n    ],\n],\n\n\n\n\nThis change means that if you go to the home page of your application\n(\nhttp://zf2-tutorial.localhost/\n), you see the default skeleton application\nintroduction. Your list of albums is still available at the \n/album\n route.\n\n\nSetting Up zend-navigation\n\n\nFirstly, we need to tell our application which \nNavigationFactory\n to use when\nusing the bundled navigation view helpers. Thankfully, zend-navigation comes with a default\nfactory that will suit our needs just fine; assuming you have used\n\nzend-component-installer\n\nin your skeleton when adding zend-navigation, this will already be enabled.\n\n\nIf not, you will need to add the configuration manually. To do this, create a\nnew file, \nconfig/autoload/navigation.global.php\n with the following contents:\n\n\n<?php\nuse Zend\\Navigation\\ConfigProvider;\n\nreturn [\n    'service_manager' => (new ConfigProvider())->getDependencyConfig(),\n];\n\n\n\n\nConfiguring our Site Map\n\n\nNext up, we need \nZend\\Navigation\n to understand the hierarchy of our site.\nTo do this, we can add a \nnavigation\n key to our configuration, with the site\nstructure details. We'll do that in the \nApplication\n module configuration:\n\n\n// in module/Application/config/module.config.php:\nreturn [\n    /* ... */\n    'navigation' => [\n        'default' => [\n            [\n                'label' => 'Home',\n                'route' => 'home',\n            ],\n            [\n                'label' => 'Album',\n                'route' => 'album',\n                'pages' => [\n                    [\n                        'label' => 'Add',\n                        'route' => 'album',\n                        'action' => 'add',\n                    ],\n                    [\n                        'label' => 'Edit',\n                        'route' => 'album',\n                        'action' => 'edit',\n                    ],\n                    [\n                        'label' => 'Delete',\n                        'route' => 'album',\n                        'action' => 'delete',\n                    ],\n                ],\n            ],\n        ],\n    ],\n    /* ... */\n];\n\n\n\n\nThis configuration maps out the pages we've defined in our controller, with\nlabels linking to the given route names. You can define highly complex\nhierarchical sites here with pages and sub-pages linking to route names,\ncontroller/action pairs or external uris. For more information, see the\n\nzend-navigation quick start\n.\n\n\nAdding the Menu View Helper\n\n\nNow that we have the navigation helper configured by our service manager and\nmerged config, we can add the menu to the title bar to our layout by\nusing the \nmenu view helper\n:\n\n\n<?php // in module/Application/view/layout/layout.phtml: ?>\n<div class=\"collapse navbar-collapse\">\n    <?php // add this: ?>\n    <?= $this->navigation('navigation')->menu() ?>\n</div>\n\n\n\n\nThe navigation helper is provided by default with zend-view, and uses the service\nmanager configuration we've already defined to configure itself automatically.\nRefreshing your application, you will see a working menu; with just a few tweaks\nhowever, we can make it look even better:\n\n\n<?php // in module/Application/view/layout/layout.phtml: ?>\n<div class=\"collapse navbar-collapse\">\n    <?php // update to: ?>\n    <?= $this->navigation('navigation')\n        ->menu()\n        ->setMinDepth(0)\n        ->setMaxDepth(0)\n        ->setUlClass('nav navbar-nav') ?>\n</div>\n\n\n\n\nHere we tell the renderer to give the root \n<ul>\n the class of \nnav\n (so that\nBootstrap styles the menu correctly), and only render the first level of any\ngiven page. If you view your application in your browser, you will now see a\nnicely styled menu appear in the title bar.\n\n\nThe great thing about zend-navigation is that it integrates with zend-router in\norder to highlight the currently viewed page. Because of this, it sets the\nactive page to have a class of \nactive\n in the menu; Bootstrap uses this to\nhighlight your current page accordingly.\n\n\nAdding Breadcrumbs\n\n\nAdding breadcrumbs follows the same process. In our \nlayout.phtml\n we want to\nadd breadcrumbs above the main content pane, so our users know exactly\nwhere they are in our website. Inside the container div, before we\noutput the content from the view, let's add a breadcrumb by using the\n\nbreadcrumbs view helper\n.\n\n\n<?php // module/Application/view/layout/layout.phtml: ?>\n<div class=\"container\">\n    <?php // add the following line: ?>\n    <?= $this->navigation('navigation')->breadcrumbs()->setMinDepth(0) ?>\n    <?= $this->content ?>\n</div>\n\n\n\n\nThis adds a simple but functional breadcrumb to every page (we tell it to render\nfrom a depth of 0 so we see all page levels), but we can do better than that!\nBecause Bootstrap has a styled breadcrumb as part of its base CSS, let's add\na partial that outputs the \n<ul>\n using Bootstrap styles. We'll create it in the\n\nview\n directory of the \nApplication\n module (this partial is application wide,\nrather than album specific):\n\n\n<?php // in module/Application/view/partial/breadcrumb.phtml: ?>\n<ul class=\"breadcrumb\">\n    <?php\n    // iterate through the pages\n    foreach ($this->pages as $key => $page):\n    ?>\n        <li>\n            <?php\n            // if this isn't the last page, add a link and the separator:\n            if ($key < count($this->pages) - 1):\n            ?>\n                <a href=\"<?= $page->getHref(); ?>\"><?= $page->getLabel(); ?></a>\n            <?php\n            // otherwise, output the name only:\n            else:\n            ?>\n                <?= $page->getLabel(); ?>\n            <?php endif; ?>\n        </li>\n    <?php endforeach; ?>\n</ul>\n\n\n\n\nNotice how the partial is passed a \nZend\\View\\Model\\ViewModel\n instance with the\n\npages\n property set to an array of pages to render.\n\n\nNow we need to tell the breadcrumb helper to use the partial we have just\nwritten:\n\n\n<?php // in module/Application/view/layout/layout.phtml: ?>\n<div class=\"container\">\n    <?php // Update to: ?>\n    <?= $this->navigation('navigation')\n            ->breadcrumbs()\n            ->setMinDepth(0)\n            ->setPartial('partial/breadcrumb.phtml') ?>\n    <?= $this->content ?>\n</div>\n\n\n\n\nRefreshing the page now gives us a styled set of breadcrumbs on each page.",
            "title": "Adding zend-navigation to the Album Module"
        },
        {
            "location": "/navigation/#using-zend-navigation-in-your-album-module",
            "text": "In this tutorial we will use the  zend-navigation component \nto add a navigation menu to the black bar at the top of the screen, and add\nbreadcrumbs above the main site content.",
            "title": "Using zend-navigation in your Album Module"
        },
        {
            "location": "/navigation/#todo",
            "text": "Update this to follow the changes made in the getting-started guide.",
            "title": "TODO"
        },
        {
            "location": "/navigation/#preparation",
            "text": "In a real world application, the album browser would be only a portion of a\nworking website. Usually the user would land on a homepage first, and be able to\nview albums by using a standard navigation menu. So that we have a site that is\nmore realistic than just the albums feature, lets make the standard skeleton\nwelcome page our homepage, with the /album route still showing our album module.\nIn order to make this change, we need to undo some work we did earlier.\nCurrently, navigating to the root of your app ( / ) routes you to the AlbumController 's default action. Let's undo this route change so we have two\ndiscrete entry points to the app, a home page, and an albums area.  // In module/Application/config/module.config.php:\n'home' => [\n   'type' => 'Zend\\Router\\Http\\Literal',\n    'options' => [\n        'route'    => '/',\n        'defaults' => [\n            'controller' => 'Application\\Controller\\Index', // <-- change back here\n            'action'     => 'index',\n        ],\n    ],\n],  This change means that if you go to the home page of your application\n( http://zf2-tutorial.localhost/ ), you see the default skeleton application\nintroduction. Your list of albums is still available at the  /album  route.",
            "title": "Preparation"
        },
        {
            "location": "/navigation/#setting-up-zend-navigation",
            "text": "Firstly, we need to tell our application which  NavigationFactory  to use when\nusing the bundled navigation view helpers. Thankfully, zend-navigation comes with a default\nfactory that will suit our needs just fine; assuming you have used zend-component-installer \nin your skeleton when adding zend-navigation, this will already be enabled.  If not, you will need to add the configuration manually. To do this, create a\nnew file,  config/autoload/navigation.global.php  with the following contents:  <?php\nuse Zend\\Navigation\\ConfigProvider;\n\nreturn [\n    'service_manager' => (new ConfigProvider())->getDependencyConfig(),\n];",
            "title": "Setting Up zend-navigation"
        },
        {
            "location": "/navigation/#configuring-our-site-map",
            "text": "Next up, we need  Zend\\Navigation  to understand the hierarchy of our site.\nTo do this, we can add a  navigation  key to our configuration, with the site\nstructure details. We'll do that in the  Application  module configuration:  // in module/Application/config/module.config.php:\nreturn [\n    /* ... */\n    'navigation' => [\n        'default' => [\n            [\n                'label' => 'Home',\n                'route' => 'home',\n            ],\n            [\n                'label' => 'Album',\n                'route' => 'album',\n                'pages' => [\n                    [\n                        'label' => 'Add',\n                        'route' => 'album',\n                        'action' => 'add',\n                    ],\n                    [\n                        'label' => 'Edit',\n                        'route' => 'album',\n                        'action' => 'edit',\n                    ],\n                    [\n                        'label' => 'Delete',\n                        'route' => 'album',\n                        'action' => 'delete',\n                    ],\n                ],\n            ],\n        ],\n    ],\n    /* ... */\n];  This configuration maps out the pages we've defined in our controller, with\nlabels linking to the given route names. You can define highly complex\nhierarchical sites here with pages and sub-pages linking to route names,\ncontroller/action pairs or external uris. For more information, see the zend-navigation quick start .",
            "title": "Configuring our Site Map"
        },
        {
            "location": "/navigation/#adding-the-menu-view-helper",
            "text": "Now that we have the navigation helper configured by our service manager and\nmerged config, we can add the menu to the title bar to our layout by\nusing the  menu view helper :  <?php // in module/Application/view/layout/layout.phtml: ?>\n<div class=\"collapse navbar-collapse\">\n    <?php // add this: ?>\n    <?= $this->navigation('navigation')->menu() ?>\n</div>  The navigation helper is provided by default with zend-view, and uses the service\nmanager configuration we've already defined to configure itself automatically.\nRefreshing your application, you will see a working menu; with just a few tweaks\nhowever, we can make it look even better:  <?php // in module/Application/view/layout/layout.phtml: ?>\n<div class=\"collapse navbar-collapse\">\n    <?php // update to: ?>\n    <?= $this->navigation('navigation')\n        ->menu()\n        ->setMinDepth(0)\n        ->setMaxDepth(0)\n        ->setUlClass('nav navbar-nav') ?>\n</div>  Here we tell the renderer to give the root  <ul>  the class of  nav  (so that\nBootstrap styles the menu correctly), and only render the first level of any\ngiven page. If you view your application in your browser, you will now see a\nnicely styled menu appear in the title bar.  The great thing about zend-navigation is that it integrates with zend-router in\norder to highlight the currently viewed page. Because of this, it sets the\nactive page to have a class of  active  in the menu; Bootstrap uses this to\nhighlight your current page accordingly.",
            "title": "Adding the Menu View Helper"
        },
        {
            "location": "/navigation/#adding-breadcrumbs",
            "text": "Adding breadcrumbs follows the same process. In our  layout.phtml  we want to\nadd breadcrumbs above the main content pane, so our users know exactly\nwhere they are in our website. Inside the container div, before we\noutput the content from the view, let's add a breadcrumb by using the breadcrumbs view helper .  <?php // module/Application/view/layout/layout.phtml: ?>\n<div class=\"container\">\n    <?php // add the following line: ?>\n    <?= $this->navigation('navigation')->breadcrumbs()->setMinDepth(0) ?>\n    <?= $this->content ?>\n</div>  This adds a simple but functional breadcrumb to every page (we tell it to render\nfrom a depth of 0 so we see all page levels), but we can do better than that!\nBecause Bootstrap has a styled breadcrumb as part of its base CSS, let's add\na partial that outputs the  <ul>  using Bootstrap styles. We'll create it in the view  directory of the  Application  module (this partial is application wide,\nrather than album specific):  <?php // in module/Application/view/partial/breadcrumb.phtml: ?>\n<ul class=\"breadcrumb\">\n    <?php\n    // iterate through the pages\n    foreach ($this->pages as $key => $page):\n    ?>\n        <li>\n            <?php\n            // if this isn't the last page, add a link and the separator:\n            if ($key < count($this->pages) - 1):\n            ?>\n                <a href=\"<?= $page->getHref(); ?>\"><?= $page->getLabel(); ?></a>\n            <?php\n            // otherwise, output the name only:\n            else:\n            ?>\n                <?= $page->getLabel(); ?>\n            <?php endif; ?>\n        </li>\n    <?php endforeach; ?>\n</ul>  Notice how the partial is passed a  Zend\\View\\Model\\ViewModel  instance with the pages  property set to an array of pages to render.  Now we need to tell the breadcrumb helper to use the partial we have just\nwritten:  <?php // in module/Application/view/layout/layout.phtml: ?>\n<div class=\"container\">\n    <?php // Update to: ?>\n    <?= $this->navigation('navigation')\n            ->breadcrumbs()\n            ->setMinDepth(0)\n            ->setPartial('partial/breadcrumb.phtml') ?>\n    <?= $this->content ?>\n</div>  Refreshing the page now gives us a styled set of breadcrumbs on each page.",
            "title": "Adding Breadcrumbs"
        },
        {
            "location": "/pagination/",
            "text": "Using zend-paginator in your Album Module\n\n\n\n\nTODO\n\n\nUpdate to:\n\n\n\n\nfollow the changes in the user-guide\n\n\nuse SQLite-compatible SQL syntax, and provide a script for inserting the data\n\n\n\n\n\n\nIn this tutorial we will use the \nzend-paginator component\n\nto add a handy pagination controller to the bottom of the album list.\n\n\nCurrently, we only have a handful of albums to display, so showing everything on\none page is not a problem. However, how will the album list look when we have\n100 albums or more in our database? The standard solution to this problem is to\nsplit the data up into a number of pages, and allow the user to navigate around\nthese pages using a pagination control. Just type \"Zend Framework\" into Google,\nand you can see their pagination control at the bottom of the page:\n\n\n\n\nPreparation\n\n\nIn order for us to have lots of albums in our database, you'll need to run the\nfollowing SQL insert statement to insert the current 150 top iTunes albums (at\nthe time of writing!):\n\n\nINSERT INTO `album` (`artist`, `title`)\nVALUES\n    ('David Bowie', 'The Next Day (Deluxe Version)'),\n    ('Bastille', 'Bad Blood'),\n    ('Bruno Mars', 'Unorthodox Jukebox'),\n    ('Emeli Sand\u00e9', 'Our Version of Events (Special Edition)'),\n    ('Bon Jovi', 'What About Now (Deluxe Version)'),\n    ('Justin Timberlake', 'The 20/20 Experience (Deluxe Version)'),\n    ('Bastille', 'Bad Blood (The Extended Cut)'),\n    ('P!nk', 'The Truth About Love'),\n    ('Sound City - Real to Reel', 'Sound City - Real to Reel'),\n    ('Jake Bugg', 'Jake Bugg'),\n    ('Various Artists', 'The Trevor Nelson Collection'),\n    ('David Bowie', 'The Next Day'),\n    ('Mumford & Sons', 'Babel'),\n    ('The Lumineers', 'The Lumineers'),\n    ('Various Artists', 'Get Ur Freak On - R&B Anthems'),\n    ('The 1975', 'Music For Cars EP'),\n    ('Various Artists', 'Saturday Night Club Classics - Ministry of Sound'),\n    ('Hurts', 'Exile (Deluxe)'),\n    ('Various Artists', 'Mixmag - The Greatest Dance Tracks of All Time'),\n    ('Ben Howard', 'Every Kingdom'),\n    ('Stereophonics', 'Graffiti On the Train'),\n    ('The Script', '#3'),\n    ('Stornoway', 'Tales from Terra Firma'),\n    ('David Bowie', 'Hunky Dory (Remastered)'),\n    ('Worship Central', 'Let It Be Known (Live)'),\n    ('Ellie Goulding', 'Halcyon'),\n    ('Various Artists', 'Dermot O\\'Leary Presents the Saturday Sessions 2013'),\n    ('Stereophonics', 'Graffiti On the Train (Deluxe Version)'),\n    ('Dido', 'Girl Who Got Away (Deluxe)'),\n    ('Hurts', 'Exile'),\n    ('Bruno Mars', 'Doo-Wops & Hooligans'),\n    ('Calvin Harris', '18 Months'),\n    ('Olly Murs', 'Right Place Right Time'),\n    ('Alt-J (?)', 'An Awesome Wave'),\n    ('One Direction', 'Take Me Home'),\n    ('Various Artists', 'Pop Stars'),\n    ('Various Artists', 'Now That\\'s What I Call Music! 83'),\n    ('John Grant', 'Pale Green Ghosts'),\n    ('Paloma Faith', 'Fall to Grace'),\n    ('Laura Mvula', 'Sing To the Moon (Deluxe)'),\n    ('Duke Dumont', 'Need U (100%) [feat. A*M*E] - EP'),\n    ('Watsky', 'Cardboard Castles'),\n    ('Blondie', 'Blondie: Greatest Hits'),\n    ('Foals', 'Holy Fire'),\n    ('Maroon 5', 'Overexposed'),\n    ('Bastille', 'Pompeii (Remixes) - EP'),\n    ('Imagine Dragons', 'Hear Me - EP'),\n    ('Various Artists', '100 Hits: 80s Classics'),\n    ('Various Artists', 'Les Mis\u00e9rables (Highlights From the Motion Picture Soundtrack)'),\n    ('Mumford & Sons', 'Sigh No More'),\n    ('Frank Ocean', 'Channel ORANGE'),\n    ('Bon Jovi', 'What About Now'),\n    ('Various Artists', 'BRIT Awards 2013'),\n    ('Taylor Swift', 'Red'),\n    ('Fleetwood Mac', 'Fleetwood Mac: Greatest Hits'),\n    ('David Guetta', 'Nothing But the Beat Ultimate'),\n    ('Various Artists', 'Clubbers Guide 2013 (Mixed By Danny Howard) - Ministry of Sound'),\n    ('David Bowie', 'Best of Bowie'),\n    ('Laura Mvula', 'Sing To the Moon'),\n    ('ADELE', '21'),\n    ('Of Monsters and Men', 'My Head Is an Animal'),\n    ('Rihanna', 'Unapologetic'),\n    ('Various Artists', 'BBC Radio 1\\'s Live Lounge - 2012'),\n    ('Avicii & Nicky Romero', 'I Could Be the One (Avicii vs. Nicky Romero)'),\n    ('The Streets', 'A Grand Don\\'t Come for Free'),\n    ('Tim McGraw', 'Two Lanes of Freedom'),\n    ('Foo Fighters', 'Foo Fighters: Greatest Hits'),\n    ('Various Artists', 'Now That\\'s What I Call Running!'),\n    ('Swedish House Mafia', 'Until Now'),\n    ('The xx', 'Coexist'),\n    ('Five', 'Five: Greatest Hits'),\n    ('Jimi Hendrix', 'People, Hell & Angels'),\n    ('Biffy Clyro', 'Opposites (Deluxe)'),\n    ('The Smiths', 'The Sound of the Smiths'),\n    ('The Saturdays', 'What About Us - EP'),\n    ('Fleetwood Mac', 'Rumours'),\n    ('Various Artists', 'The Big Reunion'),\n    ('Various Artists', 'Anthems 90s - Ministry of Sound'),\n    ('The Vaccines', 'Come of Age'),\n    ('Nicole Scherzinger', 'Boomerang (Remixes) - EP'),\n    ('Bob Marley', 'Legend (Bonus Track Version)'),\n    ('Josh Groban', 'All That Echoes'),\n    ('Blue', 'Best of Blue'),\n    ('Ed Sheeran', '+'),\n    ('Olly Murs', 'In Case You Didn\\'t Know (Deluxe Edition)'),\n    ('Macklemore & Ryan Lewis', 'The Heist (Deluxe Edition)'),\n    ('Various Artists', 'Defected Presents Most Rated Miami 2013'),\n    ('Gorgon City', 'Real EP'),\n    ('Mumford & Sons', 'Babel (Deluxe Version)'),\n    ('Various Artists', 'The Music of Nashville: Season 1, Vol. 1 (Original Soundtrack)'),\n    ('Various Artists', 'The Twilight Saga: Breaking Dawn, Pt. 2 (Original Motion Picture Soundtrack)'),\n    ('Various Artists', 'Mum - The Ultimate Mothers Day Collection'),\n    ('One Direction', 'Up All Night'),\n    ('Bon Jovi', 'Bon Jovi Greatest Hits'),\n    ('Agnetha F\u00e4ltskog', 'A'),\n    ('Fun.', 'Some Nights'),\n    ('Justin Bieber', 'Believe Acoustic'),\n    ('Atoms for Peace', 'Amok'),\n    ('Justin Timberlake', 'Justified'),\n    ('Passenger', 'All the Little Lights'),\n    ('Kodaline', 'The High Hopes EP'),\n    ('Lana Del Rey', 'Born to Die'),\n    ('JAY Z & Kanye West', 'Watch the Throne (Deluxe Version)'),\n    ('Biffy Clyro', 'Opposites'),\n    ('Various Artists', 'Return of the 90s'),\n    ('Gabrielle Aplin', 'Please Don\\'t Say You Love Me - EP'),\n    ('Various Artists', '100 Hits - Driving Rock'),\n    ('Jimi Hendrix', 'Experience Hendrix - The Best of Jimi Hendrix'),\n    ('Various Artists', 'The Workout Mix 2013'),\n    ('The 1975', 'Sex'),\n    ('Chase & Status', 'No More Idols'),\n    ('Rihanna', 'Unapologetic (Deluxe Version)'),\n    ('The Killers', 'Battle Born'),\n    ('Olly Murs', 'Right Place Right Time (Deluxe Edition)'),\n    ('A$AP Rocky', 'LONG.LIVE.A$AP (Deluxe Version)'),\n    ('Various Artists', 'Cooking Songs'),\n    ('Haim', 'Forever - EP'),\n    ('Lianne La Havas', 'Is Your Love Big Enough?'),\n    ('Michael Bubl\u00e9', 'To Be Loved'),\n    ('Daughter', 'If You Leave'),\n    ('The xx', 'xx'),\n    ('Eminem', 'Curtain Call'),\n    ('Kendrick Lamar', 'good kid, m.A.A.d city (Deluxe)'),\n    ('Disclosure', 'The Face - EP'),\n    ('Palma Violets', '180'),\n    ('Cody Simpson', 'Paradise'),\n    ('Ed Sheeran', '+ (Deluxe Version)'),\n    ('Michael Bubl\u00e9', 'Crazy Love (Hollywood Edition)'),\n    ('Bon Jovi', 'Bon Jovi Greatest Hits - The Ultimate Collection'),\n    ('Rita Ora', 'Ora'),\n    ('g33k', 'Spabby'),\n    ('Various Artists', 'Annie Mac Presents 2012'),\n    ('David Bowie', 'The Platinum Collection'),\n    ('Bridgit Mendler', 'Ready or Not (Remixes) - EP'),\n    ('Dido', 'Girl Who Got Away'),\n    ('Various Artists', 'Now That\\'s What I Call Disney'),\n    ('The 1975', 'Facedown - EP'),\n    ('Kodaline', 'The Kodaline - EP'),\n    ('Various Artists', '100 Hits: Super 70s'),\n    ('Fred V & Grafix', 'Goggles - EP'),\n    ('Biffy Clyro', 'Only Revolutions (Deluxe Version)'),\n    ('Train', 'California 37'),\n    ('Ben Howard', 'Every Kingdom (Deluxe Edition)'),\n    ('Various Artists', 'Motown Anthems'),\n    ('Courteeners', 'ANNA'),\n    ('Johnny Marr', 'The Messenger'),\n    ('Rodriguez', 'Searching for Sugar Man'),\n    ('Jessie Ware', 'Devotion'),\n    ('Bruno Mars', 'Unorthodox Jukebox'),\n    ('Various Artists', 'Call the Midwife (Music From the TV Series)'\n);\n\n\n\n\nThis gives us a handy extra 150 rows to play with. If you now visit your album\nlist at \n/album\n, you'll see a huge long list of 150+ albums; it's ugly.\n\n\nModifying the AlbumTable\n\n\nIn order to let zend-paginator handle our database queries automatically for us,\nwe will be using the \nDbSelect paginator adapter\n\nThis will automatically manipulate and run a \nZend\\Db\\Sql\\Select\n object to\ninclude the correct \nLIMIT\n and \nWHERE\n clauses so that it returns only the\nconfigured amount of data for the given page. Let's modify the \nfetchAll\n method\nof the \nAlbumTable\n model, so that it can optionally return a paginator object:\n\n\n// in module/Album/src/Album/Model/AlbumTable.php:\nnamespace Album\\Model;\n\nuse Zend\\Db\\ResultSet\\ResultSet;\nuse Zend\\Db\\TableGateway\\TableGateway;\nuse Zend\\Db\\Sql\\Select;\nuse Zend\\Paginator\\Adapter\\DbSelect;\nuse Zend\\Paginator\\Paginator;\n\nclass AlbumTable\n{\n    /* ... */\n\n    public function fetchAll($paginated = false)\n    {\n        if ($paginated) {\n            return $this->fetchPaginatedResults();\n        }\n        $resultSet = $this->tableGateway->select();\n        return $resultSet;\n    }\n\n    private function fetchPaginatedResults()\n    {\n        // Create a new Select object for the table album:\n        $select = new Select('album');\n\n        // Create a new result set based on the Album entity:\n        $resultSetPrototype = new ResultSet();\n        $resultSetPrototype->setArrayObjectPrototype(new Album());\n\n        // Create a new pagination adapter object:\n        $paginatorAdapter = new DbSelect(\n            // our configured select object:\n            $select,\n            // the adapter to run it against:\n            $this->tableGateway->getAdapter(),\n            // the result set to hydrate:\n            $resultSetPrototype\n        );\n\n        $paginator = new Paginator($paginatorAdapter);\n        return $paginator;\n    }\n\n    /* ... */\n}\n\n\n\n\nThis will return a fully configured \nPaginator\n instance. We've already told the\n\nDbSelect\n adapter to use our created \nSelect\n object, to use the adapter that\nthe \nTableGateway\n object uses, and also how to hydrate the result into a\n\nAlbum\n entity in the same fashion as the \nTableGateway\n does. This means that\nour executed and returned paginator results will return \nAlbum\n objects in\nexactly the same fashion as the non-paginated results.\n\n\nModifying the AlbumController\n\n\nNext, we need to tell the album controller to return a \nPagination\n object\ninstead of a \nResultSet\n. Both these objects can by iterated over to return\nhydrated \nAlbum\n objects, so we won't need to make many changes to the view\nscript:\n\n\n// in module/Album/src/Album/Controller/AlbumController.php:\n\n/* ... */\n\npublic function indexAction()\n{\n    // Grab the paginator from the AlbumTable:\n    $paginator = $this->getAlbumTable()->fetchAll(true);\n\n    // Set the current page to what has been passed in query string,\n    // or to 1 if none set:\n    $paginator->setCurrentPageNumber(\n        (int) $this->params()->fromQuery('page', 1)\n    );\n\n    // Set the number of items per page to 10:\n    $paginator->setItemCountPerPage(10);\n\n    return new ViewModel([\n        'paginator' => $paginator\n    ]);\n}\n\n/* ... */\n\n\n\n\nHere we are getting the configured \nPaginator\n object from the \nAlbumTable\n, and\nthen telling it to use the page that is optionally passed in the querystring\n\npage\n parameter. We are also telling the paginator we want to display 10\nobjects per page.\n\n\nUpdating the View Script\n\n\nNow, let's just tell the view script to iterate over the \npagination\n view\nvariable, rather than the \nalbums\n variable:\n\n\n<?php // in module/Album/view/album/album/index.phtml: ?>\n<table class=\"table\">\n    <tr>\n        <th>Title</th>\n        <th>Artist</th>\n        <th>&nbsp;</th>\n    </tr>\n    <?php foreach ($this->paginator as $album) : // <-- change here! ?>\n        <tr>\n            <td><?= $this->escapeHtml($album->title) ?></td>\n            <td><?= $this->escapeHtml($album->artist) ?></td>\n            <td>\n                <a href=\"<?= $this->url('album', ['action' => 'edit', 'id' => $album->id)] ?>\">Edit</a>\n                <a href=\"<?= $this->url('album', ['action' => 'delete', 'id' => $album->id]) ?>\">Delete</a>\n            </td>\n        </tr>\n    <?php endforeach; ?>\n</table>\n\n\n\n\nChecking the \n/album\n route on your website should now give you a list of just\n10 albums, but with no method to navigate through the pages. Let's correct that\nnow.\n\n\nCreating the Pagination Control Partial\n\n\nMuch like we created a custom breadcrumbs partial to render our breadcrumb in\nthe \nnavigation tutorial\n, we need to create a\ncustom pagination control partial to render our pagination control just the way\nwe want it. Again, because we are using Bootstrap, this will primarily involve\noutputting correctly formatted html. Let's create the partial in the\n\nmodule/Application/view/partial/\n folder, so that we can use the control in all\nour modules:\n\n\n<?php // in module/Application/view/partial/paginator.phtml: ?>\n<?php if ($this->pageCount): ?>\n    <div>\n        <ul class=\"pagination\">\n            <!-- Previous page link -->\n            <?php if (isset($this->previous)): ?>\n                <li>\n                    <a href=\"<?= $this->url($this->route, [], ['query' => ['page' => $this->previous]]) ?>\">\n                        <<\n                    </a>\n                </li>\n            <?php else: ?>\n                <li class=\"disabled\">\n                    <a href=\"#\">\n                        <<\n                    </a>\n                </li>\n            <?php endif; ?>\n\n            <!-- Numbered page links -->\n            <?php foreach ($this->pagesInRange as $page): ?>\n                <?php if ($page !== $this->current): ?>\n                    <li>\n                        <a href=\"<?= $this->url($this->route, [], ['query' => ['page' => $page]]) ?>\">\n                            <?= $page; ?>\n                        </a>\n                    </li>\n                <?php else: ?>\n                    <li class=\"active\">\n                        <a href=\"#\"><?= $page; ?></a>\n                    </li>\n                <?php endif; ?>\n            <?php endforeach; ?>\n\n            <!-- Next page link -->\n            <?php if (isset($this->next)): ?>\n                <li>\n                    <a href=\"<?= $this->url($this->route, [], ['query' => ['page' => $this->next]]) ?>\">\n                        >>\n                    </a>\n                </li>\n            <?php else: ?>\n                <li class=\"disabled\">\n                    <a href=\"#\">\n                        >>\n                    </a>\n                </li>\n            <?php endif; ?>\n        </ul>\n    </div>\n<?php endif; ?>\n\n\n\n\nThis partial creates a pagination control with links to the correct pages (if\nthere is more than one page in the pagination object). It will render a previous\npage link (and mark it disabled if you are at the first page), then render a\nlist of intermediate pages (that are passed to the partial based on the\nrendering style; we'll set in the view helper in the next step).  Finally, it\nwill create a next page link (and disable it if you're at the end).  Notice how\nwe pass the page number via the \npage\n querystring parameter which we have\nalready told our controller to use to display the current page.\n\n\nUsing the PaginationControl View Helper\n\n\nTo page through the albums, we need to invoke the\n\npaginationControl view helper\n\nto display our pagination control:\n\n\n<?php\n// In module/Album/view/album/album/index.phtml.\n// Add at the end of the file after the table:\necho $this->paginationControl(\n    // The paginator object:\n    $this->paginator,\n    // The scrolling style:\n    'sliding',\n    // The partial to use to render the control:\n    'partial/paginator.phtml',\n    // The route to link to when a user clicks a control link:\n    [ 'route' => 'album' ]\n);\n?>\n\n\n\n\nThe above echoes the \npaginationControl\n helper, and tells it to use our\npaginator instance, the \nsliding scrolling style\n,\nour paginator partial, and which route to use for generating links. Refreshing\nyour application now should give you Bootstrap-styled pagination controls!",
            "title": "Adding zend-paginator to the Album Module"
        },
        {
            "location": "/pagination/#using-zend-paginator-in-your-album-module",
            "text": "",
            "title": "Using zend-paginator in your Album Module"
        },
        {
            "location": "/pagination/#todo",
            "text": "Update to:   follow the changes in the user-guide  use SQLite-compatible SQL syntax, and provide a script for inserting the data    In this tutorial we will use the  zend-paginator component \nto add a handy pagination controller to the bottom of the album list.  Currently, we only have a handful of albums to display, so showing everything on\none page is not a problem. However, how will the album list look when we have\n100 albums or more in our database? The standard solution to this problem is to\nsplit the data up into a number of pages, and allow the user to navigate around\nthese pages using a pagination control. Just type \"Zend Framework\" into Google,\nand you can see their pagination control at the bottom of the page:",
            "title": "TODO"
        },
        {
            "location": "/pagination/#preparation",
            "text": "In order for us to have lots of albums in our database, you'll need to run the\nfollowing SQL insert statement to insert the current 150 top iTunes albums (at\nthe time of writing!):  INSERT INTO `album` (`artist`, `title`)\nVALUES\n    ('David Bowie', 'The Next Day (Deluxe Version)'),\n    ('Bastille', 'Bad Blood'),\n    ('Bruno Mars', 'Unorthodox Jukebox'),\n    ('Emeli Sand\u00e9', 'Our Version of Events (Special Edition)'),\n    ('Bon Jovi', 'What About Now (Deluxe Version)'),\n    ('Justin Timberlake', 'The 20/20 Experience (Deluxe Version)'),\n    ('Bastille', 'Bad Blood (The Extended Cut)'),\n    ('P!nk', 'The Truth About Love'),\n    ('Sound City - Real to Reel', 'Sound City - Real to Reel'),\n    ('Jake Bugg', 'Jake Bugg'),\n    ('Various Artists', 'The Trevor Nelson Collection'),\n    ('David Bowie', 'The Next Day'),\n    ('Mumford & Sons', 'Babel'),\n    ('The Lumineers', 'The Lumineers'),\n    ('Various Artists', 'Get Ur Freak On - R&B Anthems'),\n    ('The 1975', 'Music For Cars EP'),\n    ('Various Artists', 'Saturday Night Club Classics - Ministry of Sound'),\n    ('Hurts', 'Exile (Deluxe)'),\n    ('Various Artists', 'Mixmag - The Greatest Dance Tracks of All Time'),\n    ('Ben Howard', 'Every Kingdom'),\n    ('Stereophonics', 'Graffiti On the Train'),\n    ('The Script', '#3'),\n    ('Stornoway', 'Tales from Terra Firma'),\n    ('David Bowie', 'Hunky Dory (Remastered)'),\n    ('Worship Central', 'Let It Be Known (Live)'),\n    ('Ellie Goulding', 'Halcyon'),\n    ('Various Artists', 'Dermot O\\'Leary Presents the Saturday Sessions 2013'),\n    ('Stereophonics', 'Graffiti On the Train (Deluxe Version)'),\n    ('Dido', 'Girl Who Got Away (Deluxe)'),\n    ('Hurts', 'Exile'),\n    ('Bruno Mars', 'Doo-Wops & Hooligans'),\n    ('Calvin Harris', '18 Months'),\n    ('Olly Murs', 'Right Place Right Time'),\n    ('Alt-J (?)', 'An Awesome Wave'),\n    ('One Direction', 'Take Me Home'),\n    ('Various Artists', 'Pop Stars'),\n    ('Various Artists', 'Now That\\'s What I Call Music! 83'),\n    ('John Grant', 'Pale Green Ghosts'),\n    ('Paloma Faith', 'Fall to Grace'),\n    ('Laura Mvula', 'Sing To the Moon (Deluxe)'),\n    ('Duke Dumont', 'Need U (100%) [feat. A*M*E] - EP'),\n    ('Watsky', 'Cardboard Castles'),\n    ('Blondie', 'Blondie: Greatest Hits'),\n    ('Foals', 'Holy Fire'),\n    ('Maroon 5', 'Overexposed'),\n    ('Bastille', 'Pompeii (Remixes) - EP'),\n    ('Imagine Dragons', 'Hear Me - EP'),\n    ('Various Artists', '100 Hits: 80s Classics'),\n    ('Various Artists', 'Les Mis\u00e9rables (Highlights From the Motion Picture Soundtrack)'),\n    ('Mumford & Sons', 'Sigh No More'),\n    ('Frank Ocean', 'Channel ORANGE'),\n    ('Bon Jovi', 'What About Now'),\n    ('Various Artists', 'BRIT Awards 2013'),\n    ('Taylor Swift', 'Red'),\n    ('Fleetwood Mac', 'Fleetwood Mac: Greatest Hits'),\n    ('David Guetta', 'Nothing But the Beat Ultimate'),\n    ('Various Artists', 'Clubbers Guide 2013 (Mixed By Danny Howard) - Ministry of Sound'),\n    ('David Bowie', 'Best of Bowie'),\n    ('Laura Mvula', 'Sing To the Moon'),\n    ('ADELE', '21'),\n    ('Of Monsters and Men', 'My Head Is an Animal'),\n    ('Rihanna', 'Unapologetic'),\n    ('Various Artists', 'BBC Radio 1\\'s Live Lounge - 2012'),\n    ('Avicii & Nicky Romero', 'I Could Be the One (Avicii vs. Nicky Romero)'),\n    ('The Streets', 'A Grand Don\\'t Come for Free'),\n    ('Tim McGraw', 'Two Lanes of Freedom'),\n    ('Foo Fighters', 'Foo Fighters: Greatest Hits'),\n    ('Various Artists', 'Now That\\'s What I Call Running!'),\n    ('Swedish House Mafia', 'Until Now'),\n    ('The xx', 'Coexist'),\n    ('Five', 'Five: Greatest Hits'),\n    ('Jimi Hendrix', 'People, Hell & Angels'),\n    ('Biffy Clyro', 'Opposites (Deluxe)'),\n    ('The Smiths', 'The Sound of the Smiths'),\n    ('The Saturdays', 'What About Us - EP'),\n    ('Fleetwood Mac', 'Rumours'),\n    ('Various Artists', 'The Big Reunion'),\n    ('Various Artists', 'Anthems 90s - Ministry of Sound'),\n    ('The Vaccines', 'Come of Age'),\n    ('Nicole Scherzinger', 'Boomerang (Remixes) - EP'),\n    ('Bob Marley', 'Legend (Bonus Track Version)'),\n    ('Josh Groban', 'All That Echoes'),\n    ('Blue', 'Best of Blue'),\n    ('Ed Sheeran', '+'),\n    ('Olly Murs', 'In Case You Didn\\'t Know (Deluxe Edition)'),\n    ('Macklemore & Ryan Lewis', 'The Heist (Deluxe Edition)'),\n    ('Various Artists', 'Defected Presents Most Rated Miami 2013'),\n    ('Gorgon City', 'Real EP'),\n    ('Mumford & Sons', 'Babel (Deluxe Version)'),\n    ('Various Artists', 'The Music of Nashville: Season 1, Vol. 1 (Original Soundtrack)'),\n    ('Various Artists', 'The Twilight Saga: Breaking Dawn, Pt. 2 (Original Motion Picture Soundtrack)'),\n    ('Various Artists', 'Mum - The Ultimate Mothers Day Collection'),\n    ('One Direction', 'Up All Night'),\n    ('Bon Jovi', 'Bon Jovi Greatest Hits'),\n    ('Agnetha F\u00e4ltskog', 'A'),\n    ('Fun.', 'Some Nights'),\n    ('Justin Bieber', 'Believe Acoustic'),\n    ('Atoms for Peace', 'Amok'),\n    ('Justin Timberlake', 'Justified'),\n    ('Passenger', 'All the Little Lights'),\n    ('Kodaline', 'The High Hopes EP'),\n    ('Lana Del Rey', 'Born to Die'),\n    ('JAY Z & Kanye West', 'Watch the Throne (Deluxe Version)'),\n    ('Biffy Clyro', 'Opposites'),\n    ('Various Artists', 'Return of the 90s'),\n    ('Gabrielle Aplin', 'Please Don\\'t Say You Love Me - EP'),\n    ('Various Artists', '100 Hits - Driving Rock'),\n    ('Jimi Hendrix', 'Experience Hendrix - The Best of Jimi Hendrix'),\n    ('Various Artists', 'The Workout Mix 2013'),\n    ('The 1975', 'Sex'),\n    ('Chase & Status', 'No More Idols'),\n    ('Rihanna', 'Unapologetic (Deluxe Version)'),\n    ('The Killers', 'Battle Born'),\n    ('Olly Murs', 'Right Place Right Time (Deluxe Edition)'),\n    ('A$AP Rocky', 'LONG.LIVE.A$AP (Deluxe Version)'),\n    ('Various Artists', 'Cooking Songs'),\n    ('Haim', 'Forever - EP'),\n    ('Lianne La Havas', 'Is Your Love Big Enough?'),\n    ('Michael Bubl\u00e9', 'To Be Loved'),\n    ('Daughter', 'If You Leave'),\n    ('The xx', 'xx'),\n    ('Eminem', 'Curtain Call'),\n    ('Kendrick Lamar', 'good kid, m.A.A.d city (Deluxe)'),\n    ('Disclosure', 'The Face - EP'),\n    ('Palma Violets', '180'),\n    ('Cody Simpson', 'Paradise'),\n    ('Ed Sheeran', '+ (Deluxe Version)'),\n    ('Michael Bubl\u00e9', 'Crazy Love (Hollywood Edition)'),\n    ('Bon Jovi', 'Bon Jovi Greatest Hits - The Ultimate Collection'),\n    ('Rita Ora', 'Ora'),\n    ('g33k', 'Spabby'),\n    ('Various Artists', 'Annie Mac Presents 2012'),\n    ('David Bowie', 'The Platinum Collection'),\n    ('Bridgit Mendler', 'Ready or Not (Remixes) - EP'),\n    ('Dido', 'Girl Who Got Away'),\n    ('Various Artists', 'Now That\\'s What I Call Disney'),\n    ('The 1975', 'Facedown - EP'),\n    ('Kodaline', 'The Kodaline - EP'),\n    ('Various Artists', '100 Hits: Super 70s'),\n    ('Fred V & Grafix', 'Goggles - EP'),\n    ('Biffy Clyro', 'Only Revolutions (Deluxe Version)'),\n    ('Train', 'California 37'),\n    ('Ben Howard', 'Every Kingdom (Deluxe Edition)'),\n    ('Various Artists', 'Motown Anthems'),\n    ('Courteeners', 'ANNA'),\n    ('Johnny Marr', 'The Messenger'),\n    ('Rodriguez', 'Searching for Sugar Man'),\n    ('Jessie Ware', 'Devotion'),\n    ('Bruno Mars', 'Unorthodox Jukebox'),\n    ('Various Artists', 'Call the Midwife (Music From the TV Series)'\n);  This gives us a handy extra 150 rows to play with. If you now visit your album\nlist at  /album , you'll see a huge long list of 150+ albums; it's ugly.",
            "title": "Preparation"
        },
        {
            "location": "/pagination/#modifying-the-albumtable",
            "text": "In order to let zend-paginator handle our database queries automatically for us,\nwe will be using the  DbSelect paginator adapter \nThis will automatically manipulate and run a  Zend\\Db\\Sql\\Select  object to\ninclude the correct  LIMIT  and  WHERE  clauses so that it returns only the\nconfigured amount of data for the given page. Let's modify the  fetchAll  method\nof the  AlbumTable  model, so that it can optionally return a paginator object:  // in module/Album/src/Album/Model/AlbumTable.php:\nnamespace Album\\Model;\n\nuse Zend\\Db\\ResultSet\\ResultSet;\nuse Zend\\Db\\TableGateway\\TableGateway;\nuse Zend\\Db\\Sql\\Select;\nuse Zend\\Paginator\\Adapter\\DbSelect;\nuse Zend\\Paginator\\Paginator;\n\nclass AlbumTable\n{\n    /* ... */\n\n    public function fetchAll($paginated = false)\n    {\n        if ($paginated) {\n            return $this->fetchPaginatedResults();\n        }\n        $resultSet = $this->tableGateway->select();\n        return $resultSet;\n    }\n\n    private function fetchPaginatedResults()\n    {\n        // Create a new Select object for the table album:\n        $select = new Select('album');\n\n        // Create a new result set based on the Album entity:\n        $resultSetPrototype = new ResultSet();\n        $resultSetPrototype->setArrayObjectPrototype(new Album());\n\n        // Create a new pagination adapter object:\n        $paginatorAdapter = new DbSelect(\n            // our configured select object:\n            $select,\n            // the adapter to run it against:\n            $this->tableGateway->getAdapter(),\n            // the result set to hydrate:\n            $resultSetPrototype\n        );\n\n        $paginator = new Paginator($paginatorAdapter);\n        return $paginator;\n    }\n\n    /* ... */\n}  This will return a fully configured  Paginator  instance. We've already told the DbSelect  adapter to use our created  Select  object, to use the adapter that\nthe  TableGateway  object uses, and also how to hydrate the result into a Album  entity in the same fashion as the  TableGateway  does. This means that\nour executed and returned paginator results will return  Album  objects in\nexactly the same fashion as the non-paginated results.",
            "title": "Modifying the AlbumTable"
        },
        {
            "location": "/pagination/#modifying-the-albumcontroller",
            "text": "Next, we need to tell the album controller to return a  Pagination  object\ninstead of a  ResultSet . Both these objects can by iterated over to return\nhydrated  Album  objects, so we won't need to make many changes to the view\nscript:  // in module/Album/src/Album/Controller/AlbumController.php:\n\n/* ... */\n\npublic function indexAction()\n{\n    // Grab the paginator from the AlbumTable:\n    $paginator = $this->getAlbumTable()->fetchAll(true);\n\n    // Set the current page to what has been passed in query string,\n    // or to 1 if none set:\n    $paginator->setCurrentPageNumber(\n        (int) $this->params()->fromQuery('page', 1)\n    );\n\n    // Set the number of items per page to 10:\n    $paginator->setItemCountPerPage(10);\n\n    return new ViewModel([\n        'paginator' => $paginator\n    ]);\n}\n\n/* ... */  Here we are getting the configured  Paginator  object from the  AlbumTable , and\nthen telling it to use the page that is optionally passed in the querystring page  parameter. We are also telling the paginator we want to display 10\nobjects per page.",
            "title": "Modifying the AlbumController"
        },
        {
            "location": "/pagination/#updating-the-view-script",
            "text": "Now, let's just tell the view script to iterate over the  pagination  view\nvariable, rather than the  albums  variable:  <?php // in module/Album/view/album/album/index.phtml: ?>\n<table class=\"table\">\n    <tr>\n        <th>Title</th>\n        <th>Artist</th>\n        <th>&nbsp;</th>\n    </tr>\n    <?php foreach ($this->paginator as $album) : // <-- change here! ?>\n        <tr>\n            <td><?= $this->escapeHtml($album->title) ?></td>\n            <td><?= $this->escapeHtml($album->artist) ?></td>\n            <td>\n                <a href=\"<?= $this->url('album', ['action' => 'edit', 'id' => $album->id)] ?>\">Edit</a>\n                <a href=\"<?= $this->url('album', ['action' => 'delete', 'id' => $album->id]) ?>\">Delete</a>\n            </td>\n        </tr>\n    <?php endforeach; ?>\n</table>  Checking the  /album  route on your website should now give you a list of just\n10 albums, but with no method to navigate through the pages. Let's correct that\nnow.",
            "title": "Updating the View Script"
        },
        {
            "location": "/pagination/#creating-the-pagination-control-partial",
            "text": "Much like we created a custom breadcrumbs partial to render our breadcrumb in\nthe  navigation tutorial , we need to create a\ncustom pagination control partial to render our pagination control just the way\nwe want it. Again, because we are using Bootstrap, this will primarily involve\noutputting correctly formatted html. Let's create the partial in the module/Application/view/partial/  folder, so that we can use the control in all\nour modules:  <?php // in module/Application/view/partial/paginator.phtml: ?>\n<?php if ($this->pageCount): ?>\n    <div>\n        <ul class=\"pagination\">\n            <!-- Previous page link -->\n            <?php if (isset($this->previous)): ?>\n                <li>\n                    <a href=\"<?= $this->url($this->route, [], ['query' => ['page' => $this->previous]]) ?>\">\n                        <<\n                    </a>\n                </li>\n            <?php else: ?>\n                <li class=\"disabled\">\n                    <a href=\"#\">\n                        <<\n                    </a>\n                </li>\n            <?php endif; ?>\n\n            <!-- Numbered page links -->\n            <?php foreach ($this->pagesInRange as $page): ?>\n                <?php if ($page !== $this->current): ?>\n                    <li>\n                        <a href=\"<?= $this->url($this->route, [], ['query' => ['page' => $page]]) ?>\">\n                            <?= $page; ?>\n                        </a>\n                    </li>\n                <?php else: ?>\n                    <li class=\"active\">\n                        <a href=\"#\"><?= $page; ?></a>\n                    </li>\n                <?php endif; ?>\n            <?php endforeach; ?>\n\n            <!-- Next page link -->\n            <?php if (isset($this->next)): ?>\n                <li>\n                    <a href=\"<?= $this->url($this->route, [], ['query' => ['page' => $this->next]]) ?>\">\n                        >>\n                    </a>\n                </li>\n            <?php else: ?>\n                <li class=\"disabled\">\n                    <a href=\"#\">\n                        >>\n                    </a>\n                </li>\n            <?php endif; ?>\n        </ul>\n    </div>\n<?php endif; ?>  This partial creates a pagination control with links to the correct pages (if\nthere is more than one page in the pagination object). It will render a previous\npage link (and mark it disabled if you are at the first page), then render a\nlist of intermediate pages (that are passed to the partial based on the\nrendering style; we'll set in the view helper in the next step).  Finally, it\nwill create a next page link (and disable it if you're at the end).  Notice how\nwe pass the page number via the  page  querystring parameter which we have\nalready told our controller to use to display the current page.",
            "title": "Creating the Pagination Control Partial"
        },
        {
            "location": "/pagination/#using-the-paginationcontrol-view-helper",
            "text": "To page through the albums, we need to invoke the paginationControl view helper \nto display our pagination control:  <?php\n// In module/Album/view/album/album/index.phtml.\n// Add at the end of the file after the table:\necho $this->paginationControl(\n    // The paginator object:\n    $this->paginator,\n    // The scrolling style:\n    'sliding',\n    // The partial to use to render the control:\n    'partial/paginator.phtml',\n    // The route to link to when a user clicks a control link:\n    [ 'route' => 'album' ]\n);\n?>  The above echoes the  paginationControl  helper, and tells it to use our\npaginator instance, the  sliding scrolling style ,\nour paginator partial, and which route to use for generating links. Refreshing\nyour application now should give you Bootstrap-styled pagination controls!",
            "title": "Using the PaginationControl View Helper"
        },
        {
            "location": "/unit-testing/",
            "text": "Unit Testing a zend-mvc application\n\n\n\n\nTODO\n\n\n\n\nRemove section on installing phpunit, and replace with installing zend-test.\n\n\nUpdate assertions against controller names; they're the same as the class now.\n\n\nTry the tests and confirm they work.\n\n\n\n\n\n\nA solid unit test suite is essential for ongoing development in large projects,\nespecially those with many people involved. Going back and manually testing\nevery individual component of an application after every change is impractical.\nYour unit tests will help alleviate that by automatically testing your\napplication's components and alerting you when something is not working the same\nway it was when you wrote your tests.\n\n\nThis tutorial is written in the hopes of showing how to test different parts of\na zend-mvc application. As such, this tutorial will use the application written\nin the \ngetting started user guide\n. It is in no way a\nguide to unit testing in general, but is here only to help overcome the initial\nhurdles in writing unit tests for zend-mvc applications.\n\n\nIt is recommended to have at least a basic understanding of unit tests,\nassertions and mocks.\n\n\nzend-test, which provides testing integration for zend-mvc, uses\n\nPHPUnit\n. This tutorial assumes that you already have\nPHPUnit from either a version 4 or version 5 series installed; version 5 is\nrequired if you are using PHP 7.\n\n\nSetting up phpunit to use composer's autoload.php\n\n\nIf you used composer to generate an \nautoload.php\n file for you, per the\nskeleton application, then you need to use a phpunit binary installed by\ncomposer. You can add this as a development dependency using composer itself:\n\n\n$ composer require --dev phpunit/phpunit\n\n\n\n\nThe above command will update your \ncomposer.json\n file and perform an update\nfor you, which will also setup autoloading rules.\n\n\nSetting up the tests directory\n\n\nAs zend-mvc applications are built from modules that should be\nstandalone blocks of an application, we don't test the application in it's\nentirety, but module by module.\n\n\nWe will demonstrate setting up the minimum requirements to test a module, the\n\nAlbum\n module we wrote in the user guide, which then can be used as a base\nfor testing any other module.\n\n\nStart by creating a directory called \ntest\n in \nzf2-tutorial\\module\\Album\n with\nthe following subdirectories:\n\n\nzf2-tutorial/\n    /module\n        /Album\n            /test\n                /Controller\n\n\n\n\nAdditionally, add an \nautoload-dev\n rule in your \ncomposer.json\n:\n\n\n\"autoload-dev\": {\n    \"psr-4\": {\n        \"AlbumTest\\\\\": \"module/Album/test/\"\n    }\n}\n\n\n\n\nWhen done, run:\n\n\n$ composer dump-autoload\n\n\n\n\nThe structure of the \ntest\n directory matches exactly with that of the module's\nsource files, and it will allow you to keep your tests well-organized and easy\nto find.\n\n\nBootstrapping your tests\n\n\nNext, create a file called \nphpunit.xml.dist\n under\n\nzf2-tutorial/module/Album/test\n:\n\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<phpunit bootstrap=\"Bootstrap.php\" colors=\"true\">\n    <testsuites>\n        <testsuite name=\"zf2tutorial\">\n            <directory>.</directory>\n        </testsuite>\n    </testsuites>\n</phpunit>\n\n\n\n\nNow create a file called \nBootstrap.php\n, also under \nzf2-tutorial/module/Album/test\n:\n\n\n<?php\nnamespace AlbumTest;\n\nuse Zend\\Loader\\AutoloaderFactory;\nuse Zend\\Mvc\\Service\\ServiceManagerConfig;\nuse Zend\\ServiceManager\\ServiceManager;\nuse RuntimeException;\n\nerror_reporting(E_ALL | E_STRICT);\nchdir(__DIR__);\n\n/**\n * Test bootstrap, for setting up autoloading\n */\nclass Bootstrap\n{\n    protected static $serviceManager;\n\n    public static function init()\n    {\n        $zf2ModulePaths = array(dirname(dirname(__DIR__)));\n        if (($path = static::findParentPath('vendor'))) {\n            $zf2ModulePaths[] = $path;\n        }\n        if (($path = static::findParentPath('module')) !== $zf2ModulePaths[0]) {\n            $zf2ModulePaths[] = $path;\n        }\n\n        static::initAutoloader();\n\n        // Use ModuleManager to load this module and its dependencies\n        $config = [\n            'module_listener_options' => [\n                'module_paths' => $zf2ModulePaths,\n            ],\n            'modules' => [\n                'Album',\n            ]\n        ];\n\n        $serviceManager = new ServiceManager(new ServiceManagerConfig());\n        $serviceManager->setService('ApplicationConfig', $config);\n        $serviceManager->get('ModuleManager')->loadModules();\n        static::$serviceManager = $serviceManager;\n    }\n\n    public static function chroot()\n    {\n        $rootPath = dirname(static::findParentPath('module'));\n        chdir($rootPath);\n    }\n\n    public static function getServiceManager()\n    {\n        return static::$serviceManager;\n    }\n\n    protected static function initAutoloader()\n    {\n        $vendorPath = static::findParentPath('vendor');\n\n        if (file_exists($vendorPath.'/autoload.php')) {\n            include $vendorPath.'/autoload.php';\n        }\n\n        if (! class_exists('Zend\\Mvc\\Application')) {\n            throw new RuntimeException('Unable to load ZF2. Run `composer install`');\n        }\n    }\n\n    protected static function findParentPath($path)\n    {\n        $dir = __DIR__;\n        $previousDir = '.';\n        while (! is_dir($dir . '/' . $path)) {\n            $dir = dirname($dir);\n            if ($previousDir === $dir) {\n                return false;\n            }\n            $previousDir = $dir;\n        }\n        return $dir . '/' . $path;\n    }\n}\n\nBootstrap::init();\nBootstrap::chroot();\n\n\n\n\nThe contents of this bootstrap file can be daunting at first sight, but all it\ndoes is ensure that all the necessary files are autoloadable for our tests, and\nthat we have initial application configuration. The most important lines are in\nthe \ninit()\n method, where we specify the \nmodules\n for the application.  In\nthis case we are only loading the \nAlbum\n module as it has no dependencies\nagainst other modules, but when testing other modules, you will need to factor\nin their own dependencies.\n\n\nNow, if you navigate to the \nzf2-tutorial/module/Album/test/\n directory, and run\n\nphpunit\n, you should get a similar output to this:\n\n\nPHPUnit 5.3.4 by Sebastian Bergmann and contributors.\n\nConfiguration read from /var/www/zf2-tutorial/module/Album/test/phpunit.xml.dist\n\nTime: 0 seconds, Memory: 1.75Mb\n\nNo tests executed!\n\n\n\n\nEven though no tests were executed, we at least know that the autoloader found\nthe required files and classes; otherwise it would throw a \nRuntimeException\n,\nas demonstrated in the \ninitAutoloader()\n method.\n\n\nYour first controller test\n\n\nTesting controllers is never an easy task, but the zend-test component makes\ntesting much less cumbersome.\n\n\nFirst, create \nAlbumControllerTest.php\n under\n\nzf2-tutorial/module/Album/test/Controller\n with the following contents:\n\n\n<?php\nnamespace AlbumTest\\Controller;\n\nuse Zend\\Test\\PHPUnit\\Controller\\AbstractHttpControllerTestCase;\n\nclass AlbumControllerTest extends AbstractHttpControllerTestCase\n{\n    public function setUp()\n    {\n        $this->setApplicationConfig(\n            // Grabbing the full application configuration:\n            include __DIR__ . '/../../../../config/application.config.php'\n        );\n        parent::setUp();\n    }\n}\n\n\n\n\nThe \nAbstractHttpControllerTestCase\n class we extend here helps us setting up\nthe application itself, helps with dispatching and other tasks that happen\nduring a request, and offers methods for asserting request params, response\nheaders, redirects, and more. See the \nzend-test\n\ndocumentation for more information.\n\n\nThe principal requirement for any zend-test test case is to set the application\nconfig with the \nsetApplicationConfig()\n method.\n\n\nNow, add the following function to the \nAlbumControllerTest\n class:\n\n\npublic function testIndexActionCanBeAccessed()\n{\n    $this->dispatch('/album');\n    $this->assertResponseStatusCode(200);\n\n    $this->assertModuleName('Album');\n    $this->assertControllerName('Album\\Controller\\Album');\n    $this->assertControllerClass('AlbumController');\n    $this->assertMatchedRouteName('album');\n}\n\n\n\n\nThis test case dispatches the \n/album\n URL, asserts that the response code is\n200, and that we ended up in the desired module and controller.\n\n\n\n\nAssert against controller service names\n\n\nFor asserting the \ncontroller name\n we are using the controller name we\ndefined in our  routing configuration for the Album module. In our example\nthis should be defined on line 19 of the \nmodule.config.php\n file in the Album\nmodule.\n\n\n\n\nA failing test case\n\n\nFinally, \ncd\n to \nzf2-tutorial/module/Album/test/\n and run \nphpunit\n. Uh-oh! The\ntest failed!\n\n\nPHPUnit 5.3.4 by Sebastian Bergmann and contributors.\n\nConfiguration read from /var/www/zf2-tutorial/module/Album/test/phpunit.xml.dist\n\nF\n\nTime: 0 seconds, Memory: 8.50Mb\n\nThere was 1 failure:\n\n1) AlbumTest\\Controller\\AlbumControllerTest::testIndexActionCanBeAccessed\nFailed asserting response code \"200\", actual status code is \"500\"\n\n/var/www/zf2-tutorial/vendor/ZF2/library/Zend/Test/PHPUnit/Controller/AbstractControllerTestCase.php:373\n/var/www/zf2-tutorial/module/Album/test/AlbumTest/Controller/AlbumControllerTest.php:22\n\nFAILURES!\nTests: 1, Assertions: 0, Failures: 1.\n\n\n\n\nThe failure message doesn't tell us much, apart from that the expected status\ncode is not 200, but 500. To get a bit more information when something goes\nwrong in a test case, we set the protected \n$traceError\n member to \ntrue\n. Add\nthe following just above the \nsetUp\n method in our \nAlbumControllerTest\n class:\n\n\nprotected $traceError = true;\n\n\n\n\nRunning the \nphpunit\n command again and we should see some more information\nabout what went wrong in our test. The main error message we are interested in\nshould read something like:\n\n\nZend\\ServiceManager\\Exception\\ServiceNotFoundException: Zend\\ServiceManager\\ServiceManager::get\nwas unable to fetch or create an instance for Zend\\Db\\Adapter\\Adapter\n\n\n\n\nFrom this error message it is clear that not all our dependencies are available\nin the service manager. Let us take a look how can we fix this.\n\n\nConfiguring the service manager for the tests\n\n\nThe error says that the service manager can not create an instance of a database\nadapter for us. The database adapter is indirectly used by our\n\nAlbum\\Model\\AlbumTable\n to fetch the list of albums from the database.\n\n\nThe first thought would be to create an instance of an adapter, pass it to the\nservice manager, and let the code run from there as is. The problem with this\napproach is that we would end up with our test cases actually doing queries\nagainst the database. To keep our tests fast, and to reduce the number of\npossible failure points in our tests, this should be avoided.\n\n\nThe second thought would be then to create a mock of the database adapter, and\nprevent the actual database calls by mocking them out. This is a much better\napproach, but creating the adapter mock is tedious (but no doubt we will have to\ncreate it at some point).\n\n\nThe best thing to do would be to mock out our \nAlbum\\Model\\AlbumTable\n class\nwhich retrieves the list of albums from the database. Remember, we are now\ntesting our controller, so we can mock out the actual call to \nfetchAll\n and\nreplace the return values with dummy values. At this point, we are not\ninterested in how \nfetchAll\n retrieves the albums, but only that it gets called\nand that it returns an array of albums; these facts allow us to provide mock\ninstances. When we test \nAlbumTable\n itself, we can write the actual tests for\nthe \nfetchAll\n method.\n\n\nHere is how we can accomplish this, by modifying the\n\ntestIndexActionCanBeAccessed\n test method as follows:\n\n\npublic function testIndexActionCanBeAccessed()\n{\n    $albumTableMock = $this->getMockBuilder(AlbumTable::class)\n        ->disableOriginalConstructor()\n        ->getMock();\n\n    $albumTableMock->expects($this->once())\n        ->method('fetchAll')\n        ->will($this->returnValue([]));\n\n    $serviceManager = $this->getApplicationServiceLocator();\n    $serviceManager->setAllowOverride(true);\n    $serviceManager->setService(AlbumTable::class, $albumTableMock);\n\n    $this->dispatch('/album');\n    $this->assertResponseStatusCode(200);\n\n    $this->assertModuleName('Album');\n    $this->assertControllerName('Album\\Controller\\Album');\n    $this->assertControllerClass('AlbumController');\n    $this->assertMatchedRouteName('album');\n}\n\n\n\n\nBy default, the \nServiceManager\n does not allow us to replace existing services.\nAs the \nAlbum\\Model\\AlbumTable\n was already set, we are allowing for overrides\n(via the \nsetAllowOverride()\n call), and then replacing the real instance of the\n\nAlbumTable\n with a mock.  The mock is created so that it will return just an\nempty array when the \nfetchAll\n method is called. This allows us to test for\nwhat we care about in this test, and that is that by dispatching to the \n/album\n\nURL we get to the Album module's AlbumController.\n\n\nRunning \nphpunit\n at this point, we will get the following output as the tests\nnow pass:\n\n\nPHPUnit 5.3.4 by Sebastian Bergmann and contributors.\n\nConfiguration read from /var/www/zf2-tutorial/module/Album/test/phpunit.xml.dist\n\n.\n\nTime: 0 seconds, Memory: 9.00Mb\n\nOK (1 test, 6 assertions)\n\n\n\n\nTesting actions with POST\n\n\nOne of the most common actions happening in controllers is submitting a form\nwith some POST data; those tests look similar to the following:\n\n\n :linenos:}\npublic function testAddActionRedirectsAfterValidPost()\n{\n    $albumTableMock = $this->getMockBuilder(AlbumTable::class)\n        ->disableOriginalConstructor()\n        ->getMock();\n\n    $albumTableMock->expects($this->once())\n        ->method('saveAlbum')\n        ->will($this->returnValue(null));\n\n    $serviceManager = $this->getApplicationServiceLocator();\n    $serviceManager->setAllowOverride(true);\n    $serviceManager->setService(AlbumTable::class, $albumTableMock);\n\n    $postData = [\n        'title'  => 'Led Zeppelin III',\n        'artist' => 'Led Zeppelin',\n        'id'     => '',\n    ];\n    $this->dispatch('/album/add', 'POST', $postData);\n    $this->assertResponseStatusCode(302);\n\n    $this->assertRedirectTo('/album/');\n}\n\n\n\n\nHere we test that when we make a POST request against the \n/album/add\n URL, the\n\nAlbum\\Model\\AlbumTable\n's \nsaveAlbum()\n method will be called, and after that\nwe will be redirected back to the \n/album\n URL.\n\n\nRunning \nphpunit\n gives us the following output:\n\n\nPHPUnit 5.3.4 by Sebastian Bergmann and contributors.\n\nConfiguration read from /home/robert/www/zf2-tutorial/module/Album/test/phpunit.xml.dist\n\n..\n\nTime: 0 seconds, Memory: 10.75Mb\n\nOK (2 tests, 9 assertions)\n\n\n\n\nTesting the \neditAction()\n and \ndeleteAction()\n methods can be easily done in a\nmanner similar as shown for the \naddAction()\n.\n\n\nWhen testing the \neditAction()\n method, you will also need to mock out the\n\ngetAlbum()\n method:\n\n\n$albumTableMock->expects($this->once())\n    ->method('getAlbum')\n    ->will($this->returnValue(new Album()));\n\n\n\n\nTesting model entities\n\n\nNow that we know how to test our controllers, let us move to an other important\npart of our application: the model entity.\n\n\nHere we want to test that the initial state of the entity is what we expect it\nto be, that we can convert the model's parameters to and from an array, and that\nit has all the input filters we need.\n\n\nCreate the file \nAlbumTest.php\n in \nmodule/Album/test/Model\n directory\nwith the following contents:\n\n\n<?php\nnamespace AlbumTest\\Model;\n\nuse Album\\Model\\Album;\nuse PHPUnit_Framework_TestCase as TestCase;\n\nclass AlbumTest extends TestCase\n{\n    public function testAlbumInitialState()\n    {\n        $album = new Album();\n\n        $this->assertNull(\n            $album->artist,\n            '\"artist\" should initially be null'\n        );\n\n        $this->assertNull(\n            $album->id,\n            '\"id\" should initially be null'\n        );\n\n        $this->assertNull(\n            $album->title,\n            '\"title\" should initially be null'\n        );\n    }\n\n    public function testExchangeArraySetsPropertiesCorrectly()\n    {\n        $album = new Album();\n        $data  = [\n            'artist' => 'some artist',\n            'id'     => 123,\n            'title'  => 'some title'\n        ];\n\n        $album->exchangeArray($data);\n\n        $this->assertSame(\n            $data['artist'],\n            $album->artist,\n            '\"artist\" was not set correctly'\n        );\n\n        $this->assertSame(\n            $data['id'],\n            $album->id,\n            '\"id\" was not set correctly'\n        );\n\n        $this->assertSame(\n            $data['title'],\n            $album->title,\n            '\"title\" was not set correctly'\n        );\n    }\n\n    public function testExchangeArraySetsPropertiesToNullIfKeysAreNotPresent()\n    {\n        $album = new Album();\n\n        $album->exchangeArray([\n            'artist' => 'some artist',\n            'id'     => 123,\n            'title'  => 'some title',\n        ]);\n        $album->exchangeArray([]);\n\n        $this->assertNull(\n            $album->artist,\n            '\"artist\" should have defaulted to null'\n        );\n\n        $this->assertNull(\n            $album->id,\n            '\"id\" should have defaulted to null'\n        );\n\n        $this->assertNull(\n            $album->title,\n            '\"title\" should have defaulted to null'\n        );\n    }\n\n    public function testGetArrayCopyReturnsAnArrayWithPropertyValues()\n    {\n        $album = new Album();\n        $data  = [\n            'artist' => 'some artist',\n            'id'     => 123,\n            'title'  => 'some title'\n        ];\n\n        $album->exchangeArray($data);\n        $copyArray = $album->getArrayCopy();\n\n        $this->assertSame(\n            $data['artist'],\n            $copyArray['artist'],\n            '\"artist\" was not set correctly'\n        );\n\n        $this->assertSame(\n            $data['id'],\n            $copyArray['id'],\n            '\"id\" was not set correctly'\n        );\n\n        $this->assertSame(\n            $data['title'],\n            $copyArray['title'],\n            '\"title\" was not set correctly'\n        );\n    }\n\n    public function testInputFiltersAreSetCorrectly()\n    {\n        $album = new Album();\n\n        $inputFilter = $album->getInputFilter();\n\n        $this->assertSame(3, $inputFilter->count());\n        $this->assertTrue($inputFilter->has('artist'));\n        $this->assertTrue($inputFilter->has('id'));\n        $this->assertTrue($inputFilter->has('title'));\n    }\n}\n\n\n\n\nWe are testing for 5 things:\n\n\n\n\nAre all of the \nAlbum\n's properties initially set to \nNULL\n?\n\n\nWill the \nAlbum\n's properties be set correctly when we call \nexchangeArray()\n?\n\n\nWill a default value of \nNULL\n be used for properties whose keys are not present in the \n$data\n array?\n\n\nCan we get an array copy of our model?\n\n\nDo all elements have input filters present?\n\n\n\n\nIf we run \nphpunit\n again, we will get the following output, confirming that our\nmodel is indeed correct:\n\n\nPHPUnit 5.3.4 by Sebastian Bergmann and contributors.\n\nConfiguration read from /var/www/zf2-tutorial/module/Album/test/phpunit.xml.dist\n\n.......\n\nTime: 0 seconds, Memory: 11.00Mb\n\nOK (7 tests, 25 assertions)\n\n\n\n\nTesting model tables\n\n\nThe final step in this unit testing tutorial for zend-mvc applications is\nwriting tests for our model tables.\n\n\nThis test assures that we can get a list of albums, or one album by its ID, and\nthat we can save and delete albums from the database.\n\n\nTo avoid actual interaction with the database itself, we will replace certain\nparts with mocks.\n\n\nCreate a file \nAlbumTableTest.php\n in \nmodule/Album/test/Model\n with\nthe following contents:\n\n\n<?php\nnamespace AlbumTest\\Model;\n\nuse Album\\Model\\AlbumTable;\nuse Album\\Model\\Album;\nuse PHPUnit_Framework_TestCase as TestCase;\nuse Zend\\Db\\ResultSet\\ResultSet;\n\nclass AlbumTableTest extends TestCase\n{\n    public function testFetchAllReturnsAllAlbums()\n    {\n        $resultSet = new ResultSet();\n        $mockTableGateway = $this->getMock(\n            'Zend\\Db\\TableGateway\\TableGateway',\n            ['select'],\n            [],\n            '',\n            false\n        );\n        $mockTableGateway->expects($this->once())\n            ->method('select')\n            ->with()\n            ->will($this->returnValue($resultSet));\n\n        $albumTable = new AlbumTable($mockTableGateway);\n\n        $this->assertSame($resultSet, $albumTable->fetchAll());\n    }\n}\n\n\n\n\nSince we are testing the \nAlbumTable\n here and not the \nTableGateway\n class\n(which has already been tested in zend-db), we only want to make sure\nthat our \nAlbumTable\n class is interacting with the \nTableGateway\n class the way\nthat we expect it to. Above, we're testing to see if the \nfetchAll()\n method of\n\nAlbumTable\n will call the \nselect()\n method of the \n$tableGateway\n property\nwith no parameters. If it does, it should return a \nResultSet\n object. Finally,\nwe expect that this same \nResultSet\n object will be returned to the calling\nmethod. This test should run fine, so now we can add the rest of the test\nmethods:\n\n\npublic function testCanRetrieveAnAlbumByItsId()\n{\n    $album = new Album();\n    $album->exchangeArray([\n        'id'     => 123,\n        artist' => 'The Military Wives',\n        title'  => 'In My Dreams'\n    ]);\n\n    $resultSet = new ResultSet();\n    $resultSet->setArrayObjectPrototype(new Album());\n    $resultSet->initialize(array($album));\n\n    $mockTableGateway = $this->getMock(\n        'Zend\\Db\\TableGateway\\TableGateway',\n        ['select'],\n        [],\n        '',\n        false\n    );\n    $mockTableGateway->expects($this->once())\n        ->method('select')\n        ->with(['id' => 123])\n        ->will($this->returnValue($resultSet));\n\n    $albumTable = new AlbumTable($mockTableGateway);\n\n    $this->assertSame($album, $albumTable->getAlbum(123));\n}\n\npublic function testCanDeleteAnAlbumByItsId()\n{\n    $mockTableGateway = $this->getMock(\n        'Zend\\Db\\TableGateway\\TableGateway',\n        ['delete'],\n        [],\n        '',\n        false\n    );\n    $mockTableGateway->expects($this->once())\n        ->method('delete')\n        ->with(['id' => 123]);\n\n    $albumTable = new AlbumTable($mockTableGateway);\n    $albumTable->deleteAlbum(123);\n}\n\npublic function testSaveAlbumWillInsertNewAlbumsIfTheyDontAlreadyHaveAnId()\n{\n    $albumData = [\n        'artist' => 'The Military Wives',\n        'title'  => 'In My Dreams'\n    ];\n    $album = new Album();\n    $album->exchangeArray($albumData);\n\n    $mockTableGateway = $this->getMock(\n        'Zend\\Db\\TableGateway\\TableGateway',\n        ['insert'],\n        [],\n        '',\n        false\n    );\n    $mockTableGateway->expects($this->once())\n        ->method('insert')\n        ->with($albumData);\n\n    $albumTable = new AlbumTable($mockTableGateway);\n    $albumTable->saveAlbum($album);\n}\n\npublic function testSaveAlbumWillUpdateExistingAlbumsIfTheyAlreadyHaveAnId()\n{\n    $albumData = [\n        'id'     => 123,\n        'artist' => 'The Military Wives',\n        'title'  => 'In My Dreams',\n    ];\n    $album = new Album();\n    $album->exchangeArray($albumData);\n\n    $resultSet = new ResultSet();\n    $resultSet->setArrayObjectPrototype(new Album());\n    $resultSet->initialize([$album]);\n\n    $mockTableGateway = $this->getMock(\n        'Zend\\Db\\TableGateway\\TableGateway',\n        ['select', 'update'],\n        [],\n        '',\n        false\n    );\n    $mockTableGateway->expects($this->once())\n        ->method('select')\n        ->with(['id' => 123])\n        ->will($this->returnValue($resultSet));\n    $mockTableGateway->expects($this->once())\n        ->method('update')\n        ->with(\n            [\n                'artist' => 'The Military Wives',\n                'title'  => 'In My Dreams'\n            ],\n            ['id' => 123]\n        );\n\n    $albumTable = new AlbumTable($mockTableGateway);\n    $albumTable->saveAlbum($album);\n}\n\npublic function testExceptionIsThrownWhenGettingNonExistentAlbum()\n{\n    $resultSet = new ResultSet();\n    $resultSet->setArrayObjectPrototype(new Album());\n    $resultSet->initialize([]);\n\n    $mockTableGateway = $this->getMock(\n        'Zend\\Db\\TableGateway\\TableGateway',\n        ['select'],\n        [],\n        '',\n        false\n    );\n    $mockTableGateway->expects($this->once())\n        ->method('select')\n        ->with(['id' => 123])\n        ->will($this->returnValue($resultSet));\n\n    $albumTable = new AlbumTable($mockTableGateway);\n\n    $this->setExpectedException('Exception', 'Could not find row 123');\n    $albumTable->getAlbum(123);\n}\n\n\n\n\nThese tests are nothing complicated and they should be self explanatory. In each\ntest we are injecting a mock table gateway into our \nAlbumTable\n, and we then\nset our expectations accordingly.\n\n\nWe are testing that:\n\n\n\n\nWe can retrieve an individual album by its ID.\n\n\nWe can delete albums.\n\n\nWe can save a new album.\n\n\nWe can update existing albums.\n\n\nWe will encounter an exception if we're trying to retrieve an album that doesn't exist.\n\n\n\n\nRunning \nphpunit\n one last time, we get the output as follows:\n\n\nPHPUnit 5.3.4 by Sebastian Bergmann and contributors.\n\nConfiguration read from /var/www/zf2-tutorial/module/Album/test/phpunit.xml.dist\n\n.............\n\nTime: 0 seconds, Memory: 11.50Mb\n\nOK (13 tests, 34 assertions)\n\n\n\n\nConclusion\n\n\nIn this short tutorial, we gave a few examples how different parts of a zend-mvc\napplication can be tested. We covered setting up the environment for testing,\nhow to test controllers and actions, how to approach failing test cases , how to\nconfigure the service manager, as well as how to test model entities and model\ntables .\n\n\nThis tutorial is by no means a definitive guide to writing unit tests, just a\nsmall stepping stone helping you develop applications of higher quality.",
            "title": "Unit Testing A zend-mvc Application"
        },
        {
            "location": "/unit-testing/#unit-testing-a-zend-mvc-application",
            "text": "",
            "title": "Unit Testing a zend-mvc application"
        },
        {
            "location": "/unit-testing/#todo",
            "text": "Remove section on installing phpunit, and replace with installing zend-test.  Update assertions against controller names; they're the same as the class now.  Try the tests and confirm they work.    A solid unit test suite is essential for ongoing development in large projects,\nespecially those with many people involved. Going back and manually testing\nevery individual component of an application after every change is impractical.\nYour unit tests will help alleviate that by automatically testing your\napplication's components and alerting you when something is not working the same\nway it was when you wrote your tests.  This tutorial is written in the hopes of showing how to test different parts of\na zend-mvc application. As such, this tutorial will use the application written\nin the  getting started user guide . It is in no way a\nguide to unit testing in general, but is here only to help overcome the initial\nhurdles in writing unit tests for zend-mvc applications.  It is recommended to have at least a basic understanding of unit tests,\nassertions and mocks.  zend-test, which provides testing integration for zend-mvc, uses PHPUnit . This tutorial assumes that you already have\nPHPUnit from either a version 4 or version 5 series installed; version 5 is\nrequired if you are using PHP 7.",
            "title": "TODO"
        },
        {
            "location": "/unit-testing/#setting-up-phpunit-to-use-composers-autoloadphp",
            "text": "If you used composer to generate an  autoload.php  file for you, per the\nskeleton application, then you need to use a phpunit binary installed by\ncomposer. You can add this as a development dependency using composer itself:  $ composer require --dev phpunit/phpunit  The above command will update your  composer.json  file and perform an update\nfor you, which will also setup autoloading rules.",
            "title": "Setting up phpunit to use composer's autoload.php"
        },
        {
            "location": "/unit-testing/#setting-up-the-tests-directory",
            "text": "As zend-mvc applications are built from modules that should be\nstandalone blocks of an application, we don't test the application in it's\nentirety, but module by module.  We will demonstrate setting up the minimum requirements to test a module, the Album  module we wrote in the user guide, which then can be used as a base\nfor testing any other module.  Start by creating a directory called  test  in  zf2-tutorial\\module\\Album  with\nthe following subdirectories:  zf2-tutorial/\n    /module\n        /Album\n            /test\n                /Controller  Additionally, add an  autoload-dev  rule in your  composer.json :  \"autoload-dev\": {\n    \"psr-4\": {\n        \"AlbumTest\\\\\": \"module/Album/test/\"\n    }\n}  When done, run:  $ composer dump-autoload  The structure of the  test  directory matches exactly with that of the module's\nsource files, and it will allow you to keep your tests well-organized and easy\nto find.",
            "title": "Setting up the tests directory"
        },
        {
            "location": "/unit-testing/#bootstrapping-your-tests",
            "text": "Next, create a file called  phpunit.xml.dist  under zf2-tutorial/module/Album/test :  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<phpunit bootstrap=\"Bootstrap.php\" colors=\"true\">\n    <testsuites>\n        <testsuite name=\"zf2tutorial\">\n            <directory>.</directory>\n        </testsuite>\n    </testsuites>\n</phpunit>  Now create a file called  Bootstrap.php , also under  zf2-tutorial/module/Album/test :  <?php\nnamespace AlbumTest;\n\nuse Zend\\Loader\\AutoloaderFactory;\nuse Zend\\Mvc\\Service\\ServiceManagerConfig;\nuse Zend\\ServiceManager\\ServiceManager;\nuse RuntimeException;\n\nerror_reporting(E_ALL | E_STRICT);\nchdir(__DIR__);\n\n/**\n * Test bootstrap, for setting up autoloading\n */\nclass Bootstrap\n{\n    protected static $serviceManager;\n\n    public static function init()\n    {\n        $zf2ModulePaths = array(dirname(dirname(__DIR__)));\n        if (($path = static::findParentPath('vendor'))) {\n            $zf2ModulePaths[] = $path;\n        }\n        if (($path = static::findParentPath('module')) !== $zf2ModulePaths[0]) {\n            $zf2ModulePaths[] = $path;\n        }\n\n        static::initAutoloader();\n\n        // Use ModuleManager to load this module and its dependencies\n        $config = [\n            'module_listener_options' => [\n                'module_paths' => $zf2ModulePaths,\n            ],\n            'modules' => [\n                'Album',\n            ]\n        ];\n\n        $serviceManager = new ServiceManager(new ServiceManagerConfig());\n        $serviceManager->setService('ApplicationConfig', $config);\n        $serviceManager->get('ModuleManager')->loadModules();\n        static::$serviceManager = $serviceManager;\n    }\n\n    public static function chroot()\n    {\n        $rootPath = dirname(static::findParentPath('module'));\n        chdir($rootPath);\n    }\n\n    public static function getServiceManager()\n    {\n        return static::$serviceManager;\n    }\n\n    protected static function initAutoloader()\n    {\n        $vendorPath = static::findParentPath('vendor');\n\n        if (file_exists($vendorPath.'/autoload.php')) {\n            include $vendorPath.'/autoload.php';\n        }\n\n        if (! class_exists('Zend\\Mvc\\Application')) {\n            throw new RuntimeException('Unable to load ZF2. Run `composer install`');\n        }\n    }\n\n    protected static function findParentPath($path)\n    {\n        $dir = __DIR__;\n        $previousDir = '.';\n        while (! is_dir($dir . '/' . $path)) {\n            $dir = dirname($dir);\n            if ($previousDir === $dir) {\n                return false;\n            }\n            $previousDir = $dir;\n        }\n        return $dir . '/' . $path;\n    }\n}\n\nBootstrap::init();\nBootstrap::chroot();  The contents of this bootstrap file can be daunting at first sight, but all it\ndoes is ensure that all the necessary files are autoloadable for our tests, and\nthat we have initial application configuration. The most important lines are in\nthe  init()  method, where we specify the  modules  for the application.  In\nthis case we are only loading the  Album  module as it has no dependencies\nagainst other modules, but when testing other modules, you will need to factor\nin their own dependencies.  Now, if you navigate to the  zf2-tutorial/module/Album/test/  directory, and run phpunit , you should get a similar output to this:  PHPUnit 5.3.4 by Sebastian Bergmann and contributors.\n\nConfiguration read from /var/www/zf2-tutorial/module/Album/test/phpunit.xml.dist\n\nTime: 0 seconds, Memory: 1.75Mb\n\nNo tests executed!  Even though no tests were executed, we at least know that the autoloader found\nthe required files and classes; otherwise it would throw a  RuntimeException ,\nas demonstrated in the  initAutoloader()  method.",
            "title": "Bootstrapping your tests"
        },
        {
            "location": "/unit-testing/#your-first-controller-test",
            "text": "Testing controllers is never an easy task, but the zend-test component makes\ntesting much less cumbersome.  First, create  AlbumControllerTest.php  under zf2-tutorial/module/Album/test/Controller  with the following contents:  <?php\nnamespace AlbumTest\\Controller;\n\nuse Zend\\Test\\PHPUnit\\Controller\\AbstractHttpControllerTestCase;\n\nclass AlbumControllerTest extends AbstractHttpControllerTestCase\n{\n    public function setUp()\n    {\n        $this->setApplicationConfig(\n            // Grabbing the full application configuration:\n            include __DIR__ . '/../../../../config/application.config.php'\n        );\n        parent::setUp();\n    }\n}  The  AbstractHttpControllerTestCase  class we extend here helps us setting up\nthe application itself, helps with dispatching and other tasks that happen\nduring a request, and offers methods for asserting request params, response\nheaders, redirects, and more. See the  zend-test \ndocumentation for more information.  The principal requirement for any zend-test test case is to set the application\nconfig with the  setApplicationConfig()  method.  Now, add the following function to the  AlbumControllerTest  class:  public function testIndexActionCanBeAccessed()\n{\n    $this->dispatch('/album');\n    $this->assertResponseStatusCode(200);\n\n    $this->assertModuleName('Album');\n    $this->assertControllerName('Album\\Controller\\Album');\n    $this->assertControllerClass('AlbumController');\n    $this->assertMatchedRouteName('album');\n}  This test case dispatches the  /album  URL, asserts that the response code is\n200, and that we ended up in the desired module and controller.",
            "title": "Your first controller test"
        },
        {
            "location": "/unit-testing/#assert-against-controller-service-names",
            "text": "For asserting the  controller name  we are using the controller name we\ndefined in our  routing configuration for the Album module. In our example\nthis should be defined on line 19 of the  module.config.php  file in the Album\nmodule.",
            "title": "Assert against controller service names"
        },
        {
            "location": "/unit-testing/#a-failing-test-case",
            "text": "Finally,  cd  to  zf2-tutorial/module/Album/test/  and run  phpunit . Uh-oh! The\ntest failed!  PHPUnit 5.3.4 by Sebastian Bergmann and contributors.\n\nConfiguration read from /var/www/zf2-tutorial/module/Album/test/phpunit.xml.dist\n\nF\n\nTime: 0 seconds, Memory: 8.50Mb\n\nThere was 1 failure:\n\n1) AlbumTest\\Controller\\AlbumControllerTest::testIndexActionCanBeAccessed\nFailed asserting response code \"200\", actual status code is \"500\"\n\n/var/www/zf2-tutorial/vendor/ZF2/library/Zend/Test/PHPUnit/Controller/AbstractControllerTestCase.php:373\n/var/www/zf2-tutorial/module/Album/test/AlbumTest/Controller/AlbumControllerTest.php:22\n\nFAILURES!\nTests: 1, Assertions: 0, Failures: 1.  The failure message doesn't tell us much, apart from that the expected status\ncode is not 200, but 500. To get a bit more information when something goes\nwrong in a test case, we set the protected  $traceError  member to  true . Add\nthe following just above the  setUp  method in our  AlbumControllerTest  class:  protected $traceError = true;  Running the  phpunit  command again and we should see some more information\nabout what went wrong in our test. The main error message we are interested in\nshould read something like:  Zend\\ServiceManager\\Exception\\ServiceNotFoundException: Zend\\ServiceManager\\ServiceManager::get\nwas unable to fetch or create an instance for Zend\\Db\\Adapter\\Adapter  From this error message it is clear that not all our dependencies are available\nin the service manager. Let us take a look how can we fix this.",
            "title": "A failing test case"
        },
        {
            "location": "/unit-testing/#configuring-the-service-manager-for-the-tests",
            "text": "The error says that the service manager can not create an instance of a database\nadapter for us. The database adapter is indirectly used by our Album\\Model\\AlbumTable  to fetch the list of albums from the database.  The first thought would be to create an instance of an adapter, pass it to the\nservice manager, and let the code run from there as is. The problem with this\napproach is that we would end up with our test cases actually doing queries\nagainst the database. To keep our tests fast, and to reduce the number of\npossible failure points in our tests, this should be avoided.  The second thought would be then to create a mock of the database adapter, and\nprevent the actual database calls by mocking them out. This is a much better\napproach, but creating the adapter mock is tedious (but no doubt we will have to\ncreate it at some point).  The best thing to do would be to mock out our  Album\\Model\\AlbumTable  class\nwhich retrieves the list of albums from the database. Remember, we are now\ntesting our controller, so we can mock out the actual call to  fetchAll  and\nreplace the return values with dummy values. At this point, we are not\ninterested in how  fetchAll  retrieves the albums, but only that it gets called\nand that it returns an array of albums; these facts allow us to provide mock\ninstances. When we test  AlbumTable  itself, we can write the actual tests for\nthe  fetchAll  method.  Here is how we can accomplish this, by modifying the testIndexActionCanBeAccessed  test method as follows:  public function testIndexActionCanBeAccessed()\n{\n    $albumTableMock = $this->getMockBuilder(AlbumTable::class)\n        ->disableOriginalConstructor()\n        ->getMock();\n\n    $albumTableMock->expects($this->once())\n        ->method('fetchAll')\n        ->will($this->returnValue([]));\n\n    $serviceManager = $this->getApplicationServiceLocator();\n    $serviceManager->setAllowOverride(true);\n    $serviceManager->setService(AlbumTable::class, $albumTableMock);\n\n    $this->dispatch('/album');\n    $this->assertResponseStatusCode(200);\n\n    $this->assertModuleName('Album');\n    $this->assertControllerName('Album\\Controller\\Album');\n    $this->assertControllerClass('AlbumController');\n    $this->assertMatchedRouteName('album');\n}  By default, the  ServiceManager  does not allow us to replace existing services.\nAs the  Album\\Model\\AlbumTable  was already set, we are allowing for overrides\n(via the  setAllowOverride()  call), and then replacing the real instance of the AlbumTable  with a mock.  The mock is created so that it will return just an\nempty array when the  fetchAll  method is called. This allows us to test for\nwhat we care about in this test, and that is that by dispatching to the  /album \nURL we get to the Album module's AlbumController.  Running  phpunit  at this point, we will get the following output as the tests\nnow pass:  PHPUnit 5.3.4 by Sebastian Bergmann and contributors.\n\nConfiguration read from /var/www/zf2-tutorial/module/Album/test/phpunit.xml.dist\n\n.\n\nTime: 0 seconds, Memory: 9.00Mb\n\nOK (1 test, 6 assertions)",
            "title": "Configuring the service manager for the tests"
        },
        {
            "location": "/unit-testing/#testing-actions-with-post",
            "text": "One of the most common actions happening in controllers is submitting a form\nwith some POST data; those tests look similar to the following:   :linenos:}\npublic function testAddActionRedirectsAfterValidPost()\n{\n    $albumTableMock = $this->getMockBuilder(AlbumTable::class)\n        ->disableOriginalConstructor()\n        ->getMock();\n\n    $albumTableMock->expects($this->once())\n        ->method('saveAlbum')\n        ->will($this->returnValue(null));\n\n    $serviceManager = $this->getApplicationServiceLocator();\n    $serviceManager->setAllowOverride(true);\n    $serviceManager->setService(AlbumTable::class, $albumTableMock);\n\n    $postData = [\n        'title'  => 'Led Zeppelin III',\n        'artist' => 'Led Zeppelin',\n        'id'     => '',\n    ];\n    $this->dispatch('/album/add', 'POST', $postData);\n    $this->assertResponseStatusCode(302);\n\n    $this->assertRedirectTo('/album/');\n}  Here we test that when we make a POST request against the  /album/add  URL, the Album\\Model\\AlbumTable 's  saveAlbum()  method will be called, and after that\nwe will be redirected back to the  /album  URL.  Running  phpunit  gives us the following output:  PHPUnit 5.3.4 by Sebastian Bergmann and contributors.\n\nConfiguration read from /home/robert/www/zf2-tutorial/module/Album/test/phpunit.xml.dist\n\n..\n\nTime: 0 seconds, Memory: 10.75Mb\n\nOK (2 tests, 9 assertions)  Testing the  editAction()  and  deleteAction()  methods can be easily done in a\nmanner similar as shown for the  addAction() .  When testing the  editAction()  method, you will also need to mock out the getAlbum()  method:  $albumTableMock->expects($this->once())\n    ->method('getAlbum')\n    ->will($this->returnValue(new Album()));",
            "title": "Testing actions with POST"
        },
        {
            "location": "/unit-testing/#testing-model-entities",
            "text": "Now that we know how to test our controllers, let us move to an other important\npart of our application: the model entity.  Here we want to test that the initial state of the entity is what we expect it\nto be, that we can convert the model's parameters to and from an array, and that\nit has all the input filters we need.  Create the file  AlbumTest.php  in  module/Album/test/Model  directory\nwith the following contents:  <?php\nnamespace AlbumTest\\Model;\n\nuse Album\\Model\\Album;\nuse PHPUnit_Framework_TestCase as TestCase;\n\nclass AlbumTest extends TestCase\n{\n    public function testAlbumInitialState()\n    {\n        $album = new Album();\n\n        $this->assertNull(\n            $album->artist,\n            '\"artist\" should initially be null'\n        );\n\n        $this->assertNull(\n            $album->id,\n            '\"id\" should initially be null'\n        );\n\n        $this->assertNull(\n            $album->title,\n            '\"title\" should initially be null'\n        );\n    }\n\n    public function testExchangeArraySetsPropertiesCorrectly()\n    {\n        $album = new Album();\n        $data  = [\n            'artist' => 'some artist',\n            'id'     => 123,\n            'title'  => 'some title'\n        ];\n\n        $album->exchangeArray($data);\n\n        $this->assertSame(\n            $data['artist'],\n            $album->artist,\n            '\"artist\" was not set correctly'\n        );\n\n        $this->assertSame(\n            $data['id'],\n            $album->id,\n            '\"id\" was not set correctly'\n        );\n\n        $this->assertSame(\n            $data['title'],\n            $album->title,\n            '\"title\" was not set correctly'\n        );\n    }\n\n    public function testExchangeArraySetsPropertiesToNullIfKeysAreNotPresent()\n    {\n        $album = new Album();\n\n        $album->exchangeArray([\n            'artist' => 'some artist',\n            'id'     => 123,\n            'title'  => 'some title',\n        ]);\n        $album->exchangeArray([]);\n\n        $this->assertNull(\n            $album->artist,\n            '\"artist\" should have defaulted to null'\n        );\n\n        $this->assertNull(\n            $album->id,\n            '\"id\" should have defaulted to null'\n        );\n\n        $this->assertNull(\n            $album->title,\n            '\"title\" should have defaulted to null'\n        );\n    }\n\n    public function testGetArrayCopyReturnsAnArrayWithPropertyValues()\n    {\n        $album = new Album();\n        $data  = [\n            'artist' => 'some artist',\n            'id'     => 123,\n            'title'  => 'some title'\n        ];\n\n        $album->exchangeArray($data);\n        $copyArray = $album->getArrayCopy();\n\n        $this->assertSame(\n            $data['artist'],\n            $copyArray['artist'],\n            '\"artist\" was not set correctly'\n        );\n\n        $this->assertSame(\n            $data['id'],\n            $copyArray['id'],\n            '\"id\" was not set correctly'\n        );\n\n        $this->assertSame(\n            $data['title'],\n            $copyArray['title'],\n            '\"title\" was not set correctly'\n        );\n    }\n\n    public function testInputFiltersAreSetCorrectly()\n    {\n        $album = new Album();\n\n        $inputFilter = $album->getInputFilter();\n\n        $this->assertSame(3, $inputFilter->count());\n        $this->assertTrue($inputFilter->has('artist'));\n        $this->assertTrue($inputFilter->has('id'));\n        $this->assertTrue($inputFilter->has('title'));\n    }\n}  We are testing for 5 things:   Are all of the  Album 's properties initially set to  NULL ?  Will the  Album 's properties be set correctly when we call  exchangeArray() ?  Will a default value of  NULL  be used for properties whose keys are not present in the  $data  array?  Can we get an array copy of our model?  Do all elements have input filters present?   If we run  phpunit  again, we will get the following output, confirming that our\nmodel is indeed correct:  PHPUnit 5.3.4 by Sebastian Bergmann and contributors.\n\nConfiguration read from /var/www/zf2-tutorial/module/Album/test/phpunit.xml.dist\n\n.......\n\nTime: 0 seconds, Memory: 11.00Mb\n\nOK (7 tests, 25 assertions)",
            "title": "Testing model entities"
        },
        {
            "location": "/unit-testing/#testing-model-tables",
            "text": "The final step in this unit testing tutorial for zend-mvc applications is\nwriting tests for our model tables.  This test assures that we can get a list of albums, or one album by its ID, and\nthat we can save and delete albums from the database.  To avoid actual interaction with the database itself, we will replace certain\nparts with mocks.  Create a file  AlbumTableTest.php  in  module/Album/test/Model  with\nthe following contents:  <?php\nnamespace AlbumTest\\Model;\n\nuse Album\\Model\\AlbumTable;\nuse Album\\Model\\Album;\nuse PHPUnit_Framework_TestCase as TestCase;\nuse Zend\\Db\\ResultSet\\ResultSet;\n\nclass AlbumTableTest extends TestCase\n{\n    public function testFetchAllReturnsAllAlbums()\n    {\n        $resultSet = new ResultSet();\n        $mockTableGateway = $this->getMock(\n            'Zend\\Db\\TableGateway\\TableGateway',\n            ['select'],\n            [],\n            '',\n            false\n        );\n        $mockTableGateway->expects($this->once())\n            ->method('select')\n            ->with()\n            ->will($this->returnValue($resultSet));\n\n        $albumTable = new AlbumTable($mockTableGateway);\n\n        $this->assertSame($resultSet, $albumTable->fetchAll());\n    }\n}  Since we are testing the  AlbumTable  here and not the  TableGateway  class\n(which has already been tested in zend-db), we only want to make sure\nthat our  AlbumTable  class is interacting with the  TableGateway  class the way\nthat we expect it to. Above, we're testing to see if the  fetchAll()  method of AlbumTable  will call the  select()  method of the  $tableGateway  property\nwith no parameters. If it does, it should return a  ResultSet  object. Finally,\nwe expect that this same  ResultSet  object will be returned to the calling\nmethod. This test should run fine, so now we can add the rest of the test\nmethods:  public function testCanRetrieveAnAlbumByItsId()\n{\n    $album = new Album();\n    $album->exchangeArray([\n        'id'     => 123,\n        artist' => 'The Military Wives',\n        title'  => 'In My Dreams'\n    ]);\n\n    $resultSet = new ResultSet();\n    $resultSet->setArrayObjectPrototype(new Album());\n    $resultSet->initialize(array($album));\n\n    $mockTableGateway = $this->getMock(\n        'Zend\\Db\\TableGateway\\TableGateway',\n        ['select'],\n        [],\n        '',\n        false\n    );\n    $mockTableGateway->expects($this->once())\n        ->method('select')\n        ->with(['id' => 123])\n        ->will($this->returnValue($resultSet));\n\n    $albumTable = new AlbumTable($mockTableGateway);\n\n    $this->assertSame($album, $albumTable->getAlbum(123));\n}\n\npublic function testCanDeleteAnAlbumByItsId()\n{\n    $mockTableGateway = $this->getMock(\n        'Zend\\Db\\TableGateway\\TableGateway',\n        ['delete'],\n        [],\n        '',\n        false\n    );\n    $mockTableGateway->expects($this->once())\n        ->method('delete')\n        ->with(['id' => 123]);\n\n    $albumTable = new AlbumTable($mockTableGateway);\n    $albumTable->deleteAlbum(123);\n}\n\npublic function testSaveAlbumWillInsertNewAlbumsIfTheyDontAlreadyHaveAnId()\n{\n    $albumData = [\n        'artist' => 'The Military Wives',\n        'title'  => 'In My Dreams'\n    ];\n    $album = new Album();\n    $album->exchangeArray($albumData);\n\n    $mockTableGateway = $this->getMock(\n        'Zend\\Db\\TableGateway\\TableGateway',\n        ['insert'],\n        [],\n        '',\n        false\n    );\n    $mockTableGateway->expects($this->once())\n        ->method('insert')\n        ->with($albumData);\n\n    $albumTable = new AlbumTable($mockTableGateway);\n    $albumTable->saveAlbum($album);\n}\n\npublic function testSaveAlbumWillUpdateExistingAlbumsIfTheyAlreadyHaveAnId()\n{\n    $albumData = [\n        'id'     => 123,\n        'artist' => 'The Military Wives',\n        'title'  => 'In My Dreams',\n    ];\n    $album = new Album();\n    $album->exchangeArray($albumData);\n\n    $resultSet = new ResultSet();\n    $resultSet->setArrayObjectPrototype(new Album());\n    $resultSet->initialize([$album]);\n\n    $mockTableGateway = $this->getMock(\n        'Zend\\Db\\TableGateway\\TableGateway',\n        ['select', 'update'],\n        [],\n        '',\n        false\n    );\n    $mockTableGateway->expects($this->once())\n        ->method('select')\n        ->with(['id' => 123])\n        ->will($this->returnValue($resultSet));\n    $mockTableGateway->expects($this->once())\n        ->method('update')\n        ->with(\n            [\n                'artist' => 'The Military Wives',\n                'title'  => 'In My Dreams'\n            ],\n            ['id' => 123]\n        );\n\n    $albumTable = new AlbumTable($mockTableGateway);\n    $albumTable->saveAlbum($album);\n}\n\npublic function testExceptionIsThrownWhenGettingNonExistentAlbum()\n{\n    $resultSet = new ResultSet();\n    $resultSet->setArrayObjectPrototype(new Album());\n    $resultSet->initialize([]);\n\n    $mockTableGateway = $this->getMock(\n        'Zend\\Db\\TableGateway\\TableGateway',\n        ['select'],\n        [],\n        '',\n        false\n    );\n    $mockTableGateway->expects($this->once())\n        ->method('select')\n        ->with(['id' => 123])\n        ->will($this->returnValue($resultSet));\n\n    $albumTable = new AlbumTable($mockTableGateway);\n\n    $this->setExpectedException('Exception', 'Could not find row 123');\n    $albumTable->getAlbum(123);\n}  These tests are nothing complicated and they should be self explanatory. In each\ntest we are injecting a mock table gateway into our  AlbumTable , and we then\nset our expectations accordingly.  We are testing that:   We can retrieve an individual album by its ID.  We can delete albums.  We can save a new album.  We can update existing albums.  We will encounter an exception if we're trying to retrieve an album that doesn't exist.   Running  phpunit  one last time, we get the output as follows:  PHPUnit 5.3.4 by Sebastian Bergmann and contributors.\n\nConfiguration read from /var/www/zf2-tutorial/module/Album/test/phpunit.xml.dist\n\n.............\n\nTime: 0 seconds, Memory: 11.50Mb\n\nOK (13 tests, 34 assertions)",
            "title": "Testing model tables"
        },
        {
            "location": "/unit-testing/#conclusion",
            "text": "In this short tutorial, we gave a few examples how different parts of a zend-mvc\napplication can be tested. We covered setting up the environment for testing,\nhow to test controllers and actions, how to approach failing test cases , how to\nconfigure the service manager, as well as how to test model entities and model\ntables .  This tutorial is by no means a definitive guide to writing unit tests, just a\nsmall stepping stone helping you develop applications of higher quality.",
            "title": "Conclusion"
        }
    ]
}